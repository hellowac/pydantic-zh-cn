{"config":{"lang":["ja"],"separator":"[\\s\\-\uff0c\u3002]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"\u6982\u89c8","text":"<p>\u4f7f\u7528 Python \u7c7b\u578b\u6ce8\u89e3\u7684\u6570\u636e\u9a8c\u8bc1\u548c\u8bbe\u7f6e\u7ba1\u7406\u3002</p> <p>pydantic \u5728\u8fd0\u884c\u65f6\u5f3a\u5236\u6267\u884c\u7c7b\u578b\u63d0\u793a\uff0c\u5e76\u5728\u6570\u636e\u65e0\u6548\u65f6\u63d0\u4f9b\u7528\u6237\u53cb\u597d\u7684\u9519\u8bef\u3002</p> <p>\u5b9a\u4e49\u6570\u636e\u5e94\u8be5\u5982\u4f55\u5728\u7eaf\u6b63\u7684\u3001\u89c4\u8303\u7684 Python \u4e2d\uff1b \u7528 pydantic \u9a8c\u8bc1\u5b83\u3002</p>"},{"location":"#sponsors","title":"\u8d5e\u52a9\u5546(Sponsors)","text":"<p>\u4ee5\u4e0b\u8d5e\u52a9\u5546\u4f7f pydantic \u7684\u5f00\u53d1\u6210\u4e3a\u53ef\u80fd\uff1a</p> Salesforce FastAPI AWS Explosion TutorCruncher ExoFlare Robusta SendCloud Jina AI <p>\u8fd8\u6709\u66f4\u591a\u4eba\u5728 GitHub \u8d5e\u52a9\u5546 \u4e0a\u6177\u6168\u8d5e\u52a9 Samuel Colvin\u3002</p>"},{"location":"#example","title":"Example","text":"<pre><code>from datetime import datetime\nfrom typing import List, Optional\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int\n    name = 'John Doe'\n    signup_ts: Optional[datetime] = None\n    friends: List[int] = []\n\n\nexternal_data = {\n    'id': '123',\n    'signup_ts': '2019-06-01 12:22',\n    'friends': [1, 2, '3'],\n}\nuser = User(**external_data)\nprint(user.id)\nprint(repr(user.signup_ts))\nprint(user.friends)\nprint(user.dict())\n</code></pre> <p>\u8fd9\u91cc\u53d1\u751f\u4e86\u4ec0\u4e48\uff1a</p> <ul> <li><code>id</code> \u662f int \u7c7b\u578b\uff1b \u4ec5\u6ce8\u89e3\u58f0\u660e\u544a\u8bc9 pydantic \u8fd9\u4e2a\u5b57\u6bb5\u662f\u5fc5\u9700\u7684\u3002 \u5982\u679c\u53ef\u80fd\uff0c\u5b57\u7b26\u4e32\u3001\u5b57\u8282\u6216\u6d6e\u70b9\u6570\u5c06\u88ab\u5f3a\u5236\u8f6c\u6362\u4e3a\u6574\u6570\uff1b \u5426\u5219\u5c06\u5f15\u53d1\u5f02\u5e38\u3002</li> <li><code>name</code> \u4ece\u63d0\u4f9b\u7684\u9ed8\u8ba4\u503c\u63a8\u65ad\u4e3a\u5b57\u7b26\u4e32\uff1b \u56e0\u4e3a\u5b83\u6709\u4e00\u4e2a\u9ed8\u8ba4\u503c\uff0c\u6240\u4ee5\u5b83\u4e0d\u662f\u5fc5\u9700\u7684\u3002</li> <li><code>signup_ts</code> \u662f\u4e00\u4e2a\u4e0d\u9700\u8981\u7684\u65e5\u671f\u65f6\u95f4\u5b57\u6bb5\uff08\u5982\u679c\u672a\u63d0\u4f9b\u5219\u53d6\u503c <code>None</code>\uff09\u3002   pydantic \u5c06\u5904\u7406 unix \u65f6\u95f4\u6233 int\uff08\u4f8b\u5982 <code>1496498400</code>\uff09\u6216\u8868\u793a\u65e5\u671f\u548c\u65f6\u95f4\u7684\u5b57\u7b26\u4e32\u3002</li> <li><code>friends</code> \u4f7f\u7528 Python \u7684\u7c7b\u578b\u7cfb\u7edf\uff0c\u5e76\u4e14\u9700\u8981\u4e00\u4e2a\u6574\u6570\u5217\u8868\u3002 \u4e0e <code>id</code> \u4e00\u6837\uff0c\u7c7b\u6574\u6570\u5bf9\u8c61\u5c06\u88ab\u8f6c\u6362\u4e3a\u6574\u6570\u3002</li> </ul> <p>\u5982\u679c\u9a8c\u8bc1\u5931\u8d25\uff0cpydantic \u5c06\u5f15\u53d1\u9519\u8bef\u5e76\u8be6\u7ec6\u8bf4\u660e\u9519\u8bef\uff1a</p> <pre><code># output-json\nfrom index_main import User\n\n# ignore-above\nfrom pydantic import ValidationError\n\ntry:\n    User(signup_ts='broken', friends=[1, 2, 'not number'])\nexcept ValidationError as e:\n    print(e.json())\n# requires: User from previous example\n</code></pre>"},{"location":"#rationale","title":"\u57fa\u672c\u539f\u7406(Rationale)","text":"<p>\u6240\u4ee5 pydantic \u4f7f\u7528\u4e86\u4e00\u4e9b\u5f88\u9177\u7684\u65b0\u8bed\u8a00\u7279\u6027\uff0c\u4f46\u6211\u4e3a\u4ec0\u4e48\u8981\u771f\u6b63\u53bb\u4f7f\u7528\u5b83\u5462\uff1f</p> \u4e0e\u60a8\u7684 IDE/linter/brain \u5b8c\u7f8e\u642d\u914d \u65e0\u9700\u5b66\u4e60\u65b0\u7684\u6a21\u5f0f\u5b9a\u4e49\u5fae\u8bed\u8a00\u3002 \u5982\u679c\u60a8\u77e5\u9053\u5982\u4f55\u4f7f\u7528 Python \u7c7b\u578b\u63d0\u793a\uff0c\u60a8\u5c31\u4f1a\u77e5\u9053\u5982\u4f55\u4f7f\u7528 pydantic\u3002 \u6570\u636e\u7ed3\u6784\u53ea\u662f\u60a8\u4f7f\u7528\u7c7b\u578b\u6ce8\u91ca\u5b9a\u4e49\u7684\u7c7b\u7684\u5b9e\u4f8b\uff0c\u56e0\u6b64\u81ea\u52a8\u5b8c\u6210\u3001linting\u3001mypy\u3001IDE\uff08\u5c24\u5176\u662f PyCharm\uff09\u548c\u60a8\u7684\u76f4\u89c9\u90fd\u5e94\u8be5\u6709\u6548 \u6b63\u786e\u4f7f\u7528\u60a8\u7684\u9a8c\u8bc1\u6570\u636e\u3002 \u53cc\u91cd\u7528\u9014 pydantic \u7684 BaseSettings \u7c7b\u5141\u8bb8 pydantic \u5728\u201c\u9a8c\u8bc1\u6b64\u8bf7\u6c42\u6570\u636e\u201d\u4e0a\u4e0b\u6587\u548c\u201c\u52a0\u8f7d\u6211\u7684\u7cfb\u7edf\u8bbe\u7f6e\u201d\u4e0a\u4e0b\u6587\u4e2d\u4f7f\u7528\u3002 \u4e3b\u8981\u533a\u522b\u5728\u4e8e\u7cfb\u7edf\u8bbe\u7f6e\u53ef\u4ee5\u4ece\u73af\u5883\u53d8\u91cf\u4e2d\u8bfb\u53d6\uff0c\u5e76\u4e14\u901a\u5e38\u9700\u8981\u66f4\u590d\u6742\u7684\u5bf9\u8c61\uff0c\u5982 DSN \u548c Python \u5bf9\u8c61\u3002 \u5feb\u901f pydantic \u4e00\u76f4\u5f88\u91cd\u89c6\u6027\u80fd\uff0c\u5927\u90e8\u5206\u5e93\u90fd\u662f\u7528 cython \u7f16\u8bd1\u7684\uff0c\u52a0\u901f\u4e86 ~50%\uff0c\u5b83\u901a\u5e38\u6bd4\u5927\u591a\u6570\u7c7b\u4f3c\u7684\u5e93\u5feb\u6216\u66f4\u5feb\u3002 \u9a8c\u8bc1\u590d\u6742\u7ed3\u6784 \u4f7f\u7528\u9012\u5f52 pydantic \u6a21\u578b\u3001<code>typing</code> \u7684 \u6807\u51c6\u7c7b\u578b\uff08\u4f8b\u5982 <code>List</code>\u3001<code>Tuple</code>\u3001<code>Dict</code> \u7b49\uff09\u548c validators \u5141\u8bb8\u6e05\u6670\u3001\u8f7b\u677e\u5730\u5b9a\u4e49\u3001\u9a8c\u8bc1\u548c\u89e3\u6790\u590d\u6742\u7684\u6570\u636e\u6a21\u5f0f\u3002 \u53ef\u6269\u5c55\u7684 pydantic \u5141\u8bb8\u5b9a\u4e49\u81ea\u5b9a\u4e49\u6570\u636e\u7c7b\u578b\uff0c\u6216\u8005\u60a8\u53ef\u4ee5\u5728\u88c5\u9970\u6709 <code>validator</code> \u7684\u6a21\u578b\u4e0a\u4f7f\u7528\u65b9\u6cd5\u6269\u5c55\u9a8c\u8bc1\u88c5\u9970\u5668\u3002 \u6570\u636e\u7c7b\u6574\u5408 \u9664\u4e86 <code>BaseModel</code> \u4e4b\u5916\uff0cpydantic \u8fd8\u63d0\u4f9b\u4e86\u4e00\u4e2a <code>dataclass</code> \u88c5\u9970\u5668\uff0c\u5b83\u521b\u5efa\uff08\u51e0\u4e4e\uff09\u5e26\u6709\u8f93\u5165\u6570\u636e\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u666e\u901a Python \u6570\u636e\u7c7b\u3002"},{"location":"#pydanticusing-pydantic","title":"\u4f7f\u7528 Pydantic(Using Pydantic)","text":"<p>\u6570\u767e\u4e2a\u7ec4\u7ec7\u548c\u8f6f\u4ef6\u5305\u6b63\u5728\u4f7f\u7528 pydantic\uff0c\u5305\u62ec\uff1a</p> FastAPI \u57fa\u4e8epydantic \u548c Starlette \u7684\u9ad8\u6027\u80fd API \u6846\u67b6\uff0c\u6613\u4e8e\u5b66\u4e60\uff0c\u7f16\u7801\u901f\u5ea6\u5feb\uff0c\u53ef\u7528\u4e8e\u751f\u4ea7\u3002 Project Jupyter Jupyter notebook \u7684\u5f00\u53d1\u4eba\u5458\u6b63\u5728\u4f7f\u7528 pydantic \u7528\u4e8e\u5b50\u9879\u76ee\uff0c\u901a\u8fc7\u57fa\u4e8e FastAPI \u7684 Jupyter \u670d\u52a1\u5668 Jupyverse\uff0c\u4ee5\u53ca FPS \u7684\u914d\u7f6e\u7ba1\u7406\u3002 Microsoft \u6b63\u5728\u5c06 pydantic\uff08\u901a\u8fc7 FastAPI\uff09\u7528\u4e8e \u4f17\u591a\u670d\u52a1\uff0c\u5176\u4e2d\u4e00\u4e9b\u6b63\u5728\u201c\u96c6\u6210\u5230\u6838\u5fc3 Windows \u4ea7\u54c1\u4e2d\uff0c\u4e00\u4e9b \u529e\u516c\u7528\u54c1\u3002\u201d Amazon Web Services \u5728 gluon-ts \u4e2d\u4f7f\u7528 pydantic\uff0c\u8fd9\u662f\u4e00\u4e2a\u5f00\u6e90\u6982\u7387\u65f6\u95f4\u5e8f\u5217\u5efa\u6a21\u5e93\u3002 The NSA \u5728\u5f00\u6e90\u81ea\u52a8\u5316\u6846\u67b6 WALKOFF \u4e2d\u4f7f\u7528 pydantic\u3002 Uber \u5728 Ludwig \u4e2d\u4f7f\u7528 pydantic\uff0c\u8fd9\u662f\u4e00\u4e2a\u5f00\u6e90 TensorFlow \u5305\u88c5\u5668\u3002 Cuenca \u662f\u4e00\u5bb6\u58a8\u897f\u54e5\u65b0\u94f6\u884c\uff0c\u5b83\u4f7f\u7528 pydantic \u7528\u4e8e\u591a\u4e2a\u5185\u90e8\u5de5\u5177\uff08\u5305\u62ec API \u9a8c\u8bc1\uff09\u548c\u5f00\u6e90\u9879\u76ee\uff0c\u5982 stpmex\uff0c\u7528\u4e8e\u5904\u7406 \u58a8\u897f\u54e5\u5b9e\u65f6 24/7 \u94f6\u884c\u95f4\u8f6c\u8d26\u3002 \u5206\u5b50\u79d1\u5b66\u8f6f\u4ef6\u7814\u7a76\u6240 \u5728 QCFractal \u4e2d\u4f7f\u7528 pydantic\uff0c\u8fd9\u662f\u4e00\u4e2a\u7528\u4e8e\u91cf\u5b50\u5316\u5b66\u7684\u5927\u89c4\u6a21\u5206\u5e03\u5f0f\u8ba1\u7b97\u6846\u67b6\u3002 Reach \u4fe1\u4efb pydantic\uff08\u901a\u8fc7 FastAPI\uff09\u548c arq\uff08Samuel \u51fa\u8272\u7684\u5f02\u6b65\u4efb\u52a1\u961f\u5217\uff09\u6765\u53ef\u9760\u5730\u652f\u6301\u591a\u4e2a\u5173\u952e\u4efb\u52a1\u5fae\u670d\u52a1\u3002 Robusta.dev \u6b63\u5728\u4f7f\u7528 pydantic \u6765\u81ea\u52a8\u5316 Kubernetes \u6545\u969c\u6392\u9664\u548c\u7ef4\u62a4\u3002 \u4f8b\u5982\uff0c\u4ed6\u4eec\u7684\u5f00\u6e90 \u5728 Kubernetes \u4e0a\u8c03\u8bd5\u548c\u5206\u6790 Python \u5e94\u7528\u7a0b\u5e8f\u7684\u5de5\u5177 \u4f7f\u7528 pydantic \u6a21\u578b\u3002 <p>\u6709\u5173\u4f7f\u7528 pydantic \u7684\u66f4\u5168\u9762\u7684\u5f00\u6e90\u9879\u76ee\u5217\u8868\uff0c\u8bf7\u53c2\u9605 github \u4e0a\u7684\u4f9d\u8d56\u5217\u8868\u3002</p>"},{"location":"#pydantic-discussion-of-pydantic","title":"\u5bf9 Pydantic \u7684\u8ba8\u8bba(Discussion of Pydantic)","text":"<p>\u8ba8\u8bba pydantic \u7684\u64ad\u5ba2\u548c\u89c6\u9891\u3002</p> Talk Python To Me pydantic \u7684\u521b\u59cb\u4eba\u8fc8\u514b\u5c14\u00b7\u80af\u5c3c\u8fea (Michael Kennedy) \u548c\u585e\u7f2a\u5c14\u00b7\u79d1\u5c14\u6587 (Samuel Colvin) \u6df1\u5165\u63a2\u8ba8\u4e86 pydantic \u7684\u5386\u53f2\u53ca\u5176\u4f17\u591a\u7528\u9014\u548c\u597d\u5904\u3002 Podcast.__init__ \u4e0e pydantic \u7684\u521b\u9020\u8005 Samuel Colvin \u8ba8\u8bba pydantic \u7684\u8d77\u6e90\u4ee5\u53ca\u5b83\u4e0b\u4e00\u6b65\u53ef\u80fd\u8d70\u5411\u4f55\u65b9\u7684\u60f3\u6cd5\u3002 Python Bytes Podcast \u201c\u8fd9\u662f\u4e00\u4e2a\u53ef\u7231\u7684\u7b80\u5355\u6846\u67b6\uff0c\u89e3\u51b3\u4e86\u4e00\u4e9b\u975e\u5e38\u597d\u7684\u95ee\u9898......\u4f7f\u7528 Python \u7c7b\u578b\u6ce8\u91ca\u7684\u6570\u636e\u9a8c\u8bc1\u548c\u8bbe\u7f6e\u7ba1\u7406\uff0c\u6b63\u662f Python \u7c7b\u578b\u6ce8\u91ca\u8ba9\u6211\u975e\u5e38\u9ad8\u5174......\u5b83\u81ea\u52a8\u4e0e\u4f60\u7684\u6240\u6709 IDE \u4e00\u8d77\u5de5\u4f5c \u5df2\u7ecf\u6709\u4e86\u3002\u201d\u2014\u2014\u8fc8\u514b\u5c14\u00b7\u80af\u5c3c\u8fea Python pydantic Introduction \u2013 \u8d4b\u4e88\u6570\u636e\u7c7b\u8d85\u80fd\u529b Alexander Hultn\u00e9r \u6700\u521d\u5728 Python Pizza \u5927\u4f1a\u4e0a\u7684\u6f14\u8bb2\uff0c\u5411\u65b0\u7528\u6237\u4ecb\u7ecd\u4e86 pydantic \u5e76\u4ecb\u7ecd\u4e86 pydantic \u7684\u6838\u5fc3\u529f\u80fd\u3002"},{"location":"changelog/","title":"\u66f4\u65b0\u65e5\u5fd7","text":"<p>```</p>"},{"location":"contributing/","title":"\u8d21\u732e\u53c2\u4e0e","text":"<p>We'd love you to contribute to pydantic!</p>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as discussions or issues. However, to report a security vulnerability, please see our security policy.</p> <p>To make it as simple as possible for us to help you, please include the output of the following call in your issue:</p> <p><pre><code>python -c \"import pydantic.utils; print(pydantic.utils.version_info())\"\n</code></pre> If you're using pydantic prior to v1.3 (when <code>version_info()</code> was added), please manually include OS, Python version and pydantic version.</p> <p>Please try to always include the above unless you're unable to install pydantic or know it's not relevant to your question or feature request.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>It should be extremely simple to get started and create a Pull Request. pydantic is released regularly so you should see your improvements release in a matter of days or weeks.</p> <p>Note</p> <p>Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request.</p> <p>If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.</p> <p>To make contributing as easy and fast as possible, you'll want to run tests and linting locally. Luckily, pydantic has few dependencies, doesn't require compiling and tests don't need access to databases, etc. Because of this, setting up and running the tests should be very simple.</p> <p>You'll need to have a version between Python 3.7 and 3.11, virtualenv, git, and make installed.</p> <pre><code># 1. clone your fork and cd into the repo directory\ngit clone git@github.com:&lt;your username&gt;/pydantic.git\ncd pydantic\n\n# 2. Set up a virtualenv for running tests\nvirtualenv -p `which python3.8` env\nsource env/bin/activate\n# Building docs requires 3.8. If you don't need to build docs you can use\n# whichever version; 3.7 will work too.\n\n# 3. Install pydantic, dependencies, test dependencies and doc dependencies\nmake install\n\n# 4. Checkout a new branch and make your changes\ngit checkout -b my-new-feature-branch\n# make your changes...\n\n# 5. Fix formatting and imports\nmake format\n# Pydantic uses black to enforce formatting and isort to fix imports\n# (https://github.com/ambv/black, https://github.com/timothycrosley/isort)\n\n# 6. Run tests and linting\nmake\n# there are a few sub-commands in Makefile like `test`, `testcov` and `lint`\n# which you might want to use, but generally just `make` should be all you need\n\n# 7. Build documentation\nmake docs\n# if you have changed the documentation make sure it builds successfully\n# you can also use `make docs-serve` to serve the documentation at localhost:8000\n\n# ... commit, push, and create your pull request\n</code></pre> <p>tl;dr: use <code>make format</code> to fix formatting, <code>make</code> to run tests and linting &amp; <code>make docs</code> to build the docs.</p>"},{"location":"datamodel_code_generator/","title":"\u4ee3\u7801\u751f\u6210","text":"<p>The datamodel-code-generator project is a library and command-line utility to generate pydantic models from just about any data source, including:</p> <ul> <li>OpenAPI 3 (YAML/JSON)</li> <li>JSON Schema</li> <li>JSON/YAML Data (which will converted to JSON Schema)</li> </ul> <p>Whenever you find yourself with any data convertible JSON but without pydantic models, this tool will allow you to generate type-safe model hierarchies on demand.</p>"},{"location":"datamodel_code_generator/#installation","title":"Installation","text":"<pre><code>pip install datamodel-code-generator\n</code></pre>"},{"location":"datamodel_code_generator/#example","title":"Example","text":"<p>In this case, datamodel-code-generator creates pydantic models from a JSON Schema file. <pre><code>datamodel-codegen  --input person.json --input-file-type jsonschema --output model.py\n</code></pre></p> <p>person.json: <pre><code>{\n\"$id\": \"person.json\",\n\"$schema\": \"http://json-schema.org/draft-07/schema#\",\n\"title\": \"Person\",\n\"type\": \"object\",\n\"properties\": {\n\"first_name\": {\n\"type\": \"string\",\n\"description\": \"The person's first name.\"\n},\n\"last_name\": {\n\"type\": \"string\",\n\"description\": \"The person's last name.\"\n},\n\"age\": {\n\"description\": \"Age in years.\",\n\"type\": \"integer\",\n\"minimum\": 0\n},\n\"pets\": {\n\"type\": \"array\",\n\"items\": [\n{\n\"$ref\": \"#/definitions/Pet\"\n}\n]\n},\n\"comment\": {\n\"type\": \"null\"\n}\n},\n\"required\": [\n\"first_name\",\n\"last_name\"\n],\n\"definitions\": {\n\"Pet\": {\n\"properties\": {\n\"name\": {\n\"type\": \"string\"\n},\n\"age\": {\n\"type\": \"integer\"\n}\n}\n}\n}\n}\n</code></pre></p> <p>model.py: <pre><code># dont-upgrade\n# generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2020-05-19T15:07:31+00:00\nfrom __future__ import annotations\nfrom typing import Any, List, Optional\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Pet(BaseModel):\n    name: Optional[str] = None\n    age: Optional[int] = None\n\n\nclass Person(BaseModel):\n    first_name: str = Field(..., description=\"The person's first name.\")\n    last_name: str = Field(..., description=\"The person's last name.\")\n    age: Optional[conint(ge=0)] = Field(None, description='Age in years.')\n    pets: Optional[List[Pet]] = None\n    comment: Optional[Any] = None\n</code></pre></p> <p>More information can be found on the official documentation</p>"},{"location":"hypothesis_plugin/","title":"Hypothesis\u63d2\u4ef6'","text":"<p>Hypothesis is the Python library for property-based testing. Hypothesis can infer how to construct type-annotated classes, and supports builtin types, many standard library types, and generic types from the <code>typing</code> and <code>typing_extensions</code> modules by default.</p> <p>From Pydantic v1.8 and Hypothesis v5.29.0, Hypothesis will automatically load support for custom types like <code>PaymentCardNumber</code> and <code>PositiveFloat</code>, so that the <code>st.builds()</code> and <code>st.from_type()</code> strategies support them without any user configuration.</p> <p>Warning</p> <p>Please note, while the plugin supports these types, hypothesis will(currently) generate values outside  of given args for the constrained function types.</p>"},{"location":"hypothesis_plugin/#example-tests","title":"Example tests","text":"<pre><code>import typing\nfrom hypothesis import given, strategies as st\nfrom pydantic import BaseModel, EmailStr, PaymentCardNumber, PositiveFloat\n\n\nclass Model(BaseModel):\n    card: PaymentCardNumber\n    price: PositiveFloat\n    users: typing.List[EmailStr]\n\n\n@given(st.builds(Model))\ndef test_property(instance):\n    # Hypothesis calls this test function many times with varied Models,\n    # so you can write a test that should pass given *any* instance.\n    assert 0 &lt; instance.price\n    assert all('@' in email for email in instance.users)\n\n\n@given(st.builds(Model, price=st.floats(100, 200)))\ndef test_with_discount(instance):\n    # This test shows how you can override specific fields,\n    # and let Hypothesis fill in any you don't care about.\n    assert 100 &lt;= instance.price &lt;= 200\n</code></pre>"},{"location":"hypothesis_plugin/#use-with-json-schemas","title":"Use with JSON Schemas","text":"<p>To test client-side code, you can use <code>Model.schema()</code> with the <code>hypothesis-jsonschema</code> package to generate arbitrary JSON instances matching the schema. For web API testing, Schemathesis provides a higher-level wrapper and can detect both errors and security vulnerabilities.</p>"},{"location":"install/","title":"\u5b89\u88c5","text":"<p>\u5b89\u88c5\u975e\u5e38\u7b80\u5355\uff1a</p> <pre><code>pip install pydantic\n</code></pre> <p>pydantic \u9664\u4e86 Python 3.7\u30013.8\u30013.9\u30013.10 \u6216 3.11 \u548c <code>typing-extensions</code> \u4e4b\u5916\u6ca1\u6709\u4efb\u4f55\u5fc5\u9700\u7684\u4f9d\u8d56\u9879\u3002 \u5982\u679c\u60a8\u5df2\u7ecf\u5b89\u88c5\u4e86 Python 3.7+ \u548c <code>pip</code>\uff0c\u90a3\u4e48\u60a8\u5c31\u53ef\u4ee5\u5f00\u59cb\u4e86\u3002</p> <p>Pydantic \u4e5f\u53ef\u4ee5\u5728 conda \u7684 conda-forge \u9891\u9053\u4e0b\u83b7\u5f97\uff1a</p> <pre><code>conda install pydantic -c conda-forge\n</code></pre>"},{"location":"install/#cython-compiled-with-cython","title":"\u7528 Cython \u7f16\u8bd1(Compiled with Cython)","text":"<p>pydantic \u53ef\u4ee5\u9009\u62e9\u4f7f\u7528 cython \u8fdb\u884c\u7f16\u8bd1\uff0c\u8fd9\u5e94\u8be5\u4f1a\u5e26\u6765 30-50% \u7684\u6027\u80fd\u63d0\u5347\u3002</p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c<code>pip install</code> \u901a\u8fc7 PyPI \u4e3a Linux\u3001MacOS \u548c 64 \u4f4d Windows \u63d0\u4f9b\u4f18\u5316\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u3002</p> <p>\u5982\u679c\u60a8\u624b\u52a8\u5b89\u88c5\uff0c\u8bf7\u5728\u5b89\u88c5 pydantic \u4e4b\u524d\u5b89\u88c5 <code>cython</code>\uff0c\u7f16\u8bd1\u5e94\u8be5\u4f1a\u81ea\u52a8\u8fdb\u884c\u3002</p> <p>\u8981\u6d4b\u8bd5 pydantic \u662f\u5426\u7f16\u8bd1\u8fd0\u884c\uff1a</p> <pre><code>import pydantic\nprint('compiled:', pydantic.compiled)\n</code></pre>"},{"location":"install/#performance-vs-package-size-trade-off","title":"\u6027\u80fd\u4e0e\u6253\u5305\u5c3a\u5bf8\u7684\u6743\u8861(Performance vs package size trade-off)","text":"<p>\u7f16\u8bd1\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u4f1a\u589e\u52a0 Python \u73af\u5883\u7684\u5927\u5c0f\u3002 \u5982\u679c\u51fa\u4e8e\u67d0\u79cd\u539f\u56e0\u4f60\u60f3\u51cf\u5c11 pydantic \u5b89\u88c5\u7684\u5927\u5c0f\uff0c\u4f60\u53ef\u4ee5\u907f\u514d\u4f7f\u7528 <code>pip --no-binary</code> \u9009\u9879\u3002 \u786e\u4fdd <code>Cython</code> \u4e0d\u5728\u60a8\u7684\u73af\u5883\u4e2d\uff0c\u6216\u8005\u60a8\u8bbe\u7f6e\u4e86 <code>SKIP_CYTHON</code> \u73af\u5883\u53d8\u91cf\u4ee5\u907f\u514d\u91cd\u65b0\u7f16\u8bd1 pydantic \u5e93\uff1a</p> <pre><code>SKIP_CYTHON=1 pip install --no-binary pydantic pydantic\n</code></pre> <p>Note</p> <p><code>pydantic</code> \u5728\u8fd9\u91cc\u6709\u610f\u91cd\u590d\uff0c <code>--no-binary pydantic</code> \u544a\u8bc9 <code>pip</code> \u4f60\u4e0d\u9700\u8981 pydantic \u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u4e0b\u4e00\u6b65 <code>pydantic</code> \u544a\u8bc9 <code>pip</code> \u8981\u5b89\u88c5\u54ea\u4e2a\u5305\u3002</p> <p>\u6216\u8005\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u81ea\u5b9a\u4e49 \u6784\u5efa\u9009\u9879 \u91cd\u65b0\u7f16\u8bd1 pydantic\uff0c\u8fd9\u9700\u8981 <code>Cython</code> \u5728\u91cd\u65b0\u7f16\u8bd1 pydantic \u4e4b\u524d\u5b89\u88c5\u7684\u5305\uff1a</p> <pre><code>CFLAGS=\"-Os -g0 -s\" pip install \\\n--no-binary pydantic \\\n--global-option=build_ext \\\npydantic\n</code></pre>"},{"location":"install/#optional-dependencies","title":"\u53ef\u9009\u4f9d\u8d56\u9879(Optional dependencies)","text":"<p>pydantic \u6709\u4e24\u4e2a\u53ef\u9009\u7684\u4f9d\u8d56\u9879\uff1a</p> <ul> <li>\u5982\u679c\u60a8\u9700\u8981\u7535\u5b50\u90ae\u4ef6\u9a8c\u8bc1\uff0c\u60a8\u53ef\u4ee5\u6dfb\u52a0 email-validator</li> <li>dotenv \u6587\u4ef6\u652f\u6301 \u5176 <code>Settings</code> \u9700\u8981   python-dotenv</li> </ul> <p>\u8981\u5c06\u5b83\u4eec\u4e0e pydantic \u4e00\u8d77\u5b89\u88c5\uff1a</p> <pre><code>pip install pydantic[email]\n# or\npip install pydantic[dotenv]\n# or just\npip install pydantic[email,dotenv]\n</code></pre> <p>\u5f53\u7136\uff0c\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528<code>pip install email-validator</code>\u548c/\u6216<code>pip install python-dotenv</code>\u624b\u52a8\u5b89\u88c5\u8fd9\u4e9b\u8981\u6c42\u3002</p>"},{"location":"install/#install-from-repository","title":"\u4ece\u5b58\u50a8\u5e93\u5b89\u88c5(Install from repository)","text":"<p>\u5982\u679c\u60a8\u66f4\u559c\u6b22\u76f4\u63a5\u4ece\u5b58\u50a8\u5e93\u5b89\u88c5 pydantic\uff1a</p> <pre><code>pip install git+git://github.com/pydantic/pydantic@main#egg=pydantic\n# or with extras\npip install git+git://github.com/pydantic/pydantic@main#egg=pydantic[email,dotenv]\n</code></pre>"},{"location":"mypy_plugin/","title":"Mypy\u63d2\u4ef6","text":"<p>Pydantic works well with mypy right out of the box.</p> <p>However, Pydantic also ships with a mypy plugin that adds a number of important pydantic-specific features to mypy that improve its ability to type-check your code.</p> <p>For example, consider the following script: <pre><code># dont-execute\nfrom datetime import datetime\nfrom typing import List, Optional\nfrom pydantic import BaseModel, NoneStr\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: NoneStr = None\n    signup_ts: Optional[datetime] = None\n    list_of_ints: List[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n</code></pre></p> <p>Without any special configuration, mypy catches one of the errors (see here for usage instructions): <pre><code>13: error: \"Model\" has no attribute \"middle_name\"\n</code></pre></p> <p>But with the plugin enabled, it catches both: <pre><code>13: error: \"Model\" has no attribute \"middle_name\"\n16: error: Missing named argument \"age\" for \"Model\"\n16: error: Missing named argument \"list_of_ints\" for \"Model\"\n</code></pre></p> <p>With the pydantic mypy plugin, you can fearlessly refactor your models knowing mypy will catch any mistakes if your field names or types change.</p> <p>There are other benefits too! See below for more details.</p>"},{"location":"mypy_plugin/#plugin-capabilities","title":"Plugin Capabilities","text":""},{"location":"mypy_plugin/#generate-a-signature-for-model__init__","title":"Generate a signature for <code>Model.__init__</code>","text":"<ul> <li>Any required fields that don't have dynamically-determined aliases will be included as required   keyword arguments.</li> <li>If <code>Config.allow_population_by_field_name=True</code>, the generated signature will use the field names,   rather than aliases.</li> <li>For subclasses of <code>BaseSettings</code>, all fields are treated as optional since they may be   read from the environment.</li> <li>If <code>Config.extra=\"forbid\"</code> and you don't make use of dynamically-determined aliases, the generated signature   will not allow unexpected inputs.</li> <li>Optional: If the <code>init_forbid_extra</code> plugin setting is set to <code>True</code>, unexpected inputs to   <code>__init__</code> will raise errors even if <code>Config.extra</code> is not <code>\"forbid\"</code>.</li> <li>Optional: If the <code>init_typed</code> plugin setting is set to <code>True</code>, the generated signature   will use the types of the model fields (otherwise they will be annotated as <code>Any</code> to allow parsing).</li> </ul>"},{"location":"mypy_plugin/#generate-a-typed-signature-for-modelconstruct","title":"Generate a typed signature for <code>Model.construct</code>","text":"<ul> <li>The <code>construct</code> method is a faster alternative to <code>__init__</code>   when input data is known to be valid and does not need to be parsed. But because this method performs no runtime   validation, static checking is important to detect errors.</li> </ul>"},{"location":"mypy_plugin/#respect-configallow_mutation","title":"Respect <code>Config.allow_mutation</code>","text":"<ul> <li>If <code>Config.allow_mutation</code> is <code>False</code>, you'll get a mypy error if you try to change   the value of a model field; cf. faux immutability.</li> </ul>"},{"location":"mypy_plugin/#respect-configorm_mode","title":"Respect <code>Config.orm_mode</code>","text":"<ul> <li>If <code>Config.orm_mode</code> is <code>False</code>, you'll get a mypy error if you try to call <code>.from_orm()</code>;   cf. ORM mode</li> </ul>"},{"location":"mypy_plugin/#generate-a-signature-for-dataclasses","title":"Generate a signature for <code>dataclasses</code>","text":"<ul> <li>classes decorated with <code>@pydantic.dataclasses.dataclass</code> are type checked the same as standard Python dataclasses</li> <li>The <code>@pydantic.dataclasses.dataclass</code> decorator accepts a <code>config</code> keyword argument which has the same meaning as the <code>Config</code> sub-class.</li> </ul>"},{"location":"mypy_plugin/#respect-the-type-of-the-fields-default-and-default_factory","title":"Respect the type of the <code>Field</code>'s <code>default</code> and <code>default_factory</code>","text":"<ul> <li>Field with both a <code>default</code> and a <code>default_factory</code> will result in an error during static checking.</li> <li>The type of the <code>default</code> and <code>default_factory</code> value must be compatible with the one of the field.</li> </ul>"},{"location":"mypy_plugin/#optional-capabilities","title":"Optional Capabilities:","text":""},{"location":"mypy_plugin/#prevent-the-use-of-required-dynamic-aliases","title":"Prevent the use of required dynamic aliases","text":"<ul> <li>If the <code>warn_required_dynamic_aliases</code> plugin setting is set to <code>True</code>, you'll get a mypy   error any time you use a dynamically-determined alias or alias generator on a model with   <code>Config.allow_population_by_field_name=False</code>.</li> <li>This is important because if such aliases are present, mypy cannot properly type check calls to <code>__init__</code>.   In this case, it will default to treating all arguments as optional.</li> </ul>"},{"location":"mypy_plugin/#prevent-the-use-of-untyped-fields","title":"Prevent the use of untyped fields","text":"<ul> <li>If the <code>warn_untyped_fields</code> plugin setting is set to <code>True</code>, you'll get a mypy error   any time you create a field on a model without annotating its type.</li> <li>This is important because non-annotated fields may result in   validators being applied in a surprising order.</li> <li>In addition, mypy may not be able to correctly infer the type of the field, and may miss   checks or raise spurious errors.</li> </ul>"},{"location":"mypy_plugin/#enabling-the-plugin","title":"Enabling the Plugin","text":"<p>To enable the plugin, just add <code>pydantic.mypy</code> to the list of plugins in your mypy config file (this could be <code>mypy.ini</code> or <code>setup.cfg</code>).</p> <p>To get started, all you need to do is create a <code>mypy.ini</code> file with following contents: <pre><code>[mypy]\nplugins = pydantic.mypy\n</code></pre></p> <p>The plugin is compatible with mypy versions <code>&gt;=0.910</code>.</p> <p>See the mypy usage and plugin configuration docs for more details.</p>"},{"location":"mypy_plugin/#plugin-settings","title":"Plugin Settings","text":"<p>The plugin offers a few optional strictness flags if you want even stronger checks:</p> <ul> <li><code>init_forbid_extra</code><p>If enabled, disallow extra arguments to the <code>__init__</code> call even when <code>Config.extra</code> is not <code>\"forbid\"</code>.</p> </li> </ul> <ul> <li><code>init_typed</code><p>If enabled, include the field types as type hints in the generated signature for the <code>__init__</code> method.   This means that you'll get mypy errors if you pass an argument that is not already the right type to   <code>__init__</code>, even if parsing could safely convert the type.</p> </li> </ul> <ul> <li><code>warn_required_dynamic_aliases</code><p>If enabled, raise a mypy error whenever a model is created for which   calls to its <code>__init__</code> or <code>construct</code> methods require the use of aliases that cannot be statically determined.   This is the case, for example, if <code>allow_population_by_field_name=False</code> and the model uses an alias generator.</p> </li> </ul> <ul> <li><code>warn_untyped_fields</code><p>If enabled, raise a mypy error whenever a field is declared on a model without explicitly specifying its type.</p> </li> </ul>"},{"location":"mypy_plugin/#configuring-the-plugin","title":"Configuring the Plugin","text":"<p>To change the values of the plugin settings, create a section in your mypy config file called <code>[pydantic-mypy]</code>, and add any key-value pairs for settings you want to override.</p> <p>A <code>mypy.ini</code> file with all plugin strictness flags enabled (and some other mypy strictness flags, too) might look like: <pre><code>[mypy]\nplugins = pydantic.mypy\n\nfollow_imports = silent\nwarn_redundant_casts = True\nwarn_unused_ignores = True\ndisallow_any_generics = True\ncheck_untyped_defs = True\nno_implicit_reexport = True\n\n# for strict mypy: (this is the tricky one :-))\ndisallow_untyped_defs = True\n\n[pydantic-mypy]\ninit_forbid_extra = True\ninit_typed = True\nwarn_required_dynamic_aliases = True\nwarn_untyped_fields = True\n</code></pre></p> <p>As of <code>mypy&gt;=0.900</code>, mypy config may also be included in the <code>pyproject.toml</code> file rather than <code>mypy.ini</code>. The same configuration as above would be: <pre><code>[tool.mypy]\nplugins = [\n\"pydantic.mypy\"\n]\n\nfollow_imports = \"silent\"\nwarn_redundant_casts = true\nwarn_unused_ignores = true\ndisallow_any_generics = true\ncheck_untyped_defs = true\nno_implicit_reexport = true\n\n# for strict mypy: (this is the tricky one :-))\ndisallow_untyped_defs = true\n\n[tool.pydantic-mypy]\ninit_forbid_extra = true\ninit_typed = true\nwarn_required_dynamic_aliases = true\nwarn_untyped_fields = true\n</code></pre></p>"},{"location":"pycharm_plugin/","title":"PyCharm\u63d2\u4ef6","text":"<p>While pydantic will work well with any IDE out of the box, a  PyCharm plugin offering improved pydantic integration is available on the JetBrains Plugins Repository for PyCharm. You can install the plugin for free from the plugin marketplace (PyCharm's Preferences -&gt; Plugin -&gt; Marketplace -&gt; search \"pydantic\").</p> <p>The plugin currently supports the following features:</p> <ul> <li>For <code>pydantic.BaseModel.__init__</code>:<ul> <li>Inspection</li> <li>Autocompletion</li> <li>Type-checking</li> </ul> </li> </ul> <ul> <li>For fields of <code>pydantic.BaseModel</code>:<ul> <li>Refactor-renaming fields updates <code>__init__</code> calls, and affects sub- and super-classes</li> <li>Refactor-renaming <code>__init__</code> keyword arguments updates field names, and affects sub- and super-classes</li> </ul> </li> </ul> <p>More information can be found on the official plugin page and Github repository.</p>"},{"location":"visual_studio_code/","title":"VSCode\u4f7f\u7528","text":"<p>pydantic works well with any editor or IDE out of the box because it's made on top of standard Python type annotations.</p> <p>When using Visual Studio Code (VS Code), there are some additional editor features supported, comparable to the ones provided by the PyCharm plugin.</p> <p>This means that you will have autocompletion (or \"IntelliSense\") and error checks for types and required arguments even while creating new pydantic model instances.</p> <p></p>"},{"location":"visual_studio_code/#configure-vs-code","title":"Configure VS Code","text":"<p>To take advantage of these features, you need to make sure you configure VS Code correctly, using the recommended settings.</p> <p>In case you have a different configuration, here's a short overview of the steps.</p>"},{"location":"visual_studio_code/#install-pylance","title":"Install Pylance","text":"<p>You should use the Pylance extension for VS Code. It is the recommended, next-generation, official VS Code plug-in for Python.</p> <p>Pylance is installed as part of the Python Extension for VS Code by default, so it should probably just work. Otherwise, you can double check it's installed and enabled in your editor.</p>"},{"location":"visual_studio_code/#configure-your-environment","title":"Configure your environment","text":"<p>Then you need to make sure your editor knows the Python environment (probably a virtual environment) for your Python project.</p> <p>This would be the environment in where you installed pydantic.</p>"},{"location":"visual_studio_code/#configure-pylance","title":"Configure Pylance","text":"<p>With the default configurations, you will get support for autocompletion, but Pylance might not check for type errors.</p> <p>You can enable type error checks from Pylance with these steps:</p> <ul> <li>Open the \"User Settings\"</li> <li>Search for <code>Type Checking Mode</code></li> <li>You will find an option under <code>Python \u203a Analysis: Type Checking Mode</code></li> <li>Set it to <code>basic</code> or <code>strict</code> (by default it's <code>off</code>)</li> </ul> <p></p> <p>Now you will not only get autocompletion when creating new pydantic model instances but also error checks for required arguments.</p> <p></p> <p>And you will also get error checks for invalid data types.</p> <p></p> <p>Technical Details</p> <p>Pylance is the VS Code extension, it's closed source, but free to use. Underneath, Pylance uses an open source tool (also from Microsoft) called Pyright that does all the heavy lifting.</p> <p>You can read more about it in the Pylance Frequently Asked Questions.</p>"},{"location":"visual_studio_code/#configure-mypy","title":"Configure mypy","text":"<p>You might also want to configure mypy in VS Code to get mypy error checks inline in your editor (alternatively/additionally to Pylance).</p> <p>This would include the errors detected by the pydantic mypy plugin, if you configured it.</p> <p>To enable mypy in VS Code, do the following:</p> <ul> <li>Open the \"User Settings\"</li> <li>Search for <code>Mypy Enabled</code></li> <li>You will find an option under <code>Python \u203a Linting: Mypy Enabled</code></li> <li>Check the box (by default it's unchecked)</li> </ul> <p></p>"},{"location":"visual_studio_code/#tips-and-tricks","title":"Tips and tricks","text":"<p>Here are some additional tips and tricks to improve your developer experience when using VS Code with pydantic.</p>"},{"location":"visual_studio_code/#strict-errors","title":"Strict errors","text":"<p>The way this additional editor support works is that Pylance will treat your pydantic models as if they were Python's pure <code>dataclasses</code>.</p> <p>And it will show strict type error checks about the data types passed in arguments when creating a new pydantic model instance.</p> <p>In this example you can see that it shows that a <code>str</code> of <code>'23'</code> is not a valid <code>int</code> for the argument <code>age</code>.</p> <p></p> <p>It would expect <code>age=23</code> instead of <code>age='23'</code>.</p> <p>Nevertheless, the design, and one of the main features of pydantic, is that it is very lenient with data types.</p> <p>It will actually accept the <code>str</code> with value <code>'23'</code> and will convert it to an <code>int</code> with value <code>23</code>.</p> <p>These strict error checks are very useful most of the time and can help you detect many bugs early. But there are cases, like with <code>age='23'</code>, where they could be inconvenient by reporting a \"false positive\" error.</p> <p>This example above with <code>age='23'</code> is intentionally simple, to show the error and the differences in types.</p> <p>But more common cases where these strict errors would be inconvenient would be when using more sophisticated data types, like <code>int</code> values for <code>datetime</code> fields, or <code>dict</code> values for pydantic sub-models.</p> <p>For example, this is valid for pydantic:</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nclass Quest(BaseModel):\n    title: str\nknight: Knight\nquest = Quest(\n    title='To seek the Holy Grail',\nknight={'title': 'Sir Lancelot', 'age': 23}\n)\n</code></pre> <p>The type of the field <code>knight</code> is declared with the class <code>Knight</code> (a pydantic model) and the code is passing a literal <code>dict</code> instead. This is still valid for pydantic, and the <code>dict</code> would be automatically converted to a <code>Knight</code> instance.</p> <p>Nevertheless, it would be detected as a type error:</p> <p></p> <p>In those cases, there are several ways to disable or ignore strict errors in very specific places, while still preserving them in the rest of the code.</p> <p>Below are several techniques to achieve it.</p>"},{"location":"visual_studio_code/#disable-type-checks-in-a-line","title":"Disable type checks in a line","text":"<p>You can disable the errors for a specific line using a comment of:</p> <pre><code># type: ignore\n</code></pre> <p>or (to be specific to pylance/pyright):</p> <pre><code># pyright: ignore\n</code></pre> <p>(pyright is the language server used by Pylance.).</p> <p>coming back to the example with <code>age='23'</code>, it would be:</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age='23')  # pyright: ignore\n</code></pre> <p>that way Pylance and mypy will ignore errors in that line.</p> <p>Pros: it's a simple change in that line to remove errors there.</p> <p>Cons: any other error in that line will also be omitted, including type checks, misspelled arguments, required arguments not provided, etc.</p>"},{"location":"visual_studio_code/#override-the-type-of-a-variable","title":"Override the type of a variable","text":"<p>You can also create a variable with the value you want to use and declare it's type explicitly with <code>Any</code>.</p> <pre><code>from typing import Any\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nage_str: Any = '23'\nlancelot = Knight(title='Sir Lancelot', age=age_str)\n</code></pre> <p>that way Pylance and mypy will interpret the variable <code>age_str</code> as if they didn't know its type, instead of knowing it has a type of <code>str</code> when an <code>int</code> was expected (and then showing the corresponding error).</p> <p>Pros: errors will be ignored only for a specific value, and you will still see any additional errors for the other arguments.</p> <p>Cons: it requires importing <code>Any</code> and a new variable in a new line for each argument that needs ignoring errors.</p>"},{"location":"visual_studio_code/#override-the-type-of-a-value-with-cast","title":"Override the type of a value with <code>cast</code>","text":"<p>The same idea from the previous example can be put on the same line with the help of <code>cast()</code>.</p> <p>This way, the type declaration of the value is overriden inline, without requiring another variable.</p> <pre><code>from typing import Any, cast\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age=cast(Any, '23'))\n</code></pre> <p><code>cast(Any, '23')</code> doesn't affect the value, it's still just <code>'23'</code>, but now Pylance and mypy will assume it is of type <code>Any</code>, which means, they will act as if they didn't know the type of the value.</p> <p>So, this is the equivalent of the previous example, without the additional variable.</p> <p>Pros: errors will be ignored only for a specific value, and you will still see any additional errors for the other arguments. There's no need for additional variables.</p> <p>Cons: it requires importing <code>Any</code> and <code>cast</code>, and if you are not used to using <code>cast()</code>, it could seem strange at first.</p>"},{"location":"visual_studio_code/#config-in-class-arguments","title":"Config in class arguments","text":"<p>pydantic has a rich set of Model Configurations available.</p> <p>These configurations can be set in an internal <code>class Config</code> on each model:</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\nclass Config:\nfrozen = True\n</code></pre> <p>or passed as keyword arguments when defining the model class:</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel, frozen=True):\ntitle: str\n    age: int\n    color: str = 'blue'\n</code></pre> <p>The specific configuration <code>frozen</code> (in beta) has a special meaning.</p> <p>It prevents other code from changing a model instance once it's created, keeping it \"frozen\".</p> <p>When using the second version to declare <code>frozen=True</code> (with keyword arguments in the class definition),  Pylance can use it to help you check in your code and detect errors when something is trying to set values  in a model that is \"frozen\".</p> <p></p>"},{"location":"visual_studio_code/#basesettings-and-ignoring-pylancepyright-errors","title":"BaseSettings and ignoring Pylance/pyright errors","text":"<p>Pylance/pyright does not work well with <code>BaseSettings</code> - fields in settings classes can be  configured via environment variables and therefore \"required\" fields do not have to be explicitly set when initialising a settings instance. However, pyright considers these fields as \"required\" and will therefore show an error when they're not set.</p> <p>See #3753 for an explanation of the reasons behind this, and why we can't avoid the problem.</p> <p>There are two potential workarounds:</p> <ul> <li>use an ignore comment (<code># pyright: ignore</code>) when initialising <code>settings</code></li> <li>or, use <code>settings.parse_obj({})</code> to avoid the warning</li> </ul>"},{"location":"visual_studio_code/#adding-a-default-with-field","title":"Adding a default with <code>Field</code>","text":"<p>Pylance/pyright requires <code>default</code> to be a keyword argument to <code>Field</code> in order to infer that the field is optional.</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Knight(BaseModel):\n    title: str = Field(default='Sir Lancelot')  # this is okay\n    age: int = Field(23)  # this works fine at runtime but will case an error for pyright\n\nlance = Knight()  # error: Argument missing for parameter \"age\" \n</code></pre> <p>Like the issue with <code>BaseSettings</code>, this is a limitation of dataclass transforms and cannot be fixed in pydantic.</p>"},{"location":"visual_studio_code/#technical-details","title":"Technical Details","text":"<p>Warning</p> <p>As a pydantic user, you don't need the details below. Feel free to skip the rest of this section.</p> <p>These details are only useful for other library authors, etc.</p> <p>This additional editor support works by implementing the proposed draft standard for Dataclass Transform.</p> <p>The proposed draft standard is written by Eric Traut, from the Microsoft team, the same author of the open source package Pyright (used by Pylance to provide Python support in VS Code).</p> <p>The intention of the standard is to provide a way for libraries like pydantic and others to tell editors and tools that they (the editors) should treat these libraries (e.g. pydantic) as if they were <code>dataclasses</code>, providing autocompletion, type checks, etc.</p> <p>The draft standard also includes an Alternate Form for early adopters, like pydantic, to add support for it right away, even before the new draft standard is finished and approved.</p> <p>This new draft standard, with the Alternate Form, is already supported by Pyright, so it can be used via Pylance in VS Code.</p> <p>As it is being proposed as an official standard for Python, other editors can also easily add support for it.</p> <p>And authors of other libraries similar to pydantic can also easily adopt the standard right away (using the \"Alternate Form\") and get the benefits of these additional editor features.</p>"},{"location":"blog/pydantic-v2/","title":"Pydantic V2 Plan","text":"<p>Samuel Colvin \u2022\u00a0    \u2022\u00a0    \u2022\u00a0    Jul 10, 2022 \u2022\u00a0    25 min read</p> <p>Updated late 10 Jul 2022, see pydantic#4226.</p> <p>Update 30 Dec 2022: The new release deadline for Pydantic V2 is the end of Q1 2023,  see pydantic#4887 for more details, futher updates will be posted on that issue.</p> <p>I've spoken to quite a few people about pydantic V2, and mention it in passing even more.</p> <p>I owe people a proper explanation of the plan for V2:</p> <ul> <li>What we will add</li> <li>What we will remove</li> <li>What we will change</li> <li>How I'm intending to go about completing it and getting it released</li> <li>Some idea of timeframe </li> </ul> <p>Here goes...</p> <p>Enormous thanks to Eric Jolibois, Laurence Watson,  Sebasti\u00e1n Ram\u00edrez, Adrian Garcia Badaracco,  Tom Hamilton Stubber, Zac Hatfield-Dodds,  Tom &amp; Hasan Ramezani for reviewing this blog post, putting up with (and correcting) my horrible typos and making great suggestions that have made this post and Pydantic V2 materially better.</p>"},{"location":"blog/pydantic-v2/#plan-timeframe","title":"Plan &amp; Timeframe","text":"<p>I'm currently taking a kind of sabbatical after leaving my last job to get pydantic V2 released. Why? I ask myself that question quite often. I'm very proud of how much pydantic is used, but I'm less proud of its internals. Since it's something people seem to care about and use quite a lot (26m downloads a month, used by 72k public repos, 10k stars). I want it to be as good as possible.</p> <p>While I'm on the subject of why, how and my odd sabbatical: if you work for a large company who use pydantic a lot, you might encourage the company to sponsor me a meaningful amount, like Salesforce did (if your organisation is not open to donations, I can also offer consulting services). This is not charity, recruitment or marketing - the argument should be about how much the company will save if pydantic is 10x faster, more stable and more powerful - it would be worth paying me 10% of that to make it happen.</p> <p>Before pydantic V2 can be released, we need to release pydantic V1.10 - there are lots of changes in the main branch of pydantic contributed by the community, it's only fair to provide a release including those changes, many of them will remain unchanged for V2, the rest will act as a requirement to make sure pydantic V2 includes the capabilities they implemented.</p> <p>The basic road map for me is as follows:</p> <ol> <li>Implement a few more features in pydantic-core, and release a first version, see below</li> <li>Work on getting pydantic V1.10 out - basically merge all open PRs that are finished</li> <li>Release pydantic V1.10</li> <li>Delete all stale PRs which didn't make it into V1.10, apologise profusely to their authors who put their valuable    time into pydantic only to have their PRs closed     (and explain when and how they can rebase and recreate the PR)</li> <li>Rename <code>master</code> to <code>main</code>, seems like a good time to do this</li> <li>Change the main branch of pydantic to target V2</li> <li>Start tearing pydantic code apart and see how many existing tests can be made to pass</li> <li>Rinse, repeat</li> <li>Release pydantic V2 </li> </ol> <p>Plan is to have all this done by the end of October, definitely by the end of the year.</p>"},{"location":"blog/pydantic-v2/#breaking-changes-compatibility","title":"Breaking Changes &amp; Compatibility","text":"<p>While we'll do our best to avoid breaking changes, some things will break.</p> <p>As per the greatest pun in modern TV history.</p> <p>You can't make a Tomelette without breaking some Greggs.</p> <p>Where possible, if breaking changes are unavoidable, we'll try to provide warnings or errors to make sure those changes are obvious to developers.</p>"},{"location":"blog/pydantic-v2/#motivation-pydantic-core","title":"Motivation &amp; <code>pydantic-core</code>","text":"<p>Since pydantic's initial release, with the help of wonderful contributors Eric Jolibois, Sebasti\u00e1n Ram\u00edrez, David Montague and many others, the package and its usage have grown enormously. The core logic however has remained mostly unchanged since the initial experiment. It's old, it smells, it needs to be rebuilt.</p> <p>The release of version 2 is an opportunity to rebuild pydantic and correct many things that don't make sense - to make pydantic amazing .</p> <p>The core validation logic of pydantic V2 will be performed by a separate package pydantic-core which I've been building over the last few months. pydantic-core is written in Rust using the excellent pyo3 library which provides rust bindings for python.</p> <p>The motivation for building pydantic-core in Rust is as follows:</p> <ol> <li>Performance, see below</li> <li>Recursion and code separation - with no stack and little-to-no overhead for extra function calls,    Rust allows pydantic-core to be implemented as a tree of small validators which call each other,    making code easier to understand and extend without harming performance</li> <li>Safety and complexity - pydantic-core is a fairly complex piece of code which has to draw distinctions    between many different errors, Rust is great in situations like this,    it should minimise bugs () and allow the codebase to be extended for a long time to come</li> </ol> <p>Note</p> <p>The python interface to pydantic shouldn't change as a result of using pydantic-core, instead pydantic will use type annotations to build a schema for pydantic-core to use.</p> <p>pydantic-core is usable now, albeit with an unintuitive API, if you're interested, please give it a try.</p> <p>pydantic-core provides validators for common data types, see a list here. Other, less commonly used data types will be supported via validator functions implemented in pydantic, in Python.</p> <p>See pydantic-core#153 for a summary of what needs to be completed before its first release.</p>"},{"location":"blog/pydantic-v2/#headlines","title":"Headlines","text":"<p>Here are some of the biggest changes expected in V2.</p>"},{"location":"blog/pydantic-v2/#performance","title":"Performance","text":"<p>As a result of the move to Rust for the validation logic (and significant improvements in how validation objects are structured) pydantic V2 will be significantly faster than pydantic V1.</p> <p>Looking at the pydantic-core benchmarks today, pydantic V2 is between 4x and 50x faster than pydantic V1.9.1.</p> <p>In general, pydantic V2 is about 17x faster than V1 when validating a model containing a range of common fields.</p>"},{"location":"blog/pydantic-v2/#strict-mode","title":"Strict Mode","text":"<p>People have long complained about pydantic for coercing data instead of throwing an error. E.g. input to an <code>int</code> field could be <code>123</code> or the string <code>\"123\"</code> which would be converted to <code>123</code> While this is very useful in many scenarios (think: URL parameters, environment variables, user input), there are some situations where it's not desirable.</p> <p>pydantic-core comes with \"strict mode\" built in. With this, only the exact data type is allowed, e.g. passing <code>\"123\"</code> to an <code>int</code> field would result in a validation error.</p> <p>This will allow pydantic V2 to offer a <code>strict</code> switch which can be set on either a model or a field.</p>"},{"location":"blog/pydantic-v2/#formalised-conversion-table","title":"Formalised Conversion Table","text":"<p>As well as complaints about coercion, another legitimate complaint was inconsistency around data conversion.</p> <p>In pydantic V2, the following principle will govern when data should be converted in \"lax mode\" (<code>strict=False</code>):</p> <p>If the input data has a SINGLE and INTUITIVE representation, in the field's type, AND no data is lost during the conversion, then the data will be converted; otherwise a validation error is raised. There is one exception to this rule: string fields - virtually all data has an intuitive representation as a string (e.g. <code>repr()</code> and <code>str()</code>), therefore a custom rule is required: only <code>str</code>, <code>bytes</code> and <code>bytearray</code> are valid as inputs to string fields.</p> <p>Some examples of what that means in practice:</p> Field Type Input Single &amp; Intuitive R. All Data Preserved Result <code>int</code> <code>\"123\"</code> Convert <code>int</code> <code>123.0</code> Convert <code>int</code> <code>123.1</code> Error <code>date</code> <code>\"2020-01-01\"</code> Convert <code>date</code> <code>\"2020-01-01T00:00:00\"</code> Convert <code>date</code> <code>\"2020-01-01T12:00:00\"</code> Error <code>int</code> <code>b\"1\"</code> Error <p>(For the last case converting <code>bytes</code> to an <code>int</code> could reasonably mean <code>int(bytes_data.decode())</code> or <code>int.from_bytes(b'1', 'big/little')</code>, hence an error)</p> <p>In addition to the general rule, we'll provide a conversion table which defines exactly what data will be allowed to which field types. See the table below for a start on this.</p>"},{"location":"blog/pydantic-v2/#built-in-json-support","title":"Built in JSON support","text":"<p>pydantic-core can parse JSON directly into a model or output type, this both improves performance and avoids issue with strictness - e.g. if you have a strict model with a <code>datetime</code> field, the input must be a <code>datetime</code> object, but clearly that makes no sense when parsing JSON which has no <code>datatime</code> type. Same with <code>bytes</code> and many other types.</p> <p>Pydantic V2 will therefore allow some conversion when validating JSON directly, even in strict mode (e.g. <code>ISO8601 string -&gt; datetime</code>, <code>str -&gt; bytes</code>) even though this would not be allowed when validating a python object.</p> <p>In future direct validation of JSON will also allow:</p> <ul> <li>parsing in a separate thread while starting validation in the main thread</li> <li>line numbers from JSON to be included in the validation errors</li> </ul> <p>(These features will not be included in V2, but instead will hopefully be added later.)</p> <p>Note</p> <p>Pydantic has always had special support for JSON, that is not going to change.</p> <p>While in theory other formats could be specifically supported, the overheads and development time are  significant and I don't think there's another format that's used widely enough to be worth specific logic. Other formats can be parsed to python then validated, similarly when serialising, data can be exported to a python object, then serialised, see below.</p>"},{"location":"blog/pydantic-v2/#validation-without-a-model","title":"Validation without a Model","text":"<p>In pydantic V1 the core of all validation was a pydantic model, this led to a significant performance penalty  and extra complexity when the output data type was not a model.</p> <p>pydantic-core operates on a tree of validators with no \"model\" type required at the base of that tree. It can therefore validate a single <code>string</code> or <code>datetime</code> value, a <code>TypedDict</code> or a <code>Model</code> equally easily.</p> <p>This feature will provide significant addition performance improvements in scenarios like:</p> <ul> <li>Adding validation to <code>dataclasses</code></li> <li>Validating URL arguments, query strings, headers, etc. in FastAPI</li> <li>Adding validation to <code>TypedDict</code></li> <li>Function argument validation</li> <li>Adding validation to your custom classes, decorators...</li> </ul> <p>In effect - anywhere where you don't care about a traditional model class instance.</p> <p>We'll need to add standalone methods for generating JSON Schema and dumping these objects to JSON, etc.</p>"},{"location":"blog/pydantic-v2/#required-vs-nullable-cleanup","title":"Required vs. Nullable Cleanup","text":"<p>Pydantic previously had a somewhat confused idea about \"required\" vs. \"nullable\". This mostly resulted from my misgivings about marking a field as <code>Optional[int]</code> but requiring a value to be provided but allowing it to be <code>None</code> - I didn't like using the word \"optional\" in relation to a field which was not optional.</p> <p>In pydantic V2, pydantic will move to match dataclasses, thus:</p> Required vs. Nullable<pre><code>from pydantic import BaseModel\n\nclass Foo(BaseModel):\n    f1: str  # required, cannot be None\n    f2: str | None  # required, can be None - same as Optional[str] / Union[str, None]\n    f3: str | None = None  # not required, can be None\n    f4: str = 'Foobar'  # not required, but cannot be None\n</code></pre>"},{"location":"blog/pydantic-v2/#validator-function-improvements","title":"Validator Function Improvements","text":"<p>This is one of the changes in pydantic V2 that I'm most excited about, I've been talking about something like this for a long time, see pydantic#1984, but couldn't find a way to do this until now.</p> <p>Fields which use a function for validation can be any of the following types:</p> <ul> <li>function before mode - where the function is called before the inner validator is called</li> <li>function after mode - where the function is called after the inner validator is called</li> <li>plain mode - where there's no inner validator</li> <li>wrap mode - where the function takes a reference to a function which calls the inner validator,   and can therefore modify the input before inner validation, modify the output after inner validation, conditionally   not call the inner validator or catch errors from the inner validator and return a default value, or change the error</li> </ul> <p>An example how a wrap validator might look:</p> Wrap mode validator function<pre><code>from datetime import datetime\nfrom pydantic import BaseModel, ValidationError, validator\n\nclass MyModel(BaseModel):\n    timestamp: datetime\n\n    @validator('timestamp', mode='wrap')\n    def validate_timestamp(cls, v, handler):\n        if v == 'now':\n            # we don't want to bother with further validation, \n            # just return the new value\n            return datetime.now()\n        try:\n            return handler(v)\n        except ValidationError:\n            # validation failed, in this case we want to \n            # return a default value\n            return datetime(2000, 1, 1)\n</code></pre> <p>As well as being powerful, this provides a great \"escape hatch\" when pydantic validation doesn't do what you need.</p>"},{"location":"blog/pydantic-v2/#more-powerful-aliases","title":"More powerful alias(es)","text":"<p>pydantic-core can support alias \"paths\" as well as simple string aliases to flatten data as it's validated.</p> <p>Best demonstrated with an example:</p> Alias paths<pre><code>from pydantic import BaseModel, Field\n\n\nclass Foo(BaseModel):\n    bar: str = Field(aliases=[['baz', 2, 'qux']])\n\n\ndata = {\n    'baz': [\n        {'qux': 'a'},\n        {'qux': 'b'},\n        {'qux': 'c'},\n        {'qux': 'd'},\n    ]\n}\n\nfoo = Foo(**data)\nassert foo.bar == 'c'\n</code></pre> <p><code>aliases</code> is a list of lists because multiple paths can be provided, if so they're tried in turn until a value is found.</p> <p>Tagged unions will use the same logic as <code>aliases</code> meaning nested attributes can be used to select a schema to validate against.</p>"},{"location":"blog/pydantic-v2/#improvements-to-dumpingserializationexport","title":"Improvements to Dumping/Serialization/Export","text":"<p>(I haven't worked on this yet, so these ideas are only provisional)</p> <p>There has long been a debate about how to handle converting data when extracting it from a model. One of the features people have long requested is the ability to convert data to JSON compliant types while converting a model to a dict.</p> <p>My plan is to move data export into pydantic-core, with that, one implementation can support all export modes without compromising (and hopefully significantly improving) performance.</p> <p>I see four different export/serialisation scenarios:</p> <ol> <li>Extracting the field values of a model with no conversion, effectively <code>model.__dict__</code> but with the current filtering    logic provided by <code>.dict()</code></li> <li>Extracting the field values of a model recursively (effectively what <code>.dict()</code> does now) - sub-models are converted to    dicts, but other fields remain unchanged.</li> <li>Extracting data and converting at the same time (e.g. to JSON compliant types)</li> <li>Serialising data straight to JSON</li> </ol> <p>I think all 4 modes can be supported in a single implementation, with a kind of \"3.5\" mode where a python function is used to convert the data as the user wishes.</p> <p>The current <code>include</code> and <code>exclude</code> logic is extremely complicated, but hopefully it won't be too hard to translate it to Rust.</p> <p>We should also add support for <code>validate_alias</code> and <code>dump_alias</code> as well as the standard <code>alias</code> to allow for customising field keys.</p>"},{"location":"blog/pydantic-v2/#validation-context","title":"Validation Context","text":"<p>Pydantic V2 will add a new optional <code>context</code> argument to <code>model_validate</code> and <code>model_validate_json</code> which will allow you to pass information not available when creating a model to validators. See pydantic#1549 for motivation.</p> <p>Here's an example of <code>context</code> might be used:</p> Context during Validation<pre><code>from pydantic import BaseModel, EmailStr, validator\n\nclass User(BaseModel):\n    email: EmailStr\n    home_country: str\n\n    @validator('home_country')\n    def check_home_country(cls, v, context):\n        if v not in context['countries']:\n            raise ValueError('invalid country choice')\n        return v\n\nasync def add_user(post_data: bytes):\n    countries = set(await db_connection.fetch_all('select code from country'))\n    user = User.model_validate_json(post_data, context={'countries': countries})\n    ...\n</code></pre> <p>Note</p> <p>We (actually mostly Sebasti\u00e1n ) will have to make some changes to FastAPI to fully leverage <code>context</code> as we'd need some kind of dependency injection to build context before validation so models can still be passed as arguments to views. I'm sure he'll be game.</p> <p>Warning</p> <p>Although this will make it slightly easier to run synchronous IO (HTTP requests, DB. queries, etc.) from within validators, I strongly advise you keep IO separate from validation - do it before and use context, do it afterwards, avoid where possible making queries inside validation.</p>"},{"location":"blog/pydantic-v2/#model-namespace-cleanup","title":"Model Namespace Cleanup","text":"<p>For years I've wanted to clean up the model namespace, see pydantic#1001. This would avoid confusing gotchas when field names clash with methods on a model, it would also make it safer to add more methods to a model without risking new clashes.</p> <p>After much deliberation (and even giving a lightning talk at the python language submit about alternatives, see this discussion). I've decided to go with the simplest and clearest approach, at the expense of a bit more typing:</p> <p>All methods on models will start with <code>model_</code>, fields' names will not be allowed to start with <code>\"model\"</code> (aliases can be used if required).</p> <p>This will mean <code>BaseModel</code> will have roughly the following signature.</p> New BaseModel methods<pre><code>class BaseModel:\n    model_fields: List[FieldInfo]\n\"\"\"previously `__fields__`, although the format will change a lot\"\"\"\n    @classmethod\n    def model_validate(cls, data: Any, *, context=None) -&gt; Self:  # (1)\n\"\"\"\n        previously `parse_obj()`, validate data\n        \"\"\"\n    @classmethod\n    def model_validate_json(\n        cls,\n        data: str | bytes | bytearray,\n        *,\n        context=None\n    ) -&gt; Self:\n\"\"\"\n        previously `parse_raw(..., content_type='application/json')`\n        validate data from JSON\n        \"\"\"\n    @classmethod\n    def model_is_instance(cls, data: Any, *, context=None) -&gt; bool: # (2)\n\"\"\"\n        new, check if data is value for the model\n        \"\"\"\n    @classmethod\n    def model_is_instance_json(\n        cls,\n        data: str | bytes | bytearray,\n        *,\n        context=None\n    ) -&gt; bool:\n\"\"\"\n        Same as `model_is_instance`, but from JSON\n        \"\"\"\n    def model_dump(\n        self,\n        include: ... = None,\n        exclude: ... = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        mode: Literal['unchanged', 'dicts', 'json-compliant'] = 'unchanged',\n        converter: Callable[[Any], Any] | None = None\n    ) -&gt; Any:\n\"\"\"\n        previously `dict()`, as before\n        with new `mode` argument\n        \"\"\"\n    def model_dump_json(self, ...) -&gt; str:\n\"\"\"\n        previously `json()`, arguments as above\n        effectively equivalent to `json.dump(self.model_dump(..., mode='json'))`,\n        but more performant\n        \"\"\"\n    def model_json_schema(self, ...) -&gt; dict[str, Any]:\n\"\"\"\n        previously `schema()`, arguments roughly as before\n        JSON schema as a dict\n        \"\"\"\n    def model_update_forward_refs(self) -&gt; None:\n\"\"\"\n        previously `update_forward_refs()`, update forward references\n        \"\"\"\n    @classmethod\n    def model_construct(\n        self,\n        _fields_set: set[str] | None = None,\n        **values: Any\n    ) -&gt; Self:\n\"\"\"\n        previously `construct()`, arguments roughly as before\n        construct a model with no validation\n        \"\"\"\n    @classmethod\n    def model_customize_schema(cls, schema: dict[str, Any]) -&gt; dict[str, Any]:\n\"\"\"\n        new, way to customize validation,\n        e.g. if you wanted to alter how the model validates certain types,\n        or add validation for a specific type without custom types or\n        decorated validators\n        \"\"\"\n    class ModelConfig:\n\"\"\"\n        previously `Config`, configuration class for models\n        \"\"\"\n</code></pre> <ol> <li>see Validation Context for more information on <code>context</code></li> <li>see <code>is_instance</code> checks</li> </ol> <p>The following methods will be removed:</p> <ul> <li><code>.parse_file()</code> - was a mistake, should never have been in pydantic</li> <li><code>.parse_raw()</code> - partially replaced by <code>.model_validate_json()</code>, the other functionality was a mistake</li> <li><code>.from_orm()</code> - the functionality has been moved to config, see other improvements below</li> <li><code>.schema_json()</code> - mostly since it causes confusion between pydantic validation schema and JSON schema,   and can be replaced with just <code>json.dumps(m.model_json_schema())</code></li> <li><code>.copy()</code> instead we'll implement <code>__copy__</code> and let people use the <code>copy</code> module   (this removes some functionality) from <code>copy()</code> but there are bugs and ambiguities with the functionality anyway</li> </ul>"},{"location":"blog/pydantic-v2/#strict-api-api-documentation","title":"Strict API &amp; API documentation","text":"<p>When preparing for pydantic V2, we'll make a strict distinction between the public API and private functions &amp; classes. Private objects will be clearly identified as private via a <code>_internal</code> sub package to discourage use.</p> <p>The public API will have API documentation. I've recently been working with the wonderful mkdocstrings package for both dirty-equals and watchfiles documentation. I intend to use <code>mkdocstrings</code> to generate complete API documentation for V2.</p> <p>This wouldn't replace the current example-based somewhat informal documentation style but instead will augment it.</p>"},{"location":"blog/pydantic-v2/#error-descriptions","title":"Error descriptions","text":"<p>The way line errors (the individual errors within a <code>ValidationError</code>) are built has become much more sophisticated in pydantic-core.</p> <p>There's a well-defined set of error codes and messages.</p> <p>More will be added when other types are validated via pure python validators in pydantic.</p> <p>I would like to add a dedicated section to the documentation with extra information for each type of error.</p> <p>This would be another key in a line error: <code>documentation</code>, which would link to the appropriate section in the docs.</p> <p>Thus, errors might look like:</p> Line Errors Example<pre><code>[\n    {\n        'kind': 'greater_than_equal',\n        'loc': ['age'],\n        'message': 'Value must be greater than or equal to 18',\n        'input_value': 11,\n        'context': {'ge': 18},\n        'documentation': 'https://pydantic.dev/errors/#greater_than_equal',\n    },\n    {\n        'kind': 'bool_parsing',\n        'loc': ['is_developer'],\n        'message': 'Value must be a valid boolean, unable to interpret input',\n        'input_value': 'foobar',\n        'documentation': 'https://pydantic.dev/errors/#bool_parsing',\n    },\n]\n</code></pre> <p>I own the <code>pydantic.dev</code> domain and will use it for at least these errors so that even if the docs URL changes, the error will still link to the correct documentation. If developers don't want to show these errors to users, they can always process the errors list and filter out items from each error they don't need or want.</p>"},{"location":"blog/pydantic-v2/#no-pure-python-implementation","title":"No pure python implementation","text":"<p>Since pydantic-core is written in Rust, and I have absolutely no intention of rewriting it in python, pydantic V2 will only work where a binary package can be installed.</p> <p>pydantic-core will provide binaries in PyPI for (at least):</p> <ul> <li>Linux: <code>x86_64</code>, <code>aarch64</code>, <code>i686</code>, <code>armv7l</code>, <code>musl-x86_64</code> &amp; <code>musl-aarch64</code></li> <li>MacOS: <code>x86_64</code> &amp; <code>arm64</code> (except python 3.7)</li> <li>Windows: <code>amd64</code> &amp; <code>win32</code></li> <li>Web Assembly: <code>wasm32</code>   (pydantic-core is already   compiled for wasm32 using emscripten and unit tests pass, except where cpython itself has   problems)</li> </ul> <p>Binaries for pypy are a work in progress and will be added if possible, see pydantic-core#154.</p> <p>Other binaries can be added provided they can be (cross-)compiled on github actions. If no binary is available from PyPI, pydantic-core can be compiled from source if Rust stable is available.</p> <p>The only place where I know this will cause problems is Raspberry Pi, which is a mess when it comes to packages written in Rust for Python. Effectively, until that's fixed you'll likely have to install pydantic with <code>pip install -i https://pypi.org/simple/ pydantic</code>.</p>"},{"location":"blog/pydantic-v2/#pydantic-becomes-a-pure-python-package","title":"Pydantic becomes a pure python package","text":"<p>Pydantic V1.X is a pure python code base but is compiled with cython to provide some performance improvements. Since the \"hot\" code is moved to pydantic-core, pydantic itself can go back to being a pure python package.</p> <p>This should significantly reduce the size of the pydantic package and make unit tests of pydantic much faster. In addition:</p> <ul> <li>some constraints on pydantic code can be removed once it no-longer has to be compilable with cython</li> <li>debugging will be easier as you'll be able to drop straight into the pydantic codebase as you can with other,   pure python packages</li> </ul> <p>Some pieces of edge logic could get a little slower as they're no longer compiled.</p>"},{"location":"blog/pydantic-v2/#is_instance-like-checks","title":"<code>is_instance</code> like checks","text":"<p>Strict mode also means it makes sense to provide an <code>is_instance</code> method on models which effectively run validation then throws away the result while avoiding the (admittedly small) overhead of creating and raising an error or returning the validation result.</p> <p>To be clear, this isn't a real <code>isinstance</code> call, rather it is equivalent to</p> is_instance<pre><code>class BaseModel:\n    ...\n    @classmethod\n    def model_is_instance(cls, data: Any) -&gt; bool:\n        try:\n            cls(**data)\n        except ValidationError:\n            return False\n        else:\n            return True\n</code></pre>"},{"location":"blog/pydantic-v2/#im-dropping-the-word-parse-and-just-using-validate","title":"I'm dropping the word \"parse\" and just using \"validate\"","text":"<p>Partly due to the issues with the lack of strict mode, I've gone back and forth between using the terms \"parse\" and \"validate\" for what pydantic does.</p> <p>While pydantic is not simply a validation library (and I'm sure some would argue validation is not strictly what it does), most people use the word \"validation\".</p> <p>It's time to stop fighting that, and use consistent names.</p> <p>The word \"parse\" will no longer be used except when talking about JSON parsing, see model methods above.</p>"},{"location":"blog/pydantic-v2/#changes-to-custom-field-types","title":"Changes to custom field types","text":"<p>Since the core structure of validators has changed from \"a list of validators to call one after another\" to \"a tree of validators which call each other\", the <code>__get_validators__</code> way of defining custom field types no longer makes sense.</p> <p>Instead, we'll look for the attribute <code>__pydantic_validation_schema__</code> which must be a pydantic-core compliant schema for validating data to this field type (the <code>function</code> item can be a string, if so a function of that name will be taken from the class, see <code>'validate'</code> below).</p> <p>Here's an example of how a custom field type could be defined:</p> New custom field types<pre><code>from pydantic import ValidationSchema\n\nclass Foobar:\n    def __init__(self, value: str):\n        self.value = value\n\n    __pydantic_validation_schema__: ValidationSchema = {\n        'type': 'function',\n        'mode': 'after',\n        'function': 'validate',\n        'schema': {'type': 'str'}\n    }\n\n    @classmethod\n    def validate(cls, value):\n        if 'foobar' in value:\n            return Foobar(value)\n        else:\n            raise ValueError('expected foobar')\n</code></pre> <p>What's going on here: <code>__pydantic_validation_schema__</code> defines a schema which effectively says:</p> <p>Validate input data as a string, then call the <code>validate</code> function with that string, use the returned value as the final result of validation.</p> <p><code>ValidationSchema</code> is just an alias to <code>pydantic_core.Schema</code> which is a type defining the schema for validation schemas.</p> <p>Note</p> <p>pydantic-core schema has full type definitions although since the type is recursive, mypy can't provide static type analysis, pyright however can.</p> <p>We can probably provide one or more helper functions to make <code>__pydantic_validation_schema__</code> easier to generate.</p>"},{"location":"blog/pydantic-v2/#other-improvements","title":"Other Improvements","text":"<p>Some other things which will also change, IMHO for the better:</p> <ol> <li>Recursive models with cyclic references - although recursive models were supported by pydantic V1,    data with cyclic references caused recursion errors, in pydantic-core cyclic references are correctly detected    and a validation error is raised</li> <li>The reason I've been so keen to get pydantic-core to compile and run with wasm is that I want all examples    in the docs of pydantic V2 to be editable and runnable in the browser</li> <li>Full support for <code>TypedDict</code>, including <code>total=False</code> - e.g. omitted keys,    providing validation schema to a <code>TypedDict</code> field/item will use <code>Annotated</code>, e.g. <code>Annotated[str, Field(strict=True)]</code></li> <li><code>from_orm</code> has become <code>from_attributes</code> and is now defined at schema generation time    (either via model config or field config)</li> <li><code>input_value</code> has been added to each line error in a <code>ValidationError</code>, making errors easier to understand,    and more comprehensive details of errors to be provided to end users,    pydantic#784</li> <li><code>on_error</code> logic in a schema which allows either a default value to be used in the event of an error,    or that value to be omitted (in the case of a <code>total=False</code> <code>TypedDict</code>),    pydantic-core#151</li> <li><code>datetime</code>, <code>date</code>, <code>time</code> &amp; <code>timedelta</code> validation is improved, see the    speedate Rust library I built specifically for this purpose for more details</li> <li>Powerful \"priority\" system for optionally merging or overriding config in sub-models for nested schemas</li> <li>Pydantic will support annotated-types,    so you can do stuff like <code>Annotated[set[int], Len(0, 10)]</code> or <code>Name = Annotated[str, Len(1, 1024)]</code></li> <li>A single decorator for general usage - we should add a <code>validate</code> decorator which can be used:<ul> <li>on functions (replacing <code>validate_arguments</code>)</li> <li>on dataclasses, <code>pydantic.dataclasses.dataclass</code> will become an alias of this</li> <li>on <code>TypedDict</code>s</li> <li>On any supported type, e.g. <code>Union[...]</code>, <code>Dict[str, Thing]</code></li> <li>On Custom field types - e.g. anything with a <code>__pydantic_schema__</code> attribute</li> </ul> </li> <li>Easier validation error creation, I've often found myself wanting to raise <code>ValidationError</code>s outside     models, particularly in FastAPI     (here     is one method I've used), we should provide utilities to generate these errors</li> <li>Improve the performance of <code>__eq__</code> on models</li> <li>Computed fields, these having been an idea for a long time in pydantic - we should get them right</li> <li>Model validation that avoids instances of subclasses leaking data (particularly important for FastAPI),     see pydantic-core#155</li> <li>We'll now follow semvar properly and avoid breaking changes between minor versions,     as a result, major versions will become more common</li> <li>Improve generics to use <code>M(Basemodel, Generic[T])</code> instead of <code>M(GenericModel, Generic[T])</code> - e.g. <code>GenericModel</code>     can be removed; this results from no-longer needing to compile pydantic code with cython</li> </ol>"},{"location":"blog/pydantic-v2/#removed-features-limitations","title":"Removed Features &amp; Limitations","text":"<p>The emoji here is just for variation, I'm not frowning about any of this, these changes are either good IMHO (will make pydantic cleaner, easier to learn and easier to maintain) or irrelevant to 99.9+% of users.</p> <ol> <li><code>__root__</code> custom root models are no longer necessary since validation on any supported data type is allowed    without a model</li> <li><code>.parse_file()</code> and <code>.parse_raw()</code>, partially replaced with <code>.model_validate_json()</code>,     see model methods</li> <li><code>.schema_json()</code> &amp; <code>.copy()</code>, see model methods</li> <li><code>TypeError</code> are no longer considered as validation errors, but rather as internal errors, this is to better    catch errors in argument names in function validators.</li> <li>Subclasses of builtin types like <code>str</code>, <code>bytes</code> and <code>int</code> are coerced to their parent builtin type,    this is a limitation of how pydantic-core converts these types to Rust types during validation, if you have a    specific need to keep the type, you can use wrap validators or custom type validation as described above</li> <li>integers are represented in rust code as <code>i64</code>, meaning if you want to use ints where <code>abs(v) &gt; 2^63 \u2212 1</code>    (9,223,372,036,854,775,807), you'll need to use a wrap validator and your own logic</li> <li>Settings Management ??? - I definitely don't want to    remove the functionality, but it's something of a historical curiosity that it lives within pydantic,    perhaps it should move to a separate package, perhaps installable alongside pydantic with    <code>pip install pydantic[settings]</code>?</li> <li>The following <code>Config</code> properties will be removed:<ul> <li><code>fields</code> - it's very old (it pre-dates <code>Field</code>), can be removed</li> <li><code>allow_mutation</code> will be removed, instead <code>frozen</code> will be used</li> <li><code>error_msg_templates</code>, it's not properly documented anyway, error messages can be customized with external logic if required</li> <li><code>getter_dict</code> - pydantic-core has hardcoded <code>from_attributes</code> logic</li> <li><code>json_loads</code> - again this is hard coded in pydantic-core</li> <li><code>json_dumps</code> - possibly</li> <li><code>json_encoders</code> - see the export \"mode\" discussion above</li> <li><code>underscore_attrs_are_private</code> we should just choose a sensible default</li> <li><code>smart_union</code> - all unions are now \"smart\"</li> </ul> </li> <li><code>dict(model)</code> functionality should be removed, there's a much clearer distinction now that in 2017 when I     implemented this between a model and a dict</li> </ol>"},{"location":"blog/pydantic-v2/#features-remaining","title":"Features Remaining","text":"<p>The following features will remain (mostly) unchanged:</p> <ul> <li>JSONSchema, internally this will need to change a lot, but hopefully the external interface will remain unchanged</li> <li><code>dataclass</code> support, again internals might change, but not the external interface</li> <li><code>validate_arguments</code>, might be renamed, but otherwise remain</li> <li>hypothesis plugin, might be able to improve this as part of the general cleanup</li> </ul>"},{"location":"blog/pydantic-v2/#questions","title":"Questions","text":"<p>I hope the explanation above is useful. I'm sure people will have questions and feedback; I'm aware I've skipped over some features with limited detail (this post is already fairly long ).</p> <p>To allow feedback without being overwhelmed, I've created a \"Pydantic V2\" category for discussions on github - please feel free to create a discussion if you have any questions or suggestions. We will endeavour to read and respond to everyone.</p>"},{"location":"blog/pydantic-v2/#implementation-details","title":"Implementation Details","text":"<p>(This is yet to be built, so these are nascent ideas which might change)</p> <p>At the center of pydantic v2 will be a <code>PydanticValidator</code> class which looks roughly like this (note: this is just pseudo-code, it's not even valid python and is only supposed to be used to demonstrate the idea):</p> PydanticValidator<pre><code># type identifying data which has been validated,\n# as per pydantic-core, this can include \"fields_set\" data\nValidData = ...\n\n# any type we can perform validation for\nAnyOutputType = ...\n\nclass PydanticValidator:\n    def __init__(self, output_type: AnyOutputType, config: Config):\n        ...\n    def validate(self, input_data: Any) -&gt; ValidData:\n        ...\n    def validate_json(self, input_data: str | bytes | bytearray) -&gt; ValidData:\n        ...\n    def is_instance(self, input_data: Any) -&gt; bool:\n        ...\n    def is_instance_json(self, input_data: str | bytes | bytearray) -&gt; bool:\n        ...\n    def json_schema(self) -&gt; dict:\n        ...\n    def dump(\n        self,\n        data: ValidData,\n        include: ... = None,\n        exclude: ... = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        mode: Literal['unchanged', 'dicts', 'json-compliant'] = 'unchanged',\n        converter: Callable[[Any], Any] | None = None\n    ) -&gt; Any:\n        ...\n    def dump_json(self, ...) -&gt; str:\n        ...\n</code></pre> <p>This could be used directly, but more commonly will be used by the following:</p> <ul> <li><code>BaseModel</code></li> <li>the <code>validate</code> decorator described above</li> <li><code>pydantic.dataclasses.dataclass</code> (which might be an alias of <code>validate</code>)</li> <li>generics</li> </ul> <p>The aim will be to get pydantic V2 to a place were the vast majority of tests continue to pass unchanged.</p> <p>Thereby guaranteeing (as much as possible) that the external interface to pydantic and its behaviour are unchanged.</p>"},{"location":"blog/pydantic-v2/#conversion-table","title":"Conversion Table","text":"<p>The table below provisionally defines what input value types are allowed to which field types.</p> <p>An updated and complete version of this table will be included in the docs for V2.</p> <p>Note</p> <p>Some type conversion shown here is a significant departure from existing behavior, we may have to provide a config flag for backwards compatibility for a few of them, however pydantic V2 cannot be entirely backward compatible, see pydantic-core#152.</p> Field Type Input Mode Input Source Conditions <code>str</code> <code>str</code> both python, JSON - <code>str</code> <code>bytes</code> lax python assumes UTF-8, error on unicode decoding error <code>str</code> <code>bytearray</code> lax python assumes UTF-8, error on unicode decoding error <code>bytes</code> <code>bytes</code> both python - <code>bytes</code> <code>str</code> both JSON - <code>bytes</code> <code>str</code> lax python - <code>bytes</code> <code>bytearray</code> lax python - <code>int</code> <code>int</code> strict python, JSON max abs value 2^64 - <code>i64</code> is used internally, <code>bool</code> explicitly forbidden <code>int</code> <code>int</code> lax python, JSON <code>i64</code> <code>int</code> <code>float</code> lax python, JSON <code>i64</code>, must be exact int, e.g. <code>f % 1 == 0</code>, <code>nan</code>, <code>inf</code> raise errors <code>int</code> <code>Decimal</code> lax python, JSON <code>i64</code>, must be exact int, e.g. <code>f % 1 == 0</code> <code>int</code> <code>bool</code> lax python, JSON - <code>int</code> <code>str</code> lax python, JSON <code>i64</code>, must be numeric only, e.g. <code>[0-9]+</code> <code>float</code> <code>float</code> strict python, JSON <code>bool</code> explicitly forbidden <code>float</code> <code>float</code> lax python, JSON - <code>float</code> <code>int</code> lax python, JSON - <code>float</code> <code>str</code> lax python, JSON must match <code>[0-9]+(\\.[0-9]+)?</code> <code>float</code> <code>Decimal</code> lax python - <code>float</code> <code>bool</code> lax python, JSON - <code>bool</code> <code>bool</code> both python, JSON - <code>bool</code> <code>int</code> lax python, JSON allowed: <code>0, 1</code> <code>bool</code> <code>float</code> lax python, JSON allowed: <code>0, 1</code> <code>bool</code> <code>Decimal</code> lax python, JSON allowed: <code>0, 1</code> <code>bool</code> <code>str</code> lax python, JSON allowed: <code>'f', 'n', 'no', 'off', 'false', 't', 'y', 'on', 'yes', 'true'</code> <code>None</code> <code>None</code> both python, JSON - <code>date</code> <code>date</code> both python - <code>date</code> <code>datetime</code> lax python must be exact date, eg. no H, M, S, f <code>date</code> <code>str</code> both JSON format <code>YYYY-MM-DD</code> <code>date</code> <code>str</code> lax python format <code>YYYY-MM-DD</code> <code>date</code> <code>bytes</code> lax python format <code>YYYY-MM-DD</code> (UTF-8) <code>date</code> <code>int</code> lax python, JSON interpreted as seconds or ms from epoch, see speedate, must be exact date <code>date</code> <code>float</code> lax python, JSON interpreted as seconds or ms from epoch, see speedate, must be exact date <code>datetime</code> <code>datetime</code> both python - <code>datetime</code> <code>date</code> lax python - <code>datetime</code> <code>str</code> both JSON format <code>YYYY-MM-DDTHH:MM:SS.f</code> etc. see speedate <code>datetime</code> <code>str</code> lax python format <code>YYYY-MM-DDTHH:MM:SS.f</code> etc. see speedate <code>datetime</code> <code>bytes</code> lax python format <code>YYYY-MM-DDTHH:MM:SS.f</code> etc. see speedate, (UTF-8) <code>datetime</code> <code>int</code> lax python, JSON interpreted as seconds or ms from epoch, see speedate <code>datetime</code> <code>float</code> lax python, JSON interpreted as seconds or ms from epoch, see speedate <code>time</code> <code>time</code> both python - <code>time</code> <code>str</code> both JSON format <code>HH:MM:SS.FFFFFF</code> etc. see speedate <code>time</code> <code>str</code> lax python format <code>HH:MM:SS.FFFFFF</code> etc. see speedate <code>time</code> <code>bytes</code> lax python format <code>HH:MM:SS.FFFFFF</code> etc. see speedate, (UTF-8) <code>time</code> <code>int</code> lax python, JSON interpreted as seconds, range 0 - 86399 <code>time</code> <code>float</code> lax python, JSON interpreted as seconds, range 0 - 86399.9* <code>time</code> <code>Decimal</code> lax python, JSON interpreted as seconds, range 0 - 86399.9* <code>timedelta</code> <code>timedelta</code> both python - <code>timedelta</code> <code>str</code> both JSON format ISO8601 etc. see speedate <code>timedelta</code> <code>str</code> lax python format ISO8601 etc. see speedate <code>timedelta</code> <code>bytes</code> lax python format ISO8601 etc. see speedate, (UTF-8) <code>timedelta</code> <code>int</code> lax python, JSON interpreted as seconds <code>timedelta</code> <code>float</code> lax python, JSON interpreted as seconds <code>timedelta</code> <code>Decimal</code> lax python, JSON interpreted as seconds <code>dict</code> <code>dict</code> both python - <code>dict</code> <code>Object</code> both JSON - <code>dict</code> <code>mapping</code> lax python must implement the mapping interface and have an <code>items()</code> method <code>TypedDict</code> <code>dict</code> both python - <code>TypedDict</code> <code>Object</code> both JSON - <code>TypedDict</code> <code>Any</code> both python builtins not allowed, uses <code>getattr</code>, requires <code>from_attributes=True</code> <code>TypedDict</code> <code>mapping</code> lax python must implement the mapping interface and have an <code>items()</code> method <code>list</code> <code>list</code> both python - <code>list</code> <code>Array</code> both JSON - <code>list</code> <code>tuple</code> lax python - <code>list</code> <code>set</code> lax python - <code>list</code> <code>frozenset</code> lax python - <code>list</code> <code>dict_keys</code> lax python - <code>tuple</code> <code>tuple</code> both python - <code>tuple</code> <code>Array</code> both JSON - <code>tuple</code> <code>list</code> lax python - <code>tuple</code> <code>set</code> lax python - <code>tuple</code> <code>frozenset</code> lax python - <code>tuple</code> <code>dict_keys</code> lax python - <code>set</code> <code>set</code> both python - <code>set</code> <code>Array</code> both JSON - <code>set</code> <code>list</code> lax python - <code>set</code> <code>tuple</code> lax python - <code>set</code> <code>frozenset</code> lax python - <code>set</code> <code>dict_keys</code> lax python - <code>frozenset</code> <code>frozenset</code> both python - <code>frozenset</code> <code>Array</code> both JSON - <code>frozenset</code> <code>list</code> lax python - <code>frozenset</code> <code>tuple</code> lax python - <code>frozenset</code> <code>set</code> lax python - <code>frozenset</code> <code>dict_keys</code> lax python - <code>is_instance</code> <code>Any</code> both python <code>isinstance()</code> check returns <code>True</code> <code>is_instance</code> - both JSON never valid <code>callable</code> <code>Any</code> both python <code>callable()</code> check returns <code>True</code> <code>callable</code> - both JSON never valid <p>The <code>ModelClass</code> validator (use to create instances of a class) uses the <code>TypedDict</code> validator, then creates an instance with <code>__dict__</code> and <code>__fields_set__</code> set, so same rules apply as <code>TypedDict</code>.</p>"},{"location":"usage/dataclasses/","title":"\u6570\u636e\u7c7b","text":"<p>If you don't want to use pydantic's <code>BaseModel</code> you can instead get the same data validation on standard dataclasses (introduced in Python 3.7).</p> <pre><code>from datetime import datetime\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime = None\n\n\nuser = User(id='42', signup_ts='2032-06-21T12:00')\nprint(user)\n</code></pre> <p>Note</p> <p>Keep in mind that <code>pydantic.dataclasses.dataclass</code> is a drop-in replacement for <code>dataclasses.dataclass</code> with validation, not a replacement for <code>pydantic.BaseModel</code> (with a small difference in how initialization hooks work). There are cases where subclassing <code>pydantic.BaseModel</code> is the better choice.</p> <p>For more information and discussion see pydantic/pydantic#710.</p> <p>You can use all the standard pydantic field types, and the resulting dataclass will be identical to the one created by the standard library <code>dataclass</code> decorator.</p> <p>The underlying model and its schema can be accessed through <code>__pydantic_model__</code>. Also, fields that require a <code>default_factory</code> can be specified by either a <code>pydantic.Field</code> or a <code>dataclasses.field</code>.</p> <pre><code>import dataclasses\nfrom typing import List, Optional\n\nfrom pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: List[int] = dataclasses.field(default_factory=lambda: [0])\n    age: Optional[int] = dataclasses.field(\n        default=None,\n        metadata=dict(title='The age of the user', description='do not lie!')\n    )\n    height: Optional[int] = Field(None, title='The height in cm', ge=50, le=300)\n\n\nuser = User(id='42')\nprint(user.__pydantic_model__.schema())\n</code></pre> <p><code>pydantic.dataclasses.dataclass</code>'s arguments are the same as the standard decorator, except one extra keyword argument <code>config</code> which has the same meaning as Config.</p> <p>Warning</p> <p>After v1.2, The Mypy plugin must be installed to type check pydantic dataclasses.</p> <p>For more information about combining validators with dataclasses, see dataclass validators.</p>"},{"location":"usage/dataclasses/#dataclass-config","title":"Dataclass Config","text":"<p>If you want to modify the <code>Config</code> like you would with a <code>BaseModel</code>, you have three options:</p> <pre><code>from pydantic import ConfigDict\nfrom pydantic.dataclasses import dataclass\n\n\n# Option 1 - use directly a dict\n# Note: `mypy` will still raise typo error\n@dataclass(config=dict(validate_assignment=True))\nclass MyDataclass1:\n    a: int\n\n\n# Option 2 - use `ConfigDict`\n# (same as before at runtime since it's a `TypedDict` but with intellisense)\n@dataclass(config=ConfigDict(validate_assignment=True))\nclass MyDataclass2:\n    a: int\n\n\n# Option 3 - use a `Config` class like for a `BaseModel`\nclass Config:\n    validate_assignment = True\n\n\n@dataclass(config=Config)\nclass MyDataclass3:\n    a: int\n</code></pre> <p>Warning</p> <p>After v1.10, pydantic dataclasses support <code>Config.extra</code> but some default behaviour of stdlib dataclasses may prevail. For example, when <code>print</code>ing a pydantic dataclass with allowed extra fields, it will still use the <code>__str__</code> method of stdlib dataclass and show only the required fields. This may be improved further in the future.</p>"},{"location":"usage/dataclasses/#nested-dataclasses","title":"Nested dataclasses","text":"<p>Nested dataclasses are supported both in dataclasses and normal models.</p> <pre><code>from pydantic import AnyUrl\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass NavbarButton:\n    href: AnyUrl\n\n\n@dataclass\nclass Navbar:\n    button: NavbarButton\n\n\nnavbar = Navbar(button=('https://example.com',))\nprint(navbar)\n</code></pre> <p>Dataclasses attributes can be populated by tuples, dictionaries or instances of the dataclass itself.</p>"},{"location":"usage/dataclasses/#stdlib-dataclasses-and-pydantic-dataclasses","title":"Stdlib dataclasses and pydantic dataclasses","text":""},{"location":"usage/dataclasses/#convert-stdlib-dataclasses-into-pydantic-dataclasses","title":"Convert stdlib dataclasses into pydantic dataclasses","text":"<p>Stdlib dataclasses (nested or not) can be easily converted into pydantic dataclasses by just decorating them with <code>pydantic.dataclasses.dataclass</code>. Pydantic will enhance the given stdlib dataclass but won't alter the default behaviour (i.e. without validation). It will instead create a wrapper around it to trigger validation that will act like a plain proxy. The stdlib dataclass can still be accessed via the <code>__dataclass__</code> attribute (see example below).</p> <pre><code>import dataclasses\nfrom datetime import datetime\nfrom typing import Optional\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass Meta:\n    modified_date: Optional[datetime]\n    seen_count: int\n\n\n@dataclasses.dataclass\nclass File(Meta):\n    filename: str\n\n\n# `ValidatedFile` will be a proxy around `File`\nValidatedFile = pydantic.dataclasses.dataclass(File)\n\n# the original dataclass is the `__dataclass__` attribute\nassert ValidatedFile.__dataclass__ is File\n\n\nvalidated_file = ValidatedFile(\n    filename=b'thefilename',\n    modified_date='2020-01-01T00:00',\n    seen_count='7',\n)\nprint(validated_file)\n\ntry:\n    ValidatedFile(\n        filename=['not', 'a', 'string'],\n        modified_date=None,\n        seen_count=3,\n    )\nexcept pydantic.ValidationError as e:\n    print(e)\n\n# `File` is not altered and still does no validation by default\nprint(File(\n    filename=['not', 'a', 'string'],\n    modified_date=None,\n    seen_count=3,\n))\n</code></pre>"},{"location":"usage/dataclasses/#choose-when-to-trigger-validation","title":"Choose when to trigger validation","text":"<p>As soon as your stdlib dataclass has been decorated with pydantic dataclass decorator, magic methods have been added to validate input data. If you want, you can still keep using your dataclass and choose when to trigger it.</p> <pre><code>import dataclasses\n\nfrom pydantic import ValidationError\nfrom pydantic.dataclasses import dataclass as pydantic_dataclass, set_validation\n\n\n@dataclasses.dataclass\nclass User:\n    id: int\n    name: str\n\n\n# Enhance stdlib dataclass\npydantic_dataclass(User)\n\n\nuser1 = User(id='whatever', name='I want')\n\n# validate data of `user1`\ntry:\n    user1.__pydantic_validate_values__()\nexcept ValidationError as e:\n    print(e)\n\n# Enforce validation\ntry:\n    with set_validation(User, True):\n        User(id='whatever', name='I want')\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/dataclasses/#inherit-from-stdlib-dataclasses","title":"Inherit from stdlib dataclasses","text":"<p>Stdlib dataclasses (nested or not) can also be inherited and pydantic will automatically validate all the inherited fields.</p> <pre><code>import dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass Z:\n    z: int\n\n\n@dataclasses.dataclass\nclass Y(Z):\n    y: int = 0\n\n\n@pydantic.dataclasses.dataclass\nclass X(Y):\n    x: int = 0\n\n\nfoo = X(x=b'1', y='2', z='3')\nprint(foo)\n\ntry:\n    X(z='pika')\nexcept pydantic.ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/dataclasses/#use-of-stdlib-dataclasses-with-basemodel","title":"Use of stdlib dataclasses with <code>BaseModel</code>","text":"<p>Bear in mind that stdlib dataclasses (nested or not) are automatically converted into pydantic dataclasses when mixed with <code>BaseModel</code>! Furthermore the generated pydantic dataclass will have the exact same configuration (<code>order</code>, <code>frozen</code>, ...) as the original one.</p> <pre><code>import dataclasses\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\n@dataclasses.dataclass(frozen=True)\nclass User:\n    name: str\n\n\n@dataclasses.dataclass\nclass File:\n    filename: str\n    last_modification_time: Optional[datetime] = None\n\n\nclass Foo(BaseModel):\n    file: File\n    user: Optional[User] = None\n\n\nfile = File(\n    filename=['not', 'a', 'string'],\n    last_modification_time='2020-01-01T00:00',\n)  # nothing is validated as expected\nprint(file)\n\ntry:\n    Foo(file=file)\nexcept ValidationError as e:\n    print(e)\n\nfoo = Foo(file=File(filename='myfile'), user=User(name='pika'))\ntry:\n    foo.user.name = 'bulbi'\nexcept dataclasses.FrozenInstanceError as e:\n    print(e)\n</code></pre>"},{"location":"usage/dataclasses/#use-custom-types","title":"Use custom types","text":"<p>Since stdlib dataclasses are automatically converted to add validation using custom types may cause some unexpected behaviour. In this case you can simply add <code>arbitrary_types_allowed</code> in the config!</p> <pre><code>import dataclasses\n\nimport pydantic\n\n\nclass ArbitraryType:\n    def __init__(self, value):\n        self.value = value\n\n    def __repr__(self):\n        return f'ArbitraryType(value={self.value!r})'\n\n\n@dataclasses.dataclass\nclass DC:\n    a: ArbitraryType\n    b: str\n\n\n# valid as it is a builtin dataclass without validation\nmy_dc = DC(a=ArbitraryType(value=3), b='qwe')\n\ntry:\n    class Model(pydantic.BaseModel):\n        dc: DC\n        other: str\n\n    Model(dc=my_dc, other='other')\nexcept RuntimeError as e:  # invalid as it is now a pydantic dataclass\n    print(e)\n\n\nclass Model(pydantic.BaseModel):\n    dc: DC\n    other: str\n\n    class Config:\n        arbitrary_types_allowed = True\n\n\nm = Model(dc=my_dc, other='other')\nprint(repr(m))\n</code></pre>"},{"location":"usage/dataclasses/#initialize-hooks","title":"Initialize hooks","text":"<p>When you initialize a dataclass, it is possible to execute code after validation with the help of <code>__post_init_post_parse__</code>. This is not the same as <code>__post_init__</code>, which executes code before validation.</p> <p>Tip</p> <p>If you use a stdlib <code>dataclass</code>, you may only have <code>__post_init__</code> available and wish the validation to be done before. In this case you can set <code>Config.post_init_call = 'after_validation'</code></p> <pre><code>from pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Birth:\n    year: int\n    month: int\n    day: int\n\n\n@dataclass\nclass User:\n    birth: Birth\n\n    def __post_init__(self):\n        print(self.birth)\n\n    def __post_init_post_parse__(self):\n        print(self.birth)\n\n\nuser = User(**{'birth': {'year': 1995, 'month': 3, 'day': 2}})\n</code></pre> <p>Since version v1.0, any fields annotated with <code>dataclasses.InitVar</code> are passed to both <code>__post_init__</code> and <code>__post_init_post_parse__</code>.</p> <pre><code>from dataclasses import InitVar\nfrom pathlib import Path\nfrom typing import Optional\n\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass PathData:\n    path: Path\n    base_path: InitVar[Optional[Path]]\n\n    def __post_init__(self, base_path):\n        print(f'Received path={self.path!r}, base_path={base_path!r}')\n\n    def __post_init_post_parse__(self, base_path):\n        if base_path is not None:\n            self.path = base_path / self.path\n\n\npath_data = PathData('world', base_path='/hello')\n# Received path='world', base_path='/hello'\nassert path_data.path == Path('/hello/world')\n</code></pre>"},{"location":"usage/dataclasses/#difference-with-stdlib-dataclasses","title":"Difference with stdlib dataclasses","text":"<p>Note that the <code>dataclasses.dataclass</code> from Python stdlib implements only the <code>__post_init__</code> method since it doesn't run a validation step.</p> <p>When substituting usage of <code>dataclasses.dataclass</code> with <code>pydantic.dataclasses.dataclass</code>, it is recommended to move the code executed in the <code>__post_init__</code> method to the <code>__post_init_post_parse__</code> method, and only leave behind part of code which needs to be executed before validation.</p>"},{"location":"usage/dataclasses/#json-dumping","title":"JSON Dumping","text":"<p>Pydantic dataclasses do not feature a <code>.json()</code> function. To dump them as JSON, you will need to make use of the <code>pydantic_encoder</code> as follows:</p> <pre><code>import dataclasses\nimport json\nfrom typing import List\n\nfrom pydantic.dataclasses import dataclass\nfrom pydantic.json import pydantic_encoder\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: List[int] = dataclasses.field(default_factory=lambda: [0])\n\n\nuser = User(id='42')\nprint(json.dumps(user, indent=4, default=pydantic_encoder))\n</code></pre>"},{"location":"usage/devtools/","title":"\u548cdevtools\u4e00\u8d77\u4f7f\u7528","text":"<p>Note</p> <p>Admission: I (the primary developer of pydantic) also develop python-devtools.</p> <p>python-devtools (<code>pip install devtools</code>) provides a number of tools which are useful during Python development, including <code>debug()</code> an alternative to <code>print()</code> which formats output in a way which should be easier to read than <code>print</code> as well as giving information about which file/line the print statement  is on and what value was printed.</p> <p>pydantic integrates with devtools by implementing the <code>__pretty__</code> method on most public classes.</p> <p>In particular <code>debug()</code> is useful when inspecting models:</p> <pre><code># no-print-intercept\nfrom datetime import datetime\nfrom typing import List\nfrom pydantic import BaseModel\n\nfrom devtools import debug\n\n\nclass Address(BaseModel):\n    street: str\n    country: str\n    lat: float\n    lng: float\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    signup_ts: datetime\n    friends: List[int]\n    address: Address\n\n\nuser = User(\n    id='123',\n    name='John Doe',\n    signup_ts='2019-06-01 12:22',\n    friends=[1234, 4567, 7890],\n    address=dict(street='Testing', country='uk', lat=51.5, lng=0),\n)\ndebug(user)\nprint('\\nshould be much easier read than:\\n')\nprint('user:', user)\n</code></pre> <p>Will output in your terminal:</p> <p>```python</p>"},{"location":"usage/exporting_models/","title":"\u6a21\u578b\u5bfc\u51fa","text":"<p>As well as accessing model attributes directly via their names (e.g. <code>model.foobar</code>), models can be converted and exported in a number of ways:</p>"},{"location":"usage/exporting_models/#modeldict","title":"<code>model.dict(...)</code>","text":"<p>This is the primary way of converting a model to a dictionary. Sub-models will be recursively converted to dictionaries.</p> <p>Arguments:</p> <ul> <li><code>include</code>: fields to include in the returned dictionary; see below</li> <li><code>exclude</code>: fields to exclude from the returned dictionary; see below</li> <li><code>by_alias</code>: whether field aliases should be used as keys in the returned dictionary; default <code>False</code></li> <li><code>exclude_unset</code>: whether fields which were not explicitly set when creating the model should   be excluded from the returned dictionary; default <code>False</code>.   Prior to v1.0, <code>exclude_unset</code> was known as <code>skip_defaults</code>; use of <code>skip_defaults</code> is now deprecated</li> <li><code>exclude_defaults</code>: whether fields which are equal to their default values (whether set or otherwise) should   be excluded from the returned dictionary; default <code>False</code></li> <li><code>exclude_none</code>: whether fields which are equal to <code>None</code> should be excluded from the returned dictionary; default   <code>False</code></li> </ul> <p>Example:</p> <pre><code>from pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\n# returns a dictionary:\nprint(m.dict())\nprint(m.dict(include={'foo', 'bar'}))\nprint(m.dict(exclude={'foo', 'bar'}))\n</code></pre>"},{"location":"usage/exporting_models/#dictmodel-and-iteration","title":"<code>dict(model)</code> and iteration","text":"<p>pydantic models can also be converted to dictionaries using <code>dict(model)</code>, and you can also iterate over a model's field using <code>for field_name, value in model:</code>. With this approach the raw field values are returned, so sub-models will not be converted to dictionaries.</p> <p>Example:</p> <pre><code>from pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nprint(dict(m))\nfor name, value in m:\n    print(f'{name}: {value}')\n</code></pre>"},{"location":"usage/exporting_models/#modelcopy","title":"<code>model.copy(...)</code>","text":"<p><code>copy()</code> allows models to be duplicated, which is particularly useful for immutable models.</p> <p>Arguments:</p> <ul> <li><code>include</code>: fields to include in the returned dictionary; see below</li> <li><code>exclude</code>: fields to exclude from the returned dictionary; see below</li> <li><code>update</code>: a dictionary of values to change when creating the copied model</li> <li><code>deep</code>: whether to make a deep copy of the new model; default <code>False</code></li> </ul> <p>Example:</p> <pre><code>from pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nprint(m.copy(include={'foo', 'bar'}))\nprint(m.copy(exclude={'foo', 'bar'}))\nprint(m.copy(update={'banana': 0}))\nprint(id(m.bar), id(m.copy().bar))\n# normal copy gives the same object reference for `bar`\nprint(id(m.bar), id(m.copy(deep=True).bar))\n# deep copy gives a new object reference for `bar`\n</code></pre>"},{"location":"usage/exporting_models/#modeljson","title":"<code>model.json(...)</code>","text":"<p>The <code>.json()</code> method will serialise a model to JSON. (For models with a custom root type, only the value for the <code>__root__</code> key is serialised)</p> <p>Arguments:</p> <ul> <li><code>include</code>: fields to include in the returned dictionary; see below</li> <li><code>exclude</code>: fields to exclude from the returned dictionary; see below</li> <li><code>by_alias</code>: whether field aliases should be used as keys in the returned dictionary; default <code>False</code></li> <li><code>exclude_unset</code>: whether fields which were not set when creating the model and have their default values should   be excluded from the returned dictionary; default <code>False</code>.   Prior to v1.0, <code>exclude_unset</code> was known as <code>skip_defaults</code>; use of <code>skip_defaults</code> is now deprecated</li> <li><code>exclude_defaults</code>: whether fields which are equal to their default values (whether set or otherwise) should   be excluded from the returned dictionary; default <code>False</code></li> <li><code>exclude_none</code>: whether fields which are equal to <code>None</code> should be excluded from the returned dictionary; default   <code>False</code></li> <li><code>encoder</code>: a custom encoder function passed to the <code>default</code> argument of <code>json.dumps()</code>; defaults to a custom   encoder designed to take care of all common types</li> <li><code>**dumps_kwargs</code>: any other keyword arguments are passed to <code>json.dumps()</code>, e.g. <code>indent</code>.</li> </ul> <p>pydantic can serialise many commonly used types to JSON (e.g. <code>datetime</code>, <code>date</code> or <code>UUID</code>) which would normally fail with a simple <code>json.dumps(foobar)</code>.</p> <pre><code>from datetime import datetime\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    foo: datetime\n    bar: BarModel\n\n\nm = FooBarModel(foo=datetime(2032, 6, 1, 12, 13, 14), bar={'whatever': 123})\nprint(m.json())\n</code></pre>"},{"location":"usage/exporting_models/#json_encoders","title":"<code>json_encoders</code>","text":"<p>Serialisation can be customised on a model using the <code>json_encoders</code> config property; the keys should be types (or names of types for forward references), and the values should be functions which serialise that type (see the example below):</p> <pre><code>from datetime import datetime, timedelta\nfrom pydantic import BaseModel\nfrom pydantic.json import timedelta_isoformat\n\n\nclass WithCustomEncoders(BaseModel):\n    dt: datetime\n    diff: timedelta\n\n    class Config:\n        json_encoders = {\n            datetime: lambda v: v.timestamp(),\n            timedelta: timedelta_isoformat,\n        }\n\n\nm = WithCustomEncoders(dt=datetime(2032, 6, 1), diff=timedelta(hours=100))\nprint(m.json())\n</code></pre> <p>By default, <code>timedelta</code> is encoded as a simple float of total seconds. The <code>timedelta_isoformat</code> is provided as an optional alternative which implements ISO 8601 time diff encoding.</p> <p>The <code>json_encoders</code> are also merged during the models inheritance with the child encoders taking precedence over the parent one.</p> <pre><code>from datetime import datetime, timedelta\nfrom pydantic import BaseModel\nfrom pydantic.json import timedelta_isoformat\n\n\nclass BaseClassWithEncoders(BaseModel):\n    dt: datetime\n    diff: timedelta\n\n    class Config:\n        json_encoders = {\n            datetime: lambda v: v.timestamp()\n        }\n\n\nclass ChildClassWithEncoders(BaseClassWithEncoders):\n    class Config:\n        json_encoders = {\n            timedelta: timedelta_isoformat\n        }\n\n\nm = ChildClassWithEncoders(dt=datetime(2032, 6, 1), diff=timedelta(hours=100))\nprint(m.json())\n</code></pre>"},{"location":"usage/exporting_models/#serialising-self-reference-or-other-models","title":"Serialising self-reference or other models","text":"<p>By default, models are serialised as dictionaries. If you want to serialise them differently, you can add <code>models_as_dict=False</code> when calling <code>json()</code> method and add the classes of the model in <code>json_encoders</code>. In case of forward references, you can use a string with the class name instead of the class itself <pre><code>from typing import List, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    city: str\n    country: str\n\n\nclass User(BaseModel):\n    name: str\n    address: Address\n    friends: Optional[List['User']] = None\n\n    class Config:\n        json_encoders = {\n            Address: lambda a: f'{a.city} ({a.country})',\n            'User': lambda u: f'{u.name} in {u.address.city} '\n                              f'({u.address.country[:2].upper()})',\n        }\n\n\nUser.update_forward_refs()\n\nwolfgang = User(\n    name='Wolfgang',\n    address=Address(city='Berlin', country='Deutschland'),\n    friends=[\n        User(name='Pierre', address=Address(city='Paris', country='France')),\n        User(name='John', address=Address(city='London', country='UK')),\n    ],\n)\nprint(wolfgang.json(models_as_dict=False))\n</code></pre></p>"},{"location":"usage/exporting_models/#serialising-subclasses","title":"Serialising subclasses","text":"<p>Note</p> <p>New in version v1.5.</p> <p>Subclasses of common types were not automatically serialised to JSON before v1.5.</p> <p>Subclasses of common types are automatically encoded like their super-classes:</p> <pre><code>from datetime import date, timedelta\nfrom pydantic import BaseModel\nfrom pydantic.validators import int_validator\n\n\nclass DayThisYear(date):\n\"\"\"\n    Contrived example of a special type of date that\n    takes an int and interprets it as a day in the current year\n    \"\"\"\n\n    @classmethod\n    def __get_validators__(cls):\n        yield int_validator\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, v: int):\n        return date.today().replace(month=1, day=1) + timedelta(days=v)\n\n\nclass FooModel(BaseModel):\n    date: DayThisYear\n\n\nm = FooModel(date=300)\nprint(m.json())\n</code></pre>"},{"location":"usage/exporting_models/#custom-json-deserialisation","title":"Custom JSON (de)serialisation","text":"<p>To improve the performance of encoding and decoding JSON, alternative JSON implementations (e.g. ujson) can be used via the <code>json_loads</code> and <code>json_dumps</code> properties of <code>Config</code>.</p> <pre><code>from datetime import datetime\nimport ujson\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int\n    name = 'John Doe'\n    signup_ts: datetime = None\n\n    class Config:\n        json_loads = ujson.loads\n\n\nuser = User.parse_raw('{\"id\": 123,\"signup_ts\":1234567890,\"name\":\"John Doe\"}')\nprint(user)\n</code></pre> <p><code>ujson</code> generally cannot be used to dump JSON since it doesn't support encoding of objects like datetimes and does not accept a <code>default</code> fallback function argument. To do this, you may use another library like orjson.</p> <pre><code>from datetime import datetime\nimport orjson\nfrom pydantic import BaseModel\n\n\ndef orjson_dumps(v, *, default):\n    # orjson.dumps returns bytes, to match standard json.dumps we need to decode\n    return orjson.dumps(v, default=default).decode()\n\n\nclass User(BaseModel):\n    id: int\n    name = 'John Doe'\n    signup_ts: datetime = None\n\n    class Config:\n        json_loads = orjson.loads\n        json_dumps = orjson_dumps\n\n\nuser = User.parse_raw('{\"id\":123,\"signup_ts\":1234567890,\"name\":\"John Doe\"}')\nprint(user.json())\n</code></pre> <p>Note that <code>orjson</code> takes care of <code>datetime</code> encoding natively, making it faster than <code>json.dumps</code> but meaning you cannot always customise the encoding using <code>Config.json_encoders</code>.</p>"},{"location":"usage/exporting_models/#pickledumpsmodel","title":"<code>pickle.dumps(model)</code>","text":"<p>Using the same plumbing as <code>copy()</code>, pydantic models support efficient pickling and unpickling.</p> <pre><code>import pickle\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel):\n    a: str\n    b: int\n\n\nm = FooBarModel(a='hello', b=123)\nprint(m)\ndata = pickle.dumps(m)\nprint(data)\nm2 = pickle.loads(data)\nprint(m2)\n</code></pre>"},{"location":"usage/exporting_models/#advanced-include-and-exclude","title":"Advanced include and exclude","text":"<p>The <code>dict</code>, <code>json</code>, and <code>copy</code> methods support <code>include</code> and <code>exclude</code> arguments which can either be sets or dictionaries. This allows nested selection of which fields to export:</p> <pre><code>from pydantic import BaseModel, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str\n    password: SecretStr\n\n\nclass Transaction(BaseModel):\n    id: str\n    user: User\n    value: int\n\n\nt = Transaction(\n    id='1234567890',\n    user=User(\n        id=42,\n        username='JohnDoe',\n        password='hashedpassword'\n    ),\n    value=9876543210,\n)\n\n# using a set:\nprint(t.dict(exclude={'user', 'value'}))\n\n# using a dict:\nprint(t.dict(exclude={'user': {'username', 'password'}, 'value': True}))\n\nprint(t.dict(include={'id': True, 'user': {'id'}}))\n</code></pre> <p>The <code>True</code> indicates that we want to exclude or include an entire key, just as if we included it in a set. Of course, the same can be done at any depth level.</p> <p>Special care must be taken when including or excluding fields from a list or tuple of submodels or dictionaries.  In this scenario, <code>dict</code> and related methods expect integer keys for element-wise inclusion or exclusion. To exclude a field from every member of a list or tuple, the dictionary key <code>'__all__'</code> can be used as follows:</p> <pre><code>import datetime\nfrom typing import List\n\nfrom pydantic import BaseModel, SecretStr\n\n\nclass Country(BaseModel):\n    name: str\n    phone_code: int\n\n\nclass Address(BaseModel):\n    post_code: int\n    country: Country\n\n\nclass CardDetails(BaseModel):\n    number: SecretStr\n    expires: datetime.date\n\n\nclass Hobby(BaseModel):\n    name: str\n    info: str\n\n\nclass User(BaseModel):\n    first_name: str\n    second_name: str\n    address: Address\n    card_details: CardDetails\n    hobbies: List[Hobby]\n\n\nuser = User(\n    first_name='John',\n    second_name='Doe',\n    address=Address(\n        post_code=123456,\n        country=Country(\n            name='USA',\n            phone_code=1\n        )\n    ),\n    card_details=CardDetails(\n        number=4212934504460000,\n        expires=datetime.date(2020, 5, 1)\n    ),\n    hobbies=[\n        Hobby(name='Programming', info='Writing code and stuff'),\n        Hobby(name='Gaming', info='Hell Yeah!!!'),\n    ],\n)\n\nexclude_keys = {\n    'second_name': True,\n    'address': {'post_code': True, 'country': {'phone_code'}},\n    'card_details': True,\n    # You can exclude fields from specific members of a tuple/list by index:\n    'hobbies': {-1: {'info'}},\n}\n\ninclude_keys = {\n    'first_name': True,\n    'address': {'country': {'name'}},\n    'hobbies': {0: True, -1: {'name'}},\n}\n\n# would be the same as user.dict(exclude=exclude_keys) in this case:\nprint(user.dict(include=include_keys))\n\n# To exclude a field from all members of a nested list or tuple, use \"__all__\":\nprint(user.dict(exclude={'hobbies': {'__all__': {'info'}}}))\n</code></pre> <p>The same holds for the <code>json</code> and <code>copy</code> methods.</p>"},{"location":"usage/exporting_models/#model-and-field-level-include-and-exclude","title":"Model and field level include and exclude","text":"<p>In addition to the explicit arguments <code>exclude</code> and <code>include</code> passed to <code>dict</code>, <code>json</code> and <code>copy</code> methods, we can also pass the <code>include</code>/<code>exclude</code> arguments directly to the <code>Field</code> constructor or the equivalent <code>field</code> entry in the models <code>Config</code> class:</p> <pre><code>from pydantic import BaseModel, Field, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str\n    password: SecretStr = Field(..., exclude=True)\n\n\nclass Transaction(BaseModel):\n    id: str\n    user: User = Field(..., exclude={'username'})\n    value: int\n\n    class Config:\n        fields = {'value': {'exclude': True}}\n\n\nt = Transaction(\n    id='1234567890',\n    user=User(\n        id=42,\n        username='JohnDoe',\n        password='hashedpassword'\n    ),\n    value=9876543210,\n)\n\nprint(t.dict())\n</code></pre> <p>In the case where multiple strategies are used, <code>exclude</code>/<code>include</code> fields are merged according to the following rules:</p> <ul> <li>First, model config level settings (via <code>\"fields\"</code> entry) are merged per field with the field constructor settings (i.e. <code>Field(..., exclude=True)</code>), with the field constructor taking priority.</li> <li>The resulting settings are merged per class with the explicit settings on <code>dict</code>, <code>json</code>, <code>copy</code> calls with the explicit settings taking priority.</li> </ul> <p>Note that while merging settings, <code>exclude</code> entries are merged by computing the \"union\" of keys, while <code>include</code> entries are merged by computing the \"intersection\" of keys.</p> <p>The resulting merged exclude settings:</p> <pre><code>from pydantic import BaseModel, Field, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str  # overridden by explicit exclude\n    password: SecretStr = Field(exclude=True)\n\n\nclass Transaction(BaseModel):\n    id: str\n    user: User\n    value: int\n\n\nt = Transaction(\n    id='1234567890',\n    user=User(\n        id=42,\n        username='JohnDoe',\n        password='hashedpassword'\n    ),\n    value=9876543210,\n)\n\nprint(t.dict(exclude={'value': True, 'user': {'username'}}))\n</code></pre> <p>are the same as using merged include settings as follows:</p> <pre><code>from pydantic import BaseModel, Field, SecretStr\n\n\nclass User(BaseModel):\n    id: int = Field(..., include=True)\n    username: str = Field(..., include=True)  # overridden by explicit include\n    password: SecretStr\n\n\nclass Transaction(BaseModel):\n    id: str\n    user: User\n    value: int\n\n\nt = Transaction(\n    id='1234567890',\n    user=User(\n        id=42,\n        username='JohnDoe',\n        password='hashedpassword'\n    ),\n    value=9876543210,\n)\n\nprint(t.dict(include={'id': True, 'user': {'id'}}))\n</code></pre>"},{"location":"usage/model_config/","title":"\u6a21\u578b\u914d\u7f6e","text":"<p>Behaviour of pydantic can be controlled via the <code>Config</code> class on a model or a pydantic dataclass.</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    v: str\n\n    class Config:\n        max_anystr_length = 10\n        error_msg_templates = {\n            'value_error.any_str.max_length': 'max_length:{limit_value}',\n        }\n\n\ntry:\n    Model(v='x' * 20)\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>Also, you can specify config options as model class kwargs: <pre><code>from pydantic import BaseModel, ValidationError, Extra\n\n\nclass Model(BaseModel, extra=Extra.forbid):\n    a: str\n\n\ntry:\n    Model(a='spam', b='oh no')\nexcept ValidationError as e:\n    print(e)\n</code></pre></p> <p>Similarly, if using the <code>@dataclass</code> decorator: <pre><code>from datetime import datetime\n\nfrom pydantic import ValidationError\nfrom pydantic.dataclasses import dataclass\n\n\nclass MyConfig:\n    max_anystr_length = 10\n    validate_assignment = True\n    error_msg_templates = {\n        'value_error.any_str.max_length': 'max_length:{limit_value}',\n    }\n\n\n@dataclass(config=MyConfig)\nclass User:\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime = None\n\n\nuser = User(id='42', signup_ts='2032-06-21T12:00')\ntry:\n    user.name = 'x' * 20\nexcept ValidationError as e:\n    print(e)\n</code></pre></p>"},{"location":"usage/model_config/#options","title":"Options","text":"<code>title</code> the title for the generated JSON Schema <code>anystr_strip_whitespace</code> whether to strip leading and trailing whitespace for str &amp; byte types (default: <code>False</code>) <code>anystr_upper</code> whether to make all characters uppercase for str &amp; byte types (default: <code>False</code>) <code>anystr_lower</code> whether to make all characters lowercase for str &amp; byte types (default: <code>False</code>) <code>min_anystr_length</code> the min length for str &amp; byte types (default: <code>0</code>) <code>max_anystr_length</code> the max length for str &amp; byte types (default: <code>None</code>) <code>validate_all</code> whether to validate field defaults (default: <code>False</code>) <code>extra</code> whether to ignore, allow, or forbid extra attributes during model initialization. Accepts the string values of <code>'ignore'</code>, <code>'allow'</code>, or <code>'forbid'</code>, or values of the <code>Extra</code> enum (default: <code>Extra.ignore</code>). <code>'forbid'</code> will cause validation to fail if extra attributes are included, <code>'ignore'</code> will silently ignore any extra attributes, and <code>'allow'</code> will assign the attributes to the model. <code>allow_mutation</code> whether or not models are faux-immutable, i.e. whether <code>__setattr__</code> is allowed (default: <code>True</code>) <p><code>frozen</code></p> <p>Warning</p> <p>This parameter is in beta</p> setting <code>frozen=True</code> does everything that <code>allow_mutation=False</code> does, and also generates a <code>__hash__()</code> method for the model. This makes instances of the model potentially hashable if all the attributes are hashable. (default: <code>False</code>) <code>use_enum_values</code> whether to populate models with the <code>value</code> property of enums, rather than the raw enum. This may be useful if you want to serialise <code>model.dict()</code> later (default: <code>False</code>) <code>fields</code> a <code>dict</code> containing schema information for each field; this is equivalent to using the <code>Field</code> class, except when a field is already defined through annotation or the Field class, in which case only <code>alias</code>, <code>include</code>, <code>exclude</code>, <code>min_length</code>, <code>max_length</code>, <code>regex</code>, <code>gt</code>, <code>lt</code>, <code>gt</code>, <code>le</code>, <code>multiple_of</code>, <code>max_digits</code>, <code>decimal_places</code>, <code>min_items</code>, <code>max_items</code>, <code>unique_items</code> and allow_mutation can be set (for example you cannot set default of default_factory)  (default: <code>None</code>) <code>validate_assignment</code> whether to perform validation on assignment to attributes (default: <code>False</code>) <code>allow_population_by_field_name</code> whether an aliased field may be populated by its name as given by the model attribute, as well as the alias (default: <code>False</code>) <p>Note</p> <p>The name of this configuration setting was changed in v1.0 from <code>allow_population_by_alias</code> to <code>allow_population_by_field_name</code>.</p> <code>error_msg_templates</code> a <code>dict</code> used to override the default error message templates. Pass in a dictionary with keys matching the error messages you want to override (default: <code>{}</code>) <code>arbitrary_types_allowed</code> whether to allow arbitrary user types for fields (they are validated simply by checking if the value is an instance of the type). If <code>False</code>, <code>RuntimeError</code> will be raised on model declaration (default: <code>False</code>). See an example in Field Types. <code>orm_mode</code> whether to allow usage of ORM mode <code>getter_dict</code> a custom class (which should inherit from <code>GetterDict</code>) to use when decomposing arbitrary classes for validation, for use with <code>orm_mode</code>; see Data binding. <code>alias_generator</code> a callable that takes a field name and returns an alias for it; see the dedicated section <code>keep_untouched</code> a tuple of types (e.g. descriptors) for a model's default values that should not be changed during model creation and will not be included in the model schemas. Note: this means that attributes on the model with defaults of this type, not annotations of this type, will be left alone. <code>schema_extra</code> a <code>dict</code> used to extend/update the generated JSON Schema, or a callable to post-process it; see schema customization <code>json_loads</code> a custom function for decoding JSON; see custom JSON (de)serialisation <code>json_dumps</code> a custom function for encoding JSON; see custom JSON (de)serialisation <code>json_encoders</code> a <code>dict</code> used to customise the way types are encoded to JSON; see JSON Serialisation <code>underscore_attrs_are_private</code> whether to treat any underscore non-class var attrs as private, or leave them as is; see Private model attributes <code>copy_on_model_validation</code> string literal to control how models instances are processed during validation,  with the following means (see #4093 for a full discussion of the changes to this field): <ul> <li><code>'none'</code> - models are not copied on validation, they're simply kept \"untouched\"</li> <li><code>'shallow'</code> - models are shallow copied, this is the default</li> <li><code>'deep'</code> - models are deep copied </li> </ul> <code>smart_union</code> whether pydantic should try to check all types inside <code>Union</code> to prevent undesired coercion; see the dedicated section <code>post_init_call</code> whether stdlib dataclasses <code>__post_init__</code> should be run before (default behaviour with value <code>'before_validation'</code>) or after (value <code>'after_validation'</code>) parsing and validation when they are converted. <code>allow_inf_nan</code> whether to allow infinity (<code>+inf</code> an <code>-inf</code>) and NaN values to float fields, defaults to <code>True</code>, set to <code>False</code> for compatibility with <code>JSON</code>, see #3994 for more details, added in V1.10"},{"location":"usage/model_config/#change-behaviour-globally","title":"Change behaviour globally","text":"<p>If you wish to change the behaviour of pydantic globally, you can create your own custom <code>BaseModel</code> with custom <code>Config</code> since the config is inherited <pre><code>from pydantic import BaseModel as PydanticBaseModel\n\n\nclass BaseModel(PydanticBaseModel):\n    class Config:\n        arbitrary_types_allowed = True\n\n\nclass MyClass:\n\"\"\"A random class\"\"\"\n\n\nclass Model(BaseModel):\n    x: MyClass\n</code></pre></p>"},{"location":"usage/model_config/#alias-generator","title":"Alias Generator","text":"<p>If data source field names do not match your code style (e. g. CamelCase fields), you can automatically generate aliases using <code>alias_generator</code>:</p> <pre><code>from pydantic import BaseModel\n\n\ndef to_camel(string: str) -&gt; str:\n    return ''.join(word.capitalize() for word in string.split('_'))\n\n\nclass Voice(BaseModel):\n    name: str\n    language_code: str\n\n    class Config:\n        alias_generator = to_camel\n\n\nvoice = Voice(Name='Filiz', LanguageCode='tr-TR')\nprint(voice.language_code)\nprint(voice.dict(by_alias=True))\n</code></pre> <p>Here camel case refers to \"upper camel case\" aka pascal case e.g. <code>CamelCase</code>. If you'd like instead to use lower camel case e.g. <code>camelCase</code>, instead use the <code>to_lower_camel</code> function.</p>"},{"location":"usage/model_config/#alias-precedence","title":"Alias Precedence","text":"<p>Warning</p> <p>Alias priority logic changed in v1.4 to resolve buggy and unexpected behaviour in previous versions. In some circumstances this may represent a breaking change, see #1178 and the precedence order below for details.</p> <p>In the case where a field's alias may be defined in multiple places, the selected value is determined as follows (in descending order of priority):</p> <ol> <li>Set via <code>Field(..., alias=&lt;alias&gt;)</code>, directly on the model</li> <li>Defined in <code>Config.fields</code>, directly on the model</li> <li>Set via <code>Field(..., alias=&lt;alias&gt;)</code>, on a parent model</li> <li>Defined in <code>Config.fields</code>, on a parent model</li> <li>Generated by <code>alias_generator</code>, regardless of whether it's on the model or a parent</li> </ol> <p>Note</p> <p>This means an <code>alias_generator</code> defined on a child model does not take priority over an alias defined on a field in a parent model.</p> <p>For example:</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Voice(BaseModel):\n    name: str = Field(None, alias='ActorName')\n    language_code: str = None\n    mood: str = None\n\n\nclass Character(Voice):\n    act: int = 1\n\n    class Config:\n        fields = {'language_code': 'lang'}\n\n        @classmethod\n        def alias_generator(cls, string: str) -&gt; str:\n            # this is the same as `alias_generator = to_camel` above\n            return ''.join(word.capitalize() for word in string.split('_'))\n\n\nprint(Character.schema(by_alias=True))\n</code></pre>"},{"location":"usage/model_config/#smart-union","title":"Smart Union","text":"<p>By default, as explained here, pydantic tries to validate (and coerce if it can) in the order of the <code>Union</code>. So sometimes you may have unexpected coerced data.</p> <pre><code>from typing import Union\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    pass\n\n\nclass Bar(BaseModel):\n    pass\n\n\nclass Model(BaseModel):\n    x: Union[str, int]\n    y: Union[Foo, Bar]\n\n\nprint(Model(x=1, y=Bar()))\n</code></pre> <p>To prevent this, you can enable <code>Config.smart_union</code>. Pydantic will then check all allowed types before even trying to coerce. Know that this is of course slower, especially if your <code>Union</code> is quite big.</p> <pre><code>from typing import Union\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    pass\n\n\nclass Bar(BaseModel):\n    pass\n\n\nclass Model(BaseModel):\n    x: Union[str, int]\n    y: Union[Foo, Bar]\n\n    class Config:\n        smart_union = True\n\n\nprint(Model(x=1, y=Bar()))\n</code></pre> <p>Warning</p> <p>Note that this option does not support compound types yet (e.g. differentiate <code>List[int]</code> and <code>List[str]</code>). This option will be improved further once a strict mode is added in pydantic and will probably be the default behaviour in v2!</p> <pre><code>from typing import List, Union\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel, smart_union=True):\n    x: Union[List[str], List[int]]\n\n\n# Expected coercion\nprint(Model(x=[1, '2']))\n\n# Unexpected coercion\nprint(Model(x=[1, 2]))\n</code></pre>"},{"location":"usage/models/","title":"\u6a21\u578b","text":"<p>\u5728pydantic\u4e2d\u5b9a\u4e49\u5bf9\u8c61\u7684\u4e3b\u8981\u65b9\u6cd5\u662f\u901a\u8fc7\u6a21\u578b\uff08\u6a21\u578b\u53ea\u662f\u7ee7\u627f\u81ea\u7684\u7c7b<code>BaseModel</code>\uff09\u3002</p> <p>\u60a8\u53ef\u4ee5\u5c06\u6a21\u578b\u89c6\u4e3a\u7c7b\u4f3c\u4e8e\u4e25\u683c\u7c7b\u578b\u5316\u8bed\u8a00\u4e2d\u7684\u7c7b\u578b\uff0c\u6216\u8005\u89c6\u4e3a API \u4e2d\u5355\u4e2a\u7aef\u70b9\u7684\u8981\u6c42\u3002</p> <p>\u4e0d\u53d7\u4fe1\u4efb\u7684\u6570\u636e\u53ef\u4ee5\u4f20\u9012\u7ed9\u6a21\u578b\uff0c\u5728\u89e3\u6790\u548c\u9a8c\u8bc1\u4e4b\u540e\uff0c<code>pydantic</code>\u4fdd\u8bc1\u751f\u6210\u7684\u6a21\u578b\u5b9e\u4f8b\u7684\u5b57\u6bb5\u5c06\u7b26\u5408\u6a21\u578b\u4e0a\u5b9a\u4e49\u7684\u5b57\u6bb5\u7c7b\u578b\u3002</p> <p>\u7b14\u8bb0</p> <p>pydantic\u4e3b\u8981\u662f\u4e00\u4e2a\u89e3\u6790\u5e93\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a\u9a8c\u8bc1\u5e93\u3002</p> <p>\u9a8c\u8bc1\u662f\u8fbe\u5230\u76ee\u7684\u7684\u4e00\u79cd\u624b\u6bb5\uff1a\u5efa\u7acb\u4e00\u4e2a\u7b26\u5408\u6240\u63d0\u4f9b\u7684\u7c7b\u578b\u548c\u7ea6\u675f\u7684\u6a21\u578b\u3002</p> <p>\u6362\u53e5\u8bdd\u8bf4\uff0cpydantic\u4fdd\u8bc1\u8f93\u51fa\u6a21\u578b\u7684\u7c7b\u578b\u548c\u7ea6\u675f\uff0c\u800c\u4e0d\u662f\u8f93\u5165\u6570\u636e\u3002</p> <p>\u8fd9\u542c\u8d77\u6765\u50cf\u662f\u4e00\u4e2a\u6df1\u5965\u7684\u533a\u522b\uff0c\u4f46\u4e8b\u5b9e\u5e76\u975e\u5982\u6b64\u3002\u5982\u679c\u60a8\u4e0d\u786e\u5b9a\u8fd9\u610f\u5473\u7740\u4ec0\u4e48\u6216\u5b83\u5982\u4f55\u5f71\u54cd\u60a8\u7684\u4f7f\u7528\uff0c\u60a8\u5e94\u8be5\u9605\u8bfb\u4e0b\u9762\u6709\u5173\u6570\u636e\u8f6c\u6362\u7684\u90e8\u5206\u3002</p> <p>\u867d\u7136\u9a8c\u8bc1\u4e0d\u662fpydantic\u7684\u4e3b\u8981\u76ee\u7684\uff0c\u4f46\u60a8\u53ef\u4ee5\u4f7f\u7528\u6b64\u5e93\u8fdb\u884c\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u3002</p>"},{"location":"usage/models/#basic-model-usage","title":"\u57fa\u672c\u6a21\u578b\u4f7f\u7528(Basic model usage)","text":"<pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name = 'Jane Doe'\n</code></pre> <p>\u8fd9\u513f\u7684 <code>User</code>\u662f\u4e00\u4e2a\u6709\u4e24\u4e2a\u5b57\u6bb5\u7684\u6a21\u578b\uff0c<code>id</code>\u4e00\u4e2a\u662f\u6574\u6570\uff0c\u662f\u5fc5\u9700\u7684\uff0c\u53e6\u4e00\u4e2a<code>name</code>\u662f\u5b57\u7b26\u4e32\uff0c\u4e0d\u662f\u5fc5\u9700\u7684\uff08\u5b83\u6709\u4e00\u4e2a\u9ed8\u8ba4\u503c\uff09\u3002<code>name</code>\u7684\u7c7b\u578b\u662f\u4ece\u9ed8\u8ba4\u503c\u63a8\u65ad\u51fa\u6765\u7684\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u7c7b\u578b\u6ce8\u91ca\uff08\u4f46\u662f\u5f53\u67d0\u4e9b\u5b57\u6bb5\u6ca1\u6709\u7c7b\u578b\u6ce8\u91ca\u65f6\u8bf7\u6ce8\u610f\u6709\u5173\u5b57\u6bb5\u987a\u5e8f\u7684\u8b66\u544a\uff09\u3002</p> <pre><code>user = User(id='123')\nuser_x = User(id='123.45')\n</code></pre> <p>\u8fd9\u513f\u7684 <code>user</code> \u662f <code>User</code> \u7684\u5b9e\u4f8b\uff0c\u5bf9\u8c61\u7684\u521d\u59cb\u5316\u5c06\u6267\u884c\u6240\u6709\u7684\u89e3\u6790\u548c\u9a8c\u8bc1\u3002\u5982\u679c\u6ca1\u6709\u5f15\u53d1<code>ValidationError</code>\uff0c\u5219\u751f\u6210\u7684\u6a21\u578b\u5b9e\u4f8b\u662f\u6709\u6548\u7684\u3002</p> <pre><code>assert user.id == 123\nassert user_x.id == 123\nassert isinstance(user_x.id, int)  # Note that 123.45 was casted to an int and its value is 123\n</code></pre> <p>\u6709\u5173<code>user_x</code>\u5f62\u5f0f\u7684\u6570\u636e\u8f6c\u6362\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u6570\u636e\u8f6c\u6362\u3002 \u6a21\u578b\u7684\u5b57\u6bb5\u53ef\u4ee5\u4f5c\u4e3a\u7528\u6237\u5bf9\u8c61\u7684\u666e\u901a\u5c5e\u6027\u6765\u8bbf\u95ee\u3002 \u6839\u636e\u5b57\u6bb5\u7c7b\u578b\uff0c\u5b57\u7b26\u4e32\u201c123\u201d\u5df2\u8f6c\u6362\u4e3a int</p> <pre><code>assert user.name == 'Jane Doe'\n</code></pre> <p><code>name</code> \u5728\u7528\u6237\u521d\u59cb\u5316\u65f6\u6ca1\u6709\u8bbe\u7f6e\uff0c\u6240\u4ee5\u5b83\u6709\u9ed8\u8ba4\u503c</p> <pre><code>assert user.__fields_set__ == {'id'}\n</code></pre> <p>\u521d\u59cb\u5316\u7528\u6237\u65f6\u63d0\u4f9b\u7684\u5b57\u6bb5\u3002</p> <pre><code>assert user.dict() == dict(user) == {'id': 123, 'name': 'Jane Doe'}\n</code></pre> <p><code>.dict()</code> \u6216 <code>dict(user)</code> \u5c06\u63d0\u4f9b\u5b57\u6bb5\u7684\u5b57\u5178\uff0c\u4f46 <code>.dict()</code> \u53ef\u4ee5\u63a5\u53d7\u8bb8\u591a\u5176\u4ed6\u53c2\u6570\u3002</p> <pre><code>user.id = 321\nassert user.id == 321\n</code></pre> <p>\u8be5\u6a21\u578b\u662f\u53ef\u53d8\u7684\uff0c\u56e0\u6b64\u53ef\u4ee5\u66f4\u6539\u5b57\u6bb5\u503c\u3002</p>"},{"location":"usage/models/#model-properties","title":"\u6a21\u578b\u5c5e\u6027(Model properties)","text":"<p>\u4e0a\u9762\u7684\u4f8b\u5b50\u53ea\u5c55\u793a\u4e86\u6a21\u578b\u53ef\u4ee5\u505a\u4ec0\u4e48\u7684\u51b0\u5c71\u4e00\u89d2\u3002\u6a21\u578b\u5177\u6709\u4ee5\u4e0b\u65b9\u6cd5\u548c\u5c5e\u6027\uff1a</p> <code>dict()</code> \u8fd4\u56de\u6a21\u578b\u5b57\u6bb5\u548c\u503c\u7684\u5b57\u5178\u5f62\u5f0f; \u53c2\u8003 \u5bfc\u51fa\u6a21\u578b <code>json()</code> \u8fd4\u56de\u4e00\u4e2a JSON \u5b57\u7b26\u4e32\u8868\u793a <code>dict()</code>\uff1b \u53c2\u8003 \u5bfc\u51fa\u6a21\u578b <code>copy()</code> \u8fd4\u56de\u6a21\u578b\u7684\u526f\u672c\uff08\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4e3a\u6d45\u526f\u672c\uff09; \u53c2\u8003 \u5bfc\u51fa\u6a21\u578b <code>parse_obj()</code> \u5982\u679c\u5bf9\u8c61\u4e0d\u662f\u5b57\u5178\uff0c\u5219\u7528\u4e8e\u5c06\u4efb\u4f55\u5bf9\u8c61\u52a0\u8f7d\u5230\u6a21\u578b\u4e2d\u5e76\u8fdb\u884c\u9519\u8bef\u5904\u7406\u7684\u5b9e\u7528\u7a0b\u5e8f\uff1b \u53c2\u8003 \u8f85\u52a9\u51fd\u6570 <code>parse_raw()</code> \u7528\u4e8e\u52a0\u8f7d\u591a\u79cd\u683c\u5f0f\u7684\u5b57\u7b26\u4e32\u7684\u8f85\u52a9\u51fd\u6570; \u53c2\u8003 [\u8f85\u52a9\u51fd\u6570] (#helper-functions) <code>parse_file()</code> \u7c7b\u4f3c\u4e8e <code>parse_raw()</code> \u4f46\u7528\u4e8e\u6587\u4ef6\u8def\u5f84\uff1b \u53c2\u8003 [\u8f85\u52a9\u51fd\u6570] (#helper-functions) <code>from_orm()</code> \u5c06\u6570\u636e\u4ece\u4efb\u610f\u7c7b\u52a0\u8f7d\u5230\u6a21\u578b\u4e2d\uff1b \u53c2\u8003 ORM\u6a21\u5f0f <code>schema()</code> \u8fd4\u56de\u5c06\u6a21\u578b\u8868\u793a\u4e3a JSON Schema \u7684\u5b57\u5178\uff1b \u53c2\u8003 \u56fe\u5f0f <code>schema_json()</code> \u8fd4\u56de <code>schema()</code> \u7684 JSON \u5b57\u7b26\u4e32\u8868\u793a\uff1b \u53c2\u8003 \u56fe\u5f0f <code>construct()</code> \u4e00\u79cd\u65e0\u9700\u8fd0\u884c\u9a8c\u8bc1\u5373\u53ef\u521b\u5efa\u6a21\u578b\u7684\u7c7b\u65b9\u6cd5\uff1b \u53c2\u8003 \u521b\u5efa\u65e0\u9700\u6821\u9a8c\u7684\u6a21\u578b <code>__fields_set__</code> \u521d\u59cb\u5316\u6a21\u578b\u5b9e\u4f8b\u65f6\u8bbe\u7f6e\u7684\u5b57\u6bb5\u540d\u79f0\u96c6 <code>__fields__</code> \u6a21\u578b\u5b57\u6bb5\u7684\u5b57\u5178 <code>__config__</code> \u6a21\u578b\u7684\u914d\u7f6e\u7c7b, \u53c2\u8003 \u6a21\u578b\u914d\u7f6e"},{"location":"usage/models/#recursive-models","title":"\u5d4c\u5957\u6a21\u578b(Recursive Models)","text":"<p>\u53ef\u4ee5\u4f7f\u7528\u6a21\u578b\u672c\u8eab\u4f5c\u4e3a\u6ce8\u91ca\u4e2d\u7684\u7c7b\u578b\u6765\u5b9a\u4e49\u66f4\u590d\u6742\u7684\u5206\u5c42\u6570\u636e\u7ed3\u6784\u3002</p> <pre><code>from typing import List, Optional\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    count: int\n    size: Optional[float] = None\n\n\nclass Bar(BaseModel):\n    apple = 'x'\n    banana = 'y'\n\n\nclass Spam(BaseModel):\n    foo: Foo\n    bars: List[Bar]\n\n\nm = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])\nprint(m)\nprint(m.dict())\n</code></pre> <p>\u5bf9\u4e8e\u81ea\u5f15\u7528\u6a21\u578b\uff0c \u89c1 \u5ef6\u65f6\u6ce8\u89e3.</p>"},{"location":"usage/models/#orm-aka-arbitrary-class-instances","title":"ORM \u6a21\u5f0f\u3010\u53c8\u540d\u4efb\u610f\u7c7b\u5b9e\u4f8b\u3011 (aka Arbitrary Class Instances)","text":"<p>\u53ef\u4ee5\u4ece\u4efb\u610f\u7c7b\u5b9e\u4f8b\u521b\u5efa Pydantic \u6a21\u578b\u4ee5\u652f\u6301\u6620\u5c04\u5230 ORM \u5bf9\u8c61\u7684\u6a21\u578b\u3002</p> <p>\u53bb\u505a\u8fd9\u4e2a\uff1a</p> <ol> <li>Config \u7684\u5c5e\u6027 <code>orm_mode</code> \u5fc5\u987b\u8bbe\u7f6e\u4e3a <code>True</code>.</li> <li>\u5fc5\u987b\u4f7f\u7528\u7279\u6b8a\u6784\u9020\u51fd\u6570 <code>from_orm</code> \u6765\u521b\u5efa\u6a21\u578b\u5b9e\u4f8b\u3002</li> </ol> <p>\u6b64\u5904\u7684\u793a\u4f8b\u4f7f\u7528 SQLAlchemy\uff0c\u4f46\u540c\u6837\u7684\u65b9\u6cd5\u9002\u7528\u4e8e\u4efb\u4f55 ORM\u3002</p> <pre><code>from typing import List\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.dialects.postgresql import ARRAY\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom pydantic import BaseModel, constr\n\nBase = declarative_base()\n\n\nclass CompanyOrm(Base):\n    __tablename__ = 'companies'\n    id = Column(Integer, primary_key=True, nullable=False)\n    public_key = Column(String(20), index=True, nullable=False, unique=True)\n    name = Column(String(63), unique=True)\n    domains = Column(ARRAY(String(255)))\n\n\nclass CompanyModel(BaseModel):\n    id: int\n    public_key: constr(max_length=20)\n    name: constr(max_length=63)\n    domains: List[constr(max_length=255)]\n\n    class Config:\n        orm_mode = True\n\n\nco_orm = CompanyOrm(\n    id=123,\n    public_key='foobar',\n    name='Testing',\n    domains=['example.com', 'foobar.com'],\n)\nprint(co_orm)\nco_model = CompanyModel.from_orm(co_orm)\nprint(co_model)\n</code></pre>"},{"location":"usage/models/#reserved-names","title":"Reserved names","text":"<p>\u60a8\u53ef\u80fd\u5e0c\u671b\u5728\u4fdd\u7559\u7684 SQLAlchemy \u5b57\u6bb5\u4e4b\u540e\u91cd\u65b0\u547d\u540d\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cField \u522b\u540d\u4f1a\u5f88\u65b9\u4fbf\uff1a</p> <pre><code>import typing\n\nfrom pydantic import BaseModel, Field\nimport sqlalchemy as sa\nfrom sqlalchemy.ext.declarative import declarative_base\n\n\nclass MyModel(BaseModel):\n    metadata: typing.Dict[str, str] = Field(alias='metadata_')\n\n    class Config:\n        orm_mode = True\n\n\nBase = declarative_base()\n\n\nclass SQLModel(Base):\n    __tablename__ = 'my_table'\n    id = sa.Column('id', sa.Integer, primary_key=True)\n    # 'metadata' is reserved by SQLAlchemy, hence the '_'\n    metadata_ = sa.Column('metadata', sa.JSON)\n\n\nsql_model = SQLModel(metadata_={'key': 'val'}, id=1)\n\npydantic_model = MyModel.from_orm(sql_model)\n\nprint(pydantic_model.dict())\nprint(pydantic_model.dict(by_alias=True))\n</code></pre> <p>Note</p> <p>\u4e0a\u9762\u7684\u793a\u4f8b\u4e4b\u6240\u4ee5\u6709\u6548\uff0c\u662f\u56e0\u4e3a\u522b\u540d\u4f18\u5148\u4e8e\u5b57\u6bb5\u586b\u5145\u7684\u5b57\u6bb5\u540d\u79f0\u3002 \u8bbf\u95ee <code>SQLModel</code>\u7684 <code>metadata</code> \u5c5e\u6027\u4f1a\u5bfc\u81f4<code>ValidationError</code>\u3002</p>"},{"location":"usage/models/#ormrecursive-orm-models","title":"\u5d4c\u5957ORM\u6a21\u578b(Recursive ORM models)","text":"<p>ORM \u5b9e\u4f8b\u5c06\u4f7f\u7528 <code>from_orm</code> \u9012\u5f52\u5730\u4ee5\u53ca\u5728\u9876\u5c42\u8fdb\u884c\u89e3\u6790\u3002</p> <p>\u8fd9\u91cc\u4f7f\u7528\u666e\u901a\u7c7b\u6765\u6f14\u793a\u539f\u7406\uff0c\u4f46\u4e5f\u53ef\u4ee5\u4f7f\u7528\u4efb\u4f55 ORM \u7c7b\u3002</p> <pre><code>from typing import List\nfrom pydantic import BaseModel\n\n\nclass PetCls:\n    def __init__(self, *, name: str, species: str):\n        self.name = name\n        self.species = species\n\n\nclass PersonCls:\n    def __init__(self, *, name: str, age: float = None, pets: List[PetCls]):\n        self.name = name\n        self.age = age\n        self.pets = pets\n\n\nclass Pet(BaseModel):\n    name: str\n    species: str\n\n    class Config:\n        orm_mode = True\n\n\nclass Person(BaseModel):\n    name: str\n    age: float = None\n    pets: List[Pet]\n\n    class Config:\n        orm_mode = True\n\n\nbones = PetCls(name='Bones', species='dog')\norion = PetCls(name='Orion', species='cat')\nanna = PersonCls(name='Anna', age=20, pets=[bones, orion])\nanna_model = Person.from_orm(anna)\nprint(anna_model)\n</code></pre>"},{"location":"usage/models/#data-binding","title":"\u6570\u636e\u7ed1\u5b9a(Data binding)","text":"<p>pydantic \u4f7f\u7528 <code>GetterDict</code> \u7c7b\u5904\u7406\u4efb\u610f\u7c7b\uff08\u53c2\u89c1 utils.py\uff09\uff0c \u5b83\u8bd5\u56fe\u4e3a\u4efb\u4f55\u7c7b\u63d0\u4f9b\u7c7b\u4f3c\u5b57\u5178\u7684\u63a5\u53e3\u3002 \u60a8\u53ef\u4ee5\u901a\u8fc7\u5c06\u60a8\u81ea\u5df1\u7684 <code>GetterDict</code> \u5b50\u7c7b\u8bbe\u7f6e\u4e3a <code>Config.getter_dict</code> \u7684\u503c\u6765\u81ea\u5b9a\u4e49\u5176\u5de5\u4f5c\u65b9\u5f0f\uff08\u53c2\u89c1 config\uff09\u3002</p> <p>\u60a8\u8fd8\u53ef\u4ee5\u4f7f\u7528\u5e26\u6709 <code>pre=True</code> \u7684 root_validators \u81ea\u5b9a\u4e49\u7c7b\u9a8c\u8bc1\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u7684\u9a8c\u8bc1\u5668\u51fd\u6570\u5c06\u88ab\u4f20\u9012\u7ed9\u60a8\u53ef\u4ee5\u590d\u5236\u548c\u4fee\u6539\u7684 <code>GetterDict</code> \u5b9e\u4f8b\u3002</p> <p>\u5c06\u4e3a\u6bcf\u4e2a\u5b57\u6bb5\u8c03\u7528 <code>GetterDict</code> \u5b9e\u4f8b\uff0c\u5e76\u5c06\u6807\u8bb0\uff08\u5982\u679c\u672a\u8bbe\u7f6e\u5176\u4ed6\u9ed8\u8ba4\u503c\uff09\u3002 \u8fd4\u56de\u6b64\u6807\u8bb0\u610f\u5473\u7740\u8be5\u5b57\u6bb5\u4e22\u5931\u3002 \u4efb\u4f55\u5176\u4ed6\u503c\u90fd\u5c06\u88ab\u89e3\u91ca\u4e3a\u8be5\u5b57\u6bb5\u7684\u503c\u3002</p> <pre><code>from pydantic import BaseModel\nfrom typing import Any, Optional\nfrom pydantic.utils import GetterDict\nfrom xml.etree.ElementTree import fromstring\n\n\nxmlstring = \"\"\"\n&lt;User Id=\"2138\"&gt;\n    &lt;FirstName /&gt;\n    &lt;LoggedIn Value=\"true\" /&gt;\n&lt;/User&gt;\n\"\"\"\n\n\nclass UserGetter(GetterDict):\n\n    def get(self, key: str, default: Any) -&gt; Any:\n\n        # element attributes\n        if key in {'Id', 'Status'}:\n            return self._obj.attrib.get(key, default)\n\n        # element children\n        else:\n            try:\n                return self._obj.find(key).attrib['Value']\n            except (AttributeError, KeyError):\n                return default\n\n\nclass User(BaseModel):\n    Id: int\n    Status: Optional[str]\n    FirstName: Optional[str]\n    LastName: Optional[str]\n    LoggedIn: bool\n\n    class Config:\n        orm_mode = True\n        getter_dict = UserGetter\n\n\nuser = User.from_orm(fromstring(xmlstring))\n</code></pre>"},{"location":"usage/models/#error-handling","title":"\u9519\u8bef\u5904\u7406(Error Handling)","text":"<p>pydantic \u4f1a\u5728\u53d1\u73b0\u6b63\u5728\u9a8c\u8bc1\u7684\u6570\u636e\u4e2d\u5b58\u5728\u9519\u8bef\u65f6\u5f15\u53d1 <code>ValidationError</code>\u3002</p> <p>Note</p> <p>\u9a8c\u8bc1\u4ee3\u7801\u4e0d\u5e94\u5f15\u53d1 <code>ValidationError</code> \u672c\u8eab\uff0c\u800c\u662f\u5f15\u53d1 <code>ValueError</code>\u3001<code>TypeError</code> \u6216 <code>AssertionError</code>\uff08\u6216 <code>ValueError</code> \u6216 <code>TypeError</code> \u7684\u5b50\u7c7b\uff09\uff0c\u5b83\u4eec\u5c06\u88ab\u6355\u83b7\u5e76\u7528\u4e8e\u586b\u5145 <code>ValidationError</code>\u3002</p> <p>\u65e0\u8bba\u53d1\u73b0\u591a\u5c11\u9519\u8bef\uff0c\u90fd\u4f1a\u5f15\u53d1\u4e00\u4e2a\u5f02\u5e38\uff0c\u5373 <code>ValidationError</code> \u5c06\u5305\u542b\u6709\u5173\u6240\u6709\u9519\u8bef\u53ca\u5176\u53d1\u751f\u65b9\u5f0f\u7684\u4fe1\u606f\u3002</p> <p>\u60a8\u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u65b9\u5f0f\u8bbf\u95ee\u8fd9\u4e9b\u9519\u8bef\uff1a</p> <code>e.errors()</code> \u65b9\u6cd5\u5c06\u8fd4\u56de\u5728\u8f93\u5165\u6570\u636e\u4e2d\u53d1\u73b0\u7684\u9519\u8bef\u5217\u8868\u3002 <code>e.json()</code> \u65b9\u6cd5\u5c06\u8fd4\u56de <code>errors</code> \u7684 JSON \u8868\u793a\u3002 <code>str(e)</code> \u65b9\u6cd5\u5c06\u8fd4\u56de\u9519\u8bef\u7684\u4eba\u7c7b\u53ef\u8bfb\u8868\u793a\u3002 <p>\u6bcf\u4e2a\u9519\u8bef\u5bf9\u8c61\u5305\u542b\uff1a</p> <code>loc</code> \u9519\u8bef\u7684\u4f4d\u7f6e\u4f5c\u4e3a\u5217\u8868\u3002 \u5217\u8868\u4e2d\u7684\u7b2c\u4e00\u9879\u5c06\u662f\u53d1\u751f\u9519\u8bef\u7684\u5b57\u6bb5\uff0c\u5982\u679c\u8be5\u5b57\u6bb5\u662f \u5b50\u6a21\u5757\uff0c\u5219\u5c06\u51fa\u73b0\u540e\u7eed\u9879\u4ee5\u6307\u793a\u9519\u8bef\u7684\u5d4c\u5957\u4f4d\u7f6e\u3002 <code>type</code> \u9519\u8bef\u7c7b\u578b\u7684\u8ba1\u7b97\u673a\u53ef\u8bfb\u6807\u8bc6\u7b26\u3002 <p><code>msg</code> :\u9519\u8bef\u7c7b\u578b\u7684\u8ba1\u7b97\u673a\u53ef\u8bfb\u6807\u8bc6\u7b26\u3002</p> <code>ctx</code> \u4e00\u4e2a\u53ef\u9009\u5bf9\u8c61\uff0c\u5176\u4e2d\u5305\u542b\u5448\u73b0\u9519\u8bef\u6d88\u606f\u6240\u9700\u7684\u503c\u3002 <p>\u4f5c\u4e3a\u793a\u8303\uff1a</p> <pre><code>from typing import List\nfrom pydantic import BaseModel, ValidationError, conint\n\n\nclass Location(BaseModel):\n    lat = 0.1\n    lng = 10.1\n\n\nclass Model(BaseModel):\n    is_required: float\n    gt_int: conint(gt=42)\n    list_of_ints: List[int] = None\n    a_float: float = None\n    recursive_model: Location = None\n\n\ndata = dict(\n    list_of_ints=['1', 2, 'bad'],\n    a_float='not a float',\n    recursive_model={'lat': 4.2, 'lng': 'New York'},\n    gt_int=21,\n)\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e.json())\n</code></pre>"},{"location":"usage/models/#custom-errors","title":"\u81ea\u5b9a\u4e49\u9519\u8bef(Custom Errors)","text":"<p>\u5728\u60a8\u7684\u81ea\u5b9a\u4e49\u6570\u636e\u7c7b\u578b\u6216\u9a8c\u8bc1\u5668\u4e2d\uff0c\u60a8\u5e94\u8be5\u4f7f\u7528 <code>ValueError</code>\u3001<code>TypeError</code> \u6216 <code>AssertionError</code> \u6765\u5f15\u53d1\u9519\u8bef\u3002</p> <p>\u6709\u5173\u4f7f\u7528 <code>@validator</code> \u88c5\u9970\u5668\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 \u6821\u9a8c\u5668\u3002</p> <pre><code>from pydantic import BaseModel, ValidationError, validator\n\n\nclass Model(BaseModel):\n    foo: str\n\n    @validator('foo')\n    def value_must_equal_bar(cls, v):\n        if v != 'bar':\n            raise ValueError('value must be \"bar\"')\n\n        return v\n\n\ntry:\n    Model(foo='ber')\nexcept ValidationError as e:\n    print(e.errors())\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u5b9a\u4e49\u81ea\u5df1\u7684\u9519\u8bef\u7c7b\uff0c\u5b83\u53ef\u4ee5\u81ea\u5b9a\u4e49\u9519\u8bef\u4ee3\u7801\u3001\u6d88\u606f\u6a21\u677f\u548c\u4e0a\u4e0b\u6587\uff1a</p> <pre><code>from pydantic import BaseModel, PydanticValueError, ValidationError, validator\n\n\nclass NotABarError(PydanticValueError):\n    code = 'not_a_bar'\n    msg_template = 'value is not \"bar\", got \"{wrong_value}\"'\n\n\nclass Model(BaseModel):\n    foo: str\n\n    @validator('foo')\n    def value_must_equal_bar(cls, v):\n        if v != 'bar':\n            raise NotABarError(wrong_value=v)\n        return v\n\n\ntry:\n    Model(foo='ber')\nexcept ValidationError as e:\n    print(e.json())\n</code></pre>"},{"location":"usage/models/#helper-functions","title":"\u8f85\u52a9\u51fd\u6570(Helper Functions)","text":"<p>Pydantic \u5728\u6a21\u578b\u4e0a\u63d0\u4f9b\u4e86\u4e09\u4e2a <code>classmethod</code> \u8f85\u52a9\u51fd\u6570\u6765\u89e3\u6790\u6570\u636e\uff1a</p> <ul> <li><code>parse_obj</code>: \u8fd9\u4e0e\u6a21\u578b\u7684 <code>__init__</code> \u65b9\u6cd5\u975e\u5e38\u76f8\u4f3c\uff0c\u9664\u4e86\u5b83\u91c7\u7528\u5b57\u5178\u800c\u4e0d\u662f\u5173\u952e\u5b57\u53c2\u6570\u3002 \u5982\u679c\u4f20\u9012\u7684\u5bf9\u8c61\u4e0d\u662f\u5b57\u5178\uff0c\u5219\u4f1a\u5f15\u53d1<code>ValidationError</code>\u3002</li> <li><code>parse_raw</code>: \u8fd9\u9700\u8981 str \u6216 bytes \u5e76\u5c06\u5176\u89e3\u6790\u4e3a json\uff0c\u7136\u540e\u5c06\u7ed3\u679c\u4f20\u9012\u7ed9 <code>parse_obj</code>\u3002\u901a\u8fc7\u9002\u5f53\u8bbe\u7f6e <code>content_type</code> \u53c2\u6570\u4e5f\u652f\u6301\u89e3\u6790 pickle \u6570\u636e\u3002</li> <li><code>parse_file</code>: \u8fd9\u9700\u8981\u4e00\u4e2a\u6587\u4ef6\u8def\u5f84\uff0c\u8bfb\u53d6\u6587\u4ef6\u5e76\u5c06\u5185\u5bb9\u4f20\u9012\u7ed9<code>parse_raw</code>\u3002 \u5982\u679c\u7701\u7565\u4e86 <code>content_type</code>\uff0c\u5219\u4ece\u6587\u4ef6\u7684\u6269\u5c55\u540d\u4e2d\u63a8\u65ad\u51fa\u6765\u3002</li> </ul> <pre><code>import pickle\nfrom datetime import datetime\nfrom pathlib import Path\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name = 'John Doe'\n    signup_ts: datetime = None\n\n\nm = User.parse_obj({'id': 123, 'name': 'James'})\nprint(m)\n\ntry:\n    User.parse_obj(['not', 'a', 'dict'])\nexcept ValidationError as e:\n    print(e)\n\n# assumes json as no content type passed\nm = User.parse_raw('{\"id\": 123, \"name\": \"James\"}')\nprint(m)\n\npickle_data = pickle.dumps({\n    'id': 123,\n    'name': 'James',\n    'signup_ts': datetime(2017, 7, 14)\n})\nm = User.parse_raw(\n    pickle_data, content_type='application/pickle', allow_pickle=True\n)\nprint(m)\n\npath = Path('data.json')\npath.write_text('{\"id\": 123, \"name\": \"James\"}')\nm = User.parse_file(path)\nprint(m)\n# ignore-below\nif path.exists():\n    path.unlink()\n</code></pre> <p>Warning</p> <p>\u5f15\u7528 \u5b98\u65b9 <code>pickle</code> \u6587\u6863\uff0c\u201cpickle \u6a21\u5757\u5bf9\u4e8e\u9519\u8bef\u6216\u6076\u610f\u6784\u9020\u7684\u6570\u636e\u4e0d\u5b89\u5168\u3002\u5207\u52ff\u53d6\u6d88\u63a5\u6536\u6765\u81ea\u4e0d\u53d7\u4fe1\u4efb\u6216\u672a\u7ecf\u8eab\u4efd\u9a8c\u8bc1\u7684\u6765\u6e90\u3002\u201d</p> <p>Info</p> <p>\u56e0\u4e3a\u5b83\u4f1a\u5bfc\u81f4\u4efb\u610f\u4ee3\u7801\u6267\u884c\uff0c\u4f5c\u4e3a\u5b89\u5168\u63aa\u65bd\uff0c\u60a8\u9700\u8981\u663e\u5f0f\u5730\u5c06 <code>allow_pickle</code> \u4f20\u9012\u7ed9\u89e3\u6790\u51fd\u6570\uff0c\u4ee5\u4fbf\u52a0\u8f7d <code>pickle</code> \u6570\u636e\u3002</p>"},{"location":"usage/models/#creating-models-without-validation","title":"\u521b\u5efa\u65e0\u9700\u6821\u9a8c\u7684\u6a21\u578b(Creating models without validation)","text":"<p>pydantic \u8fd8\u63d0\u4f9b\u4e86 <code>construct()</code> \u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u5141\u8bb8\u521b\u5efa\u6a21\u578b\u65e0\u9700\u9a8c\u8bc1\u5f53\u6570\u636e\u5df2\u7ecf\u8fc7\u9a8c\u8bc1\u6216\u6765\u81ea\u53d7\u4fe1\u4efb\u7684\u6765\u6e90\u5e76\u4e14\u60a8\u5e0c\u671b\u5c3d\u53ef\u80fd\u9ad8\u6548\u5730\u521b\u5efa\u6a21\u578b\u65f6\uff0c\u8fd9\u53ef\u80fd\u5f88\u6709\u7528 \u53ef\u80fd\uff08<code>construct()</code> \u901a\u5e38\u6bd4\u521b\u5efa\u5177\u6709\u5b8c\u6574\u9a8c\u8bc1\u7684\u6a21\u578b\u5feb 30 \u500d\u5de6\u53f3\uff09\u3002</p> <p>Warning</p> <p><code>construct()</code> \u4e0d\u505a\u4efb\u4f55\u9a8c\u8bc1\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u53ef\u4ee5\u521b\u5efa\u65e0\u6548\u7684\u6a21\u578b\u3002 \u60a8\u5e94\u8be5\u53ea\u5bf9\u5df2\u7ecf\u8fc7\u9a8c\u8bc1\u6216\u60a8\u4fe1\u4efb\u7684\u6570\u636e\u4f7f\u7528 <code>construct()</code> \u65b9\u6cd5\u3002</p> <pre><code>from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int\n    age: int\n    name: str = 'John Doe'\n\n\noriginal_user = User(id=123, age=32)\n\nuser_data = original_user.dict()\nprint(user_data)\nfields_set = original_user.__fields_set__\nprint(fields_set)\n\n# ...\n# pass user_data and fields_set to RPC or save to the database etc.\n# ...\n\n# you can then create a new instance of User without\n# re-running validation which would be unnecessary at this point:\nnew_user = User.construct(_fields_set=fields_set, **user_data)\nprint(repr(new_user))\nprint(new_user.__fields_set__)\n\n# construct can be dangerous, only use it with validated data!:\nbad_user = User.construct(id='dog')\nprint(repr(bad_user))\n</code></pre> <p><code>construct()</code> \u7684 <code>_fields_set</code> \u5173\u952e\u5b57\u53c2\u6570\u662f\u53ef\u9009\u7684\uff0c\u4f46\u53ef\u4ee5\u8ba9\u60a8\u66f4\u51c6\u786e\u5730\u4e86\u89e3\u54ea\u4e9b\u5b57\u6bb5\u662f\u6700\u521d\u8bbe\u7f6e\u7684\uff0c\u54ea\u4e9b\u4e0d\u662f\u3002 \u5982\u679c\u5b83\u88ab\u7701\u7565\uff0c<code>__fields_set__</code> \u5c06\u53ea\u662f\u6240\u63d0\u4f9b\u6570\u636e\u7684\u952e\u3002</p> <p>\u4f8b\u5982\uff0c\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u5982\u679c\u672a\u63d0\u4f9b <code>_fields_set</code>\uff0c\u5219<code>new_user.fields_set</code>\u5c06\u4e3a<code>{'id', 'age', 'name'}</code>\u3002</p>"},{"location":"usage/models/#generic-models","title":"\u901a\u7528\u6a21\u578b(Generic Models)","text":"<p>Pydantic \u652f\u6301\u521b\u5efa\u901a\u7528\u6a21\u578b\uff0c\u4ee5\u4fbf\u66f4\u8f7b\u677e\u5730\u91cd\u7528\u901a\u7528\u6a21\u578b\u7ed3\u6784\u3002</p> <p>\u4e3a\u4e86\u58f0\u660e\u901a\u7528\u6a21\u578b\uff0c\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ul> <li>\u58f0\u660e\u4e00\u4e2a\u6216\u591a\u4e2a <code>typing.TypeVar</code> \u5b9e\u4f8b\u4ee5\u7528\u4e8e\u53c2\u6570\u5316\u60a8\u7684\u6a21\u578b\u3002</li> <li>\u58f0\u660e\u4e00\u4e2a\u7ee7\u627f\u81ea <code>pydantic.generics.GenericModel</code> \u548c <code>typing.Generic</code> \u7684 pydantic \u6a21\u578b\uff0c\u5728\u5176\u4e2d\u5c06 <code>TypeVar</code> \u5b9e\u4f8b\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9 <code>typing.Generic</code>\u3002</li> <li>\u4f7f\u7528 <code>TypeVar</code> \u5b9e\u4f8b\u4f5c\u4e3a\u6ce8\u89e3\uff0c\u60a8\u53ef\u4ee5\u5728\u5176\u4e2d\u5c06\u5b83\u4eec\u66ff\u6362\u4e3a\u5176\u4ed6\u7c7b\u578b\u6216 pydantic \u6a21\u578b\u3002</li> </ul> <p>\u4e0b\u9762\u662f\u4e00\u4e2a\u4f7f\u7528 <code>GenericModel</code> \u521b\u5efa\u6613\u4e8e\u91cd\u7528\u7684 HTTP \u54cd\u5e94\u8d1f\u8f7d\u5305\u88c5\u5668\u7684\u793a\u4f8b\uff1a</p> <pre><code>from typing import Generic, TypeVar, Optional, List\n\nfrom pydantic import BaseModel, validator, ValidationError\nfrom pydantic.generics import GenericModel\n\nDataT = TypeVar('DataT')\n\n\nclass Error(BaseModel):\n    code: int\n    message: str\n\n\nclass DataModel(BaseModel):\n    numbers: List[int]\n    people: List[str]\n\n\nclass Response(GenericModel, Generic[DataT]):\n    data: Optional[DataT]\n    error: Optional[Error]\n\n    @validator('error', always=True)\n    def check_consistency(cls, v, values):\n        if v is not None and values['data'] is not None:\n            raise ValueError('must not provide both data and error')\n        if v is None and values.get('data') is None:\n            raise ValueError('must provide data or error')\n        return v\n\n\ndata = DataModel(numbers=[1, 2, 3], people=[])\nerror = Error(code=404, message='Not found')\n\nprint(Response[int](data=1))\nprint(Response[str](data='value'))\nprint(Response[str](data='value').dict())\nprint(Response[DataModel](data=data).dict())\nprint(Response[DataModel](error=error).dict())\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>\u5982\u679c\u60a8\u5728\u901a\u7528\u6a21\u578b\u5b9a\u4e49\u4e2d\u8bbe\u7f6e <code>Config</code> \u6216\u4f7f\u7528 <code>validator</code>\uff0c\u5b83\u5c06\u4ee5\u4e0e\u4ece <code>BaseModel</code> \u7ee7\u627f\u65f6\u76f8\u540c\u7684\u65b9\u5f0f\u5e94\u7528\u4e8e\u5177\u4f53\u5b50\u7c7b\u3002 \u5728\u6cdb\u578b\u7c7b\u4e0a\u5b9a\u4e49\u7684\u4efb\u4f55\u65b9\u6cd5\u4e5f\u5c06\u88ab\u7ee7\u627f\u3002</p> <p>Pydantic \u7684\u6cdb\u578b\u4e5f\u4e0e mypy \u6b63\u786e\u96c6\u6210\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u8981\u5728\u4e0d\u4f7f\u7528 <code>GenericModel</code> \u7684\u60c5\u51b5\u4e0b\u58f0\u660e\u7c7b\u578b\uff0c\u60a8\u5c06\u83b7\u5f97\u60a8\u5e0c\u671b mypy \u63d0\u4f9b\u7684\u6240\u6709\u7c7b\u578b\u68c0\u67e5\u3002</p> <p>Note</p> <p>\u5728\u5185\u90e8\uff0cpydantic \u4f7f\u7528 <code>create_model</code>\u5728\u8fd0\u884c\u65f6\u751f\u6210\uff08\u7f13\u5b58\u7684\uff09\u5177\u4f53 <code>BaseModel</code>\uff0c\u56e0\u6b64\u4f7f\u7528 <code>GenericModel</code> \u5f15\u5165\u7684\u5f00\u9500\u57fa\u672c\u4e0a\u4e3a\u96f6\u3002</p> <p>\u8981\u4ece <code>GenericModel</code> \u7ee7\u627f\u800c\u4e0d\u66ff\u6362 <code>TypeVar</code> \u5b9e\u4f8b\uff0c\u7c7b\u8fd8\u5fc5\u987b\u4ece <code>typing.Generic</code> \u7ee7\u627f\uff1a</p> <pre><code>from typing import TypeVar, Generic\nfrom pydantic.generics import GenericModel\n\nTypeX = TypeVar('TypeX')\n\n\nclass BaseClass(GenericModel, Generic[TypeX]):\n    X: TypeX\n\n\nclass ChildClass(BaseClass[TypeX], Generic[TypeX]):\n    # Inherit from Generic[TypeX]\n    pass\n\n\n# Replace TypeX by int\nprint(ChildClass[int](X=1))\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u521b\u5efa <code>GenericModel</code> \u7684\u901a\u7528\u5b50\u7c7b\uff0c\u90e8\u5206\u6216\u5b8c\u5168\u66ff\u6362\u8d85\u7c7b\u4e2d\u7684\u7c7b\u578b\u53c2\u6570\u3002</p> <pre><code>from typing import TypeVar, Generic\nfrom pydantic.generics import GenericModel\n\nTypeX = TypeVar('TypeX')\nTypeY = TypeVar('TypeY')\nTypeZ = TypeVar('TypeZ')\n\n\nclass BaseClass(GenericModel, Generic[TypeX, TypeY]):\n    x: TypeX\n    y: TypeY\n\n\nclass ChildClass(BaseClass[int, TypeY], Generic[TypeY, TypeZ]):\n    z: TypeZ\n\n\n# Replace TypeY by str\nprint(ChildClass[str, int](x=1, y='y', z=3))\n</code></pre> <p>\u5982\u679c\u5177\u4f53\u5b50\u7c7b\u7684\u540d\u79f0\u5f88\u91cd\u8981\uff0c\u60a8\u8fd8\u53ef\u4ee5\u8986\u76d6\u9ed8\u8ba4\u884c\u4e3a\uff1a</p> <pre><code>from typing import Generic, TypeVar, Type, Any, Tuple\n\nfrom pydantic.generics import GenericModel\n\nDataT = TypeVar('DataT')\n\n\nclass Response(GenericModel, Generic[DataT]):\n    data: DataT\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...]) -&gt; str:\n        return f'{params[0].__name__.title()}Response'\n\n\nprint(repr(Response[int](data=1)))\nprint(repr(Response[str](data='a')))\n</code></pre> <p>\u5728\u5d4c\u5957\u6a21\u578b\u4e2d\u4f7f\u7528\u76f8\u540c\u7684 <code>TypeVar</code> \u5141\u8bb8\u60a8\u5728\u6a21\u578b\u7684\u4e0d\u540c\u70b9\u5f3a\u5236\u6267\u884c\u7c7b\u578b\u5173\u7cfb\uff1a</p> <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import ValidationError\nfrom pydantic.generics import GenericModel\n\nT = TypeVar('T')\n\n\nclass InnerT(GenericModel, Generic[T]):\n    inner: T\n\n\nclass OuterT(GenericModel, Generic[T]):\n    outer: T\n    nested: InnerT[T]\n\n\nnested = InnerT[int](inner=1)\nprint(OuterT[int](outer=1, nested=nested))\ntry:\n    nested = InnerT[str](inner='a')\n    print(OuterT[int](outer='a', nested=nested))\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>Pydantic \u8fd8\u50cf\u5904\u7406 <code>List</code> \u548c <code>Dict</code> \u7b49\u5185\u7f6e\u6cdb\u578b\u7c7b\u578b\u4e00\u6837\u5904\u7406 <code>GenericModel</code>\uff0c\u4ee5\u4f7f\u5176\u4fdd\u6301\u672a\u53c2\u6570\u5316\u6216\u4f7f\u7528\u6709\u754c <code>TypeVar</code> \u5b9e\u4f8b\uff1a</p> <ul> <li>\u5982\u679c\u60a8\u5728\u5b9e\u4f8b\u5316\u901a\u7528\u6a21\u578b\u4e4b\u524d\u6ca1\u6709\u6307\u5b9a\u53c2\u6570\uff0c\u5b83\u4eec\u5c06\u88ab\u89c6\u4e3a<code>Any</code></li> <li>\u60a8\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u6216\u591a\u4e2abounded(\u6709\u754c)\u53c2\u6570\u5bf9\u6a21\u578b\u8fdb\u884c\u53c2\u6570\u5316\u4ee5\u6dfb\u52a0\u5b50\u7c7b\u68c0\u67e5</li> </ul> <p>\u6b64\u5916\uff0c\u4e0e <code>List</code> \u548c <code>Dict</code> \u4e00\u6837\uff0c\u4f7f\u7528 <code>TypeVar</code> \u6307\u5b9a\u7684\u4efb\u4f55\u53c2\u6570\u7a0d\u540e\u90fd\u53ef\u4ee5\u66ff\u6362\u4e3a\u5177\u4f53\u7c7b\u578b\u3002</p> <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import ValidationError\nfrom pydantic.generics import GenericModel\n\nAT = TypeVar('AT')\nBT = TypeVar('BT')\n\n\nclass Model(GenericModel, Generic[AT, BT]):\n    a: AT\n    b: BT\n\n\nprint(Model(a='a', b='a'))\n\nIntT = TypeVar('IntT', bound=int)\ntypevar_model = Model[int, IntT]\nprint(typevar_model(a=1, b=1))\ntry:\n    typevar_model(a='a', b='a')\nexcept ValidationError as exc:\n    print(exc)\n\nconcrete_model = typevar_model[int]\nprint(concrete_model(a=1, b=1))\n</code></pre>"},{"location":"usage/models/#dynamic-model-creation","title":"\u52a8\u6001\u6a21\u578b\u7684\u521b\u5efa(Dynamic model creation)","text":"<p>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u76f4\u5230\u8fd0\u884c\u65f6\u624d\u77e5\u9053\u6a21\u578b\u7684\u5f62\u6001(shape)\u3002 \u4e3a\u6b64 pydantic \u63d0\u4f9b\u4e86 <code>create_model</code> \u65b9\u6cd5\u6765\u5141\u8bb8\u52a8\u6001\u521b\u5efa\u6a21\u578b\u3002</p> <pre><code>from pydantic import BaseModel, create_model\n\nDynamicFoobarModel = create_model('DynamicFoobarModel', foo=(str, ...), bar=123)\n\n\nclass StaticFoobarModel(BaseModel):\n    foo: str\n    bar: int = 123\n</code></pre> <p>\u8fd9\u91cc\u7684 <code>StaticFoobarModel</code> \u548c <code>DynamicFoobarModel</code> \u662f\u76f8\u540c\u7684\u3002</p> <p>Warning</p> <p>\u8bf7\u53c2\u9605 \u5fc5\u987b\u7684\u53ef\u9009\u53c2\u6570 \u4e2d\u7684\u6ce8\u91ca\uff0c\u4ee5\u4e86\u89e3\u7701\u7565\u53f7\u4f5c\u4e3a\u5b57\u6bb5\u9ed8\u8ba4\u503c\u548c\u4ec5\u6ce8\u91ca\u5b57\u6bb5\u4e4b\u95f4\u7684\u533a\u522b\u3002 \u53c2\u89c1 pydantic/pydantic#1047 \u83b7\u53d6\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\u3002</p> <p>\u5b57\u6bb5\u7531 <code>(&lt;type&gt;, &lt;default value&gt;)</code> \u5f62\u5f0f\u7684\u5143\u7ec4\u6216\u4ec5\u7531\u9ed8\u8ba4\u503c\u5b9a\u4e49\u3002 \u7279\u6b8a\u5173\u952e\u5b57\u53c2\u6570 <code>__config__</code> \u548c <code>__base__</code> \u53ef\u7528\u4e8e\u81ea\u5b9a\u4e49\u65b0\u6a21\u578b\u3002 \u8fd9\u5305\u62ec\u4f7f\u7528\u989d\u5916\u5b57\u6bb5\u6269\u5c55\u57fa\u672c\u6a21\u578b\u3002</p> <pre><code>from pydantic import BaseModel, create_model\n\n\nclass FooModel(BaseModel):\n    foo: str\n    bar: int = 123\n\n\nBarModel = create_model(\n    'BarModel',\n    apple='russet',\n    banana='yellow',\n    __base__=FooModel,\n)\nprint(BarModel)\nprint(BarModel.__fields__.keys())\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u901a\u8fc7\u5c06\u5b57\u5178\u4f20\u9012\u7ed9 <code>__validators__</code> \u53c2\u6570\u6765\u6dfb\u52a0\u9a8c\u8bc1\u5668\u3002</p> <pre><code>from pydantic import create_model, ValidationError, validator\n\n\ndef username_alphanumeric(cls, v):\n    assert v.isalnum(), 'must be alphanumeric'\n    return v\n\n\nvalidators = {\n    'username_validator':\n    validator('username')(username_alphanumeric)\n}\n\nUserModel = create_model(\n    'UserModel',\n    username=(str, ...),\n    __validators__=validators\n)\n\nuser = UserModel(username='scolvin')\nprint(user)\n\ntry:\n    UserModel(username='scolvi%n')\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/models/#namedtupletypeddictmodel-creation-from-namedtuple-or-typeddict","title":"\u4ece<code>NamedTuple</code>\u6216<code>TypedDict</code>\u521b\u5efa\u6a21\u578b(Model creation from <code>NamedTuple</code> or <code>TypedDict</code>)","text":"<p>\u6709\u65f6\uff0c\u60a8\u5df2\u7ecf\u5728\u5e94\u7528\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u4e86\u7ee7\u627f\u81ea <code>NamedTuple</code> \u6216 <code>TypedDict</code> \u7684\u7c7b\uff0c\u5e76\u4e14\u60a8\u4e0d\u60f3\u590d\u5236\u6240\u6709\u4fe1\u606f\u4ee5\u62e5\u6709 <code>BaseModel</code>\u3002 \u4e3a\u6b64pydantic \u63d0\u4f9b\u4e86<code>create_model_from_namedtuple</code> \u548c<code>create_model_from_typeddict</code> \u65b9\u6cd5\u3002 \u8fd9\u4e9b\u65b9\u6cd5\u5177\u6709\u4e0e <code>create_model</code> \u5b8c\u5168\u76f8\u540c\u7684\u5173\u952e\u5b57\u53c2\u6570\u3002</p> <pre><code>from typing_extensions import TypedDict\n\nfrom pydantic import ValidationError, create_model_from_typeddict\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nclass Config:\n    extra = 'forbid'\n\n\nUserM = create_model_from_typeddict(User, __config__=Config)\nprint(repr(UserM(name=123, id='3')))\n\ntry:\n    UserM(name=123, id='3', other='no')\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/models/#custom-root-types","title":"\u81ea\u5b9a\u4e49\u6839\u7c7b\u578b(Custom Root Types)","text":"<p>Pydantic \u6a21\u578b\u53ef\u4ee5\u901a\u8fc7\u58f0\u660e <code>__root__</code> \u5b57\u6bb5\u6765\u5b9a\u4e49\u81ea\u5b9a\u4e49\u6839\u7c7b\u578b\u3002</p> <p>\u6839\u7c7b\u578b\u53ef\u4ee5\u662f pydantic \u652f\u6301\u7684\u4efb\u4f55\u7c7b\u578b\uff0c\u5e76\u7531 <code>__root__</code> \u5b57\u6bb5\u4e0a\u7684\u7c7b\u578b\u63d0\u793a\u6307\u5b9a\u3002 \u6839\u503c\u53ef\u4ee5\u901a\u8fc7 <code>__root__</code> \u5173\u952e\u5b57\u53c2\u6570\u4f20\u9012\u7ed9\u6a21\u578b <code>__init__</code> \uff0c\u6216\u8005\u4f5c\u4e3a <code>parse_obj</code> \u7684\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u4e00\u4e2a\u53c2\u6570\u3002</p> <pre><code>from typing import List\nimport json\nfrom pydantic import BaseModel\nfrom pydantic.schema import schema\n\n\nclass Pets(BaseModel):\n    __root__: List[str]\n\n\nprint(Pets(__root__=['dog', 'cat']))\nprint(Pets(__root__=['dog', 'cat']).json())\nprint(Pets.parse_obj(['dog', 'cat']))\nprint(Pets.schema())\npets_schema = schema([Pets])\nprint(json.dumps(pets_schema, indent=2))\n</code></pre> <p>\u5982\u679c\u60a8\u4e3a\u5177\u6709\u81ea\u5b9a\u4e49\u6839\u7c7b\u578b\u7684\u6a21\u578b\u8c03\u7528 <code>parse_obj</code> \u65b9\u6cd5\uff0c\u5e76\u5c06 dict \u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u53c2\u6570\uff0c\u5219\u4f7f\u7528\u4ee5\u4e0b\u903b\u8f91\uff1a</p> <ul> <li>\u5982\u679c\u81ea\u5b9a\u4e49\u6839\u7c7b\u578b\u662f\u6620\u5c04\u7c7b\u578b\uff08\u4f8b\u5982\uff0c<code>Dict</code> \u6216 <code>Mapping</code>\uff09\uff0c\u53c2\u6570\u672c\u8eab\u603b\u662f\u6839\u636e\u81ea\u5b9a\u4e49\u6839\u7c7b\u578b\u8fdb\u884c\u9a8c\u8bc1\u3002</li> <li>\u5bf9\u4e8e\u5176\u4ed6\u81ea\u5b9a\u4e49\u6839\u7c7b\u578b\uff0c\u5982\u679c\u5b57\u5178\u6070\u597d\u6709\u4e00\u4e2a\u503c\u4e3a <code>__root__</code> \u7684\u952e\uff0c\u5219\u5c06\u6839\u636e\u81ea\u5b9a\u4e49\u6839\u7c7b\u578b\u9a8c\u8bc1\u76f8\u5e94\u7684\u503c\u3002</li> <li>\u5426\u5219\uff0c\u5c06\u6839\u636e\u81ea\u5b9a\u4e49\u6839\u7c7b\u578b\u9a8c\u8bc1\u5b57\u5178\u672c\u8eab\u3002</li> </ul> <p>\u8fd9\u5728\u4ee5\u4e0b\u793a\u4f8b\u4e2d\u5f97\u5230\u4e86\u8bc1\u660e\uff1a</p> <pre><code>from typing import List, Dict\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Pets(BaseModel):\n    __root__: List[str]\n\n\nprint(Pets.parse_obj(['dog', 'cat']))\nprint(Pets.parse_obj({'__root__': ['dog', 'cat']}))  # not recommended\n\n\nclass PetsByName(BaseModel):\n    __root__: Dict[str, str]\n\n\nprint(PetsByName.parse_obj({'Otis': 'dog', 'Milo': 'cat'}))\ntry:\n    PetsByName.parse_obj({'__root__': {'Otis': 'dog', 'Milo': 'cat'}})\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>Warning</p> <p>\u4e3a\u4e86\u5411\u540e\u517c\u5bb9\uff0c\u76ee\u524d\u652f\u6301\u4f7f\u7528\u5355\u952e <code>\"__root__\"</code> \u5728 dict \u4e0a\u8c03\u7528 <code>parse_obj</code> \u65b9\u6cd5\u4ee5\u5b9e\u73b0\u5411\u540e\u517c\u5bb9\u6027\uff0c\u4f46\u4e0d\u63a8\u8350\u5e76\u4e14\u53ef\u80fd\u5728\u672a\u6765\u7248\u672c\u4e2d\u5220\u9664\u3002</p> <p>\u5982\u679c\u60a8\u60f3\u76f4\u63a5\u8bbf\u95ee <code>__root__</code> \u5b57\u6bb5\u4e2d\u7684\u9879\u76ee\u6216\u8fed\u4ee3\u8fd9\u4e9b\u9879\u76ee\uff0c\u60a8\u53ef\u4ee5\u5b9e\u73b0\u81ea\u5b9a\u4e49 <code>__iter__</code> \u548c <code>__getitem__</code> \u51fd\u6570\uff0c\u5982\u4ee5\u4e0b\u793a\u4f8b\u6240\u793a\u3002</p> <pre><code>from typing import List\nfrom pydantic import BaseModel\n\n\nclass Pets(BaseModel):\n    __root__: List[str]\n\n    def __iter__(self):\n        return iter(self.__root__)\n\n    def __getitem__(self, item):\n        return self.__root__[item]\n\n\npets = Pets.parse_obj(['dog', 'cat'])\nprint(pets[0])\nprint([pet for pet in pets])\n</code></pre>"},{"location":"usage/models/#faux-immutability","title":"\u4f2a\u4e0d\u53d8\u6027(Faux Immutability)","text":"<p>\u53ef\u4ee5\u901a\u8fc7 <code>allow_mutation = False</code> \u5c06\u6a21\u578b\u914d\u7f6e\u4e3a\u4e0d\u53ef\u53d8\u7684\u3002 \u8bbe\u7f6e\u540e\uff0c\u5c1d\u8bd5\u66f4\u6539\u5b9e\u4f8b\u5c5e\u6027\u7684\u503c\u5c06\u5f15\u53d1\u9519\u8bef\u3002 \u6709\u5173 <code>Config</code> \u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 \u6a21\u578b\u914d\u7f6e\u3002</p> <p>Warning</p> <p>Python \u4e2d\u7684\u4e0d\u53d8\u6027\u4ece\u6765\u90fd\u4e0d\u662f\u4e25\u683c\u7684\u3002 \u5982\u679c\u5f00\u53d1\u4eba\u5458\u6709\u51b3\u5fc3/\u611a\u8822\uff0c\u4ed6\u4eec\u603b\u662f\u53ef\u4ee5\u4fee\u6539\u6240\u8c13\u7684\u201c\u4e0d\u53ef\u53d8\u201d\u5bf9\u8c61\u3002</p> <pre><code>from pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel):\n    a: str\n    b: dict\n\n    class Config:\n        allow_mutation = False\n\n\nfoobar = FooBarModel(a='hello', b={'apple': 'pear'})\n\ntry:\n    foobar.a = 'different'\nexcept TypeError as e:\n    print(e)\n\nprint(foobar.a)\nprint(foobar.b)\nfoobar.b['apple'] = 'grape'\nprint(foobar.b)\n</code></pre> <p>\u5c1d\u8bd5\u66f4\u6539 <code>a</code> \u5bfc\u81f4\u9519\u8bef\uff0c\u800c <code>a</code> \u4fdd\u6301\u4e0d\u53d8\u3002 \u7136\u800c\uff0cdict <code>b</code> \u662f\u53ef\u53d8\u7684\uff0c\u800c <code>foobar</code> \u7684\u4e0d\u53d8\u6027\u5e76\u4e0d\u80fd\u963b\u6b62 <code>b</code> \u88ab\u6539\u53d8\u3002</p>"},{"location":"usage/models/#abstract-base-classes","title":"\u62bd\u8c61\u57fa\u7c7b(Abstract Base Classes)","text":"<p>Pydantic \u6a21\u578b\u53ef\u4ee5\u4e0e Python \u7684\u62bd\u8c61\u57fa\u7c7b (ABC) \u4e00\u8d77\u4f7f\u7528\u3002</p> <pre><code>import abc\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel, abc.ABC):\n    a: str\n    b: int\n\n    @abc.abstractmethod\n    def my_abstract_method(self):\n        pass\n</code></pre>"},{"location":"usage/models/#field-ordering","title":"\u5b57\u6bb5\u987a\u5e8f(Field Ordering)","text":"<p>\u5b57\u6bb5\u987a\u5e8f\u5728\u6a21\u578b\u4e2d\u5f88\u91cd\u8981\uff0c\u539f\u56e0\u5982\u4e0b\uff1a</p> <ul> <li>\u5728\u5b9a\u4e49\u7684\u8ba2\u5355\u5b57\u6bb5\u4e2d\u6267\u884c\u9a8c\u8bc1\uff1b fields validators \u53ef\u4ee5\u8bbf\u95ee\u524d\u9762\u5b57\u6bb5\u7684\u503c\uff0c\u4f46\u4e0d\u80fd\u8bbf\u95ee\u540e\u9762\u7684\u5b57\u6bb5</li> <li>\u5b57\u6bb5\u987a\u5e8f\u4fdd\u7559\u5728\u6a21\u578b schema \u4e2d</li> <li>\u5b57\u6bb5\u987a\u5e8f\u4fdd\u7559\u5728 validation errors</li> <li>\u5b57\u6bb5\u987a\u5e8f\u7531 <code>.dict()</code> \u548c <code>.json()</code>\u7b49\u4fdd\u5b58</li> </ul> <p>\u4ece v1.0 \u5f00\u59cb\uff0c\u6240\u6709\u5e26\u6709\u6ce8\u89e3\u7684\u5b57\u6bb5\uff08\u65e0\u8bba\u662f\u4ec5\u6ce8\u89e3\u8fd8\u662f\u5e26\u6709\u9ed8\u8ba4\u503c\uff09\u90fd\u5c06\u4f4d\u4e8e\u6240\u6709\u6ca1\u6709\u6ce8\u89e3\u7684\u5b57\u6bb5\u4e4b\u524d\u3002 \u5728\u5404\u81ea\u7684\u7ec4\u4e2d\uff0c\u5b57\u6bb5\u4fdd\u6301\u5176\u5b9a\u4e49\u7684\u987a\u5e8f\u3002</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b = 2\n    c: int = 1\n    d = 0\n    e: float\n\n\nprint(Model.__fields__.keys())\nm = Model(e=2, a=1)\nprint(m.dict())\ntry:\n    Model(a='x', b='x', c='x', d='x', e='x')\nexcept ValidationError as e:\n    error_locations = [e['loc'] for e in e.errors()]\n\nprint(error_locations)\n</code></pre> <p>Warning</p> <p>\u5982\u4e0a\u9762\u7684\u793a\u4f8b\u6240\u793a\uff0c\u5728\u540c\u4e00\u6a21\u578b\u4e2d\u7ed3\u5408\u4f7f\u7528\u5e26\u6ce8\u91ca\u548c\u975e\u5e26\u6ce8\u91ca\u7684\u5b57\u6bb5\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4ee4\u4eba\u60ca\u8bb6\u7684\u5b57\u6bb5\u6392\u5e8f\u3002 \uff08\u8fd9\u662f\u7531\u4e8e Python \u7684\u9650\u5236\uff09</p> <p>\u56e0\u6b64\uff0c\u6211\u4eec\u5efa\u8bae\u5411\u6240\u6709\u5b57\u6bb5\u6dfb\u52a0\u7c7b\u578b\u6ce8\u91ca\uff0c\u5373\u4f7f\u9ed8\u8ba4\u503c\u4f1a\u81ea\u884c\u786e\u5b9a\u7c7b\u578b\u4ee5\u4fdd\u8bc1\u4fdd\u7559\u5b57\u6bb5\u987a\u5e8f\u3002</p>"},{"location":"usage/models/#required-fields","title":"\u5fc5\u987b\u5b57\u6bb5(Required fields)","text":"<p>\u8981\u6839\u636e\u9700\u8981\u58f0\u660e\u4e00\u4e2a\u5b57\u6bb5\uff0c\u60a8\u53ef\u4ee5\u4ec5\u4f7f\u7528\u6ce8\u89e3\u6765\u58f0\u660e\u5b83\uff0c\u6216\u8005\u60a8\u53ef\u4ee5\u4f7f\u7528\u7701\u7565\u53f7\uff08<code>...</code>\uff09\u4f5c\u4e3a\u503c\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    a: int\n    b: int = ...\n    c: int = Field(...)\n</code></pre> <p>\u5176\u4e2d <code>Field</code> \u6307\u7684\u662f \u5b57\u6bb5\u51fd\u6570\u3002</p> <p>\u8fd9\u91cc <code>a</code>\u3001<code>b</code> \u548c <code>c</code> \u90fd\u662f\u5fc5\u9700\u7684\u3002 \u4f46\u662f\uff0c\u5728 <code>b</code> \u4e2d\u4f7f\u7528\u7701\u7565\u53f7\u4e0d\u9002\u7528\u4e8e mypy\uff0c\u4ece v1.0 \u5f00\u59cb\uff0c\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u5e94\u907f\u514d\u4f7f\u7528\u3002</p>"},{"location":"usage/models/#required-optional-fields","title":"\u5fc5\u987b\u4f46\u53ef\u9009\u5b57\u6bb5(Required Optional fields)","text":"<p>Warning</p> <p>\u7531\u4e8e\u7248\u672c v1.2 \u6ce8\u89e3\u4ec5\u53ef\u4e3a\u7a7a\uff08<code>Optional[...]</code>\u3001<code>Union[None, ...]</code> \u548c<code>Any</code>\uff09\u5b57\u6bb5\u548c\u5e26\u6709\u7701\u7565\u53f7\uff08<code>...</code>\uff09\u7684\u53ef\u4e3a\u7a7a\u5b57\u6bb5\uff09\u4f5c\u4e3a\u9ed8\u8ba4\u503c\uff0c\u4e0d\u518d\u610f\u5473\u7740\u540c\u4e00\u4ef6\u4e8b\u3002</p> <p>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4 v1.2 \u65e0\u6cd5\u5b8c\u5168\u5411\u540e\u517c\u5bb9\u65e9\u671f\u7684 v1.* \u7248\u672c\u3002</p> <p>\u5982\u679c\u4f60\u60f3\u6307\u5b9a\u4e00\u4e2a\u5b57\u6bb5\uff0c\u8be5\u5b57\u6bb5\u5728\u4ecd\u7136\u9700\u8981\u65f6\u53ef\u4ee5\u91c7\u7528\u201c\u65e0\u201d\u503c\uff0c\u5219\u53ef\u4ee5\u5c06\u201c\u53ef\u9009\u201d\u4e0e\u201c...\u201d\u4e00\u8d77\u4f7f\u7528\uff1a</p> <pre><code>from typing import Optional\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    a: Optional[int]\n    b: Optional[int] = ...\n    c: Optional[int] = Field(...)\n\n\nprint(Model(b=1, c=2))\ntry:\n    Model(a=1, b=2)\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>\u5728\u8fd9\u4e2a\u6a21\u578b\u4e2d\uff0c<code>a</code>\u3001<code>b</code> \u548c <code>c</code> \u53ef\u4ee5\u53d6 <code>None</code> \u4f5c\u4e3a\u503c\u3002 \u4f46\u662f <code>a</code> \u662f\u53ef\u9009\u7684\uff0c\u800c <code>b</code> \u548c <code>c</code> \u662f\u5fc5\u9700\u7684\u3002 <code>b</code> \u548c <code>c</code> \u9700\u8981\u4e00\u4e2a\u503c\uff0c\u5373\u4f7f\u8be5\u503c\u4e3a <code>None</code>\u3002</p>"},{"location":"usage/models/#field-with-dynamic-default-value","title":"\u5177\u6709\u52a8\u6001\u9ed8\u8ba4\u503c\u7684\u5b57\u6bb5(Field with dynamic default value)","text":"<p>\u5f53\u7528\u9ed8\u8ba4\u503c\u58f0\u660e\u4e00\u4e2a\u5b57\u6bb5\u65f6\uff0c\u60a8\u53ef\u80fd\u5e0c\u671b\u5b83\u662f\u52a8\u6001\u7684\uff08\u5373\u6bcf\u4e2a\u6a21\u578b\u4e0d\u540c\uff09\u3002 \u4e3a\u6b64\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f7f\u7528<code>default_factory</code>\u3002</p> <p>\u6d4b\u8bd5\u7248</p> <p><code>default_factory</code> \u53c2\u6570\u5728 beta \u4e2d\uff0c\u5b83\u5df2\u5728 \u4e34\u65f6\u57fa\u7840 \u4e2d\u6dfb\u52a0\u5230 v1.5 \u4e2d\u7684 pydantic\u3002 \u5b83\u53ef\u80fd\u4f1a\u5728\u672a\u6765\u7684\u7248\u672c\u4e2d\u53d1\u751f\u91cd\u5927\u53d8\u5316\uff0c\u5e76\u4e14\u5176\u7b7e\u540d\u6216\u884c\u4e3a\u5728 v2 \u4e4b\u524d\u4e0d\u4f1a\u5177\u4f53\u3002 \u6765\u81ea\u793e\u533a\u7684\u53cd\u9988\u5728\u5b83\u4ecd\u7136\u662f\u4e34\u65f6\u7684\u65f6\u5019\u5c06\u975e\u5e38\u6709\u7528\uff1b \u8bc4\u8bba #866 \u6216\u521b\u5efa\u4e00\u4e2a\u65b0\u95ee\u9898\u3002</p> <p>\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code>from datetime import datetime\nfrom uuid import UUID, uuid4\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    uid: UUID = Field(default_factory=uuid4)\n    updated: datetime = Field(default_factory=datetime.utcnow)\n\n\nm1 = Model()\nm2 = Model()\nprint(f'{m1.uid} != {m2.uid}')\nprint(f'{m1.updated} != {m2.updated}')\n</code></pre> <p>\u5176\u4e2d <code>Field</code> \u6307\u7684\u662f \u5b57\u6bb5\u51fd\u6570\u3002</p> <p>Warning</p> <p><code>default_factory</code> \u9700\u8981\u8bbe\u7f6e\u5b57\u6bb5\u7c7b\u578b\u3002</p>"},{"location":"usage/models/#automatically-excluded-attributes","title":"\u81ea\u52a8\u6392\u9664\u7684\u5c5e\u6027(Automatically excluded attributes)","text":"<p>\u4ee5\u4e0b\u5212\u7ebf\u5f00\u5934\u7684\u7c7b\u53d8\u91cf\u548c\u7528 <code>typing.ClassVar</code> \u6ce8\u91ca\u7684\u5c5e\u6027\u5c06\u81ea\u52a8\u4ece\u6a21\u578b\u4e2d\u6392\u9664\u3002</p>"},{"location":"usage/models/#private-model-attributes","title":"\u79c1\u6709\u6a21\u578b\u5c5e\u6027(Private model attributes)","text":"<p>\u5982\u679c\u60a8\u9700\u8981\u6539\u53d8\u6216\u64cd\u4f5c\u6a21\u578b\u5b9e\u4f8b\u7684\u5185\u90e8\u5c5e\u6027\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>PrivateAttr</code> \u58f0\u660e\u5b83\u4eec\uff1a</p> <pre><code>from datetime import datetime\nfrom random import randint\n\nfrom pydantic import BaseModel, PrivateAttr\n\n\nclass TimeAwareModel(BaseModel):\n    _processed_at: datetime = PrivateAttr(default_factory=datetime.now)\n    _secret_value: str = PrivateAttr()\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        # this could also be done with default_factory\n        self._secret_value = randint(1, 5)\n\n\nm = TimeAwareModel()\nprint(m._processed_at)\nprint(m._secret_value)\n</code></pre> <p>\u79c1\u6709\u5c5e\u6027\u540d\u79f0\u5fc5\u987b\u4ee5\u4e0b\u5212\u7ebf\u5f00\u5934\uff0c\u4ee5\u9632\u6b62\u4e0e\u6a21\u578b\u5b57\u6bb5\u51b2\u7a81\uff1a\u652f\u6301 <code>_attr</code> \u548c <code>__attr__</code> \u3002</p> <p>\u5982\u679c <code>Config.underscore_attrs_are_private</code> \u4e3a <code>True</code>\uff0c\u4efb\u4f55\u975e ClassVar \u4e0b\u5212\u7ebf\u5c5e\u6027\u90fd\u5c06\u88ab\u89c6\u4e3a\u79c1\u6709\uff1a</p> <pre><code>from typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    _class_var: ClassVar[str] = 'class var value'\n    _private_attr: str = 'private attr value'\n\n    class Config:\n        underscore_attrs_are_private = True\n\n\nprint(Model._class_var)\nprint(Model._private_attr)\nprint(Model()._private_attr)\n</code></pre> <p>\u5728\u521b\u5efa\u7c7b\u65f6\uff0cpydantic \u6784\u9020\u4e86\u586b\u5145\u79c1\u6709\u5c5e\u6027\u7684 <code>__slots__</code> \u3002</p>"},{"location":"usage/models/#parsing-data-into-a-specified-type","title":"\u5c06\u6570\u636e\u89e3\u6790\u4e3a\u6307\u5b9a\u7c7b\u578b(Parsing data into a specified type)","text":"<p>Pydantic \u5305\u62ec\u4e00\u4e2a\u72ec\u7acb\u7684\u5b9e\u7528\u51fd\u6570 <code>parse_obj_as</code> \uff0c\u53ef\u7528\u4e8e\u5e94\u7528\u7528\u4e8e\u4ee5\u66f4\u7279\u6b8a\u7684\u65b9\u5f0f\u586b\u5145 pydantic \u6a21\u578b\u7684\u89e3\u6790\u903b\u8f91\u3002 \u6b64\u51fd\u6570\u7684\u884c\u4e3a\u7c7b\u4f3c\u4e8e <code>BaseModel.parse_obj</code> \uff0c\u4f46\u9002\u7528\u4e8e\u4efb\u610f\u4e0e pydantic \u517c\u5bb9\u7684\u7c7b\u578b\u3002</p> <p>\u5f53\u60a8\u60f3\u8981\u5c06\u7ed3\u679c\u89e3\u6790\u4e3a\u4e0d\u662f <code>BaseModel</code> \u7684\u76f4\u63a5\u5b50\u7c7b\u7684\u7c7b\u578b\u65f6\uff0c\u8fd9\u5c24\u5176\u6709\u7528\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>from typing import List\n\nfrom pydantic import BaseModel, parse_obj_as\n\n\nclass Item(BaseModel):\n    id: int\n    name: str\n\n\n# `item_data` could come from an API call, eg., via something like:\n# item_data = requests.get('https://my-api.com/items').json()\nitem_data = [{'id': 1, 'name': 'My Item'}]\n\nitems = parse_obj_as(List[Item], item_data)\nprint(items)\n</code></pre> <p>\u6b64\u51fd\u6570\u80fd\u591f\u5c06\u6570\u636e\u89e3\u6790\u4e3a pydantic \u53ef\u4ee5\u4f5c\u4e3a <code>BaseModel</code> \u5b57\u6bb5\u5904\u7406\u7684\u4efb\u4f55\u7c7b\u578b\u3002</p> <p>Pydantic \u8fd8\u5305\u62ec\u4e24\u4e2a\u7c7b\u4f3c\u7684\u72ec\u7acb\u51fd\u6570\uff0c\u79f0\u4e3a <code>parse_file_as</code> \u548c <code>parse_raw_as</code>\uff0c\u5b83\u4eec\u7c7b\u4f3c\u4e8e <code>BaseModel.parse_file</code> \u548c<code>BaseModel.parse_raw</code>\u3002</p>"},{"location":"usage/models/#data-conversion","title":"\u6570\u636e\u8f6c\u6362(Data Conversion)","text":"<p>pydantic \u53ef\u80fd\u4f1a\u8f6c\u6362\u8f93\u5165\u6570\u636e\u4ee5\u5f3a\u5236\u5176\u7b26\u5408\u6a21\u578b\u5b57\u6bb5\u7c7b\u578b\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4fe1\u606f\u4e22\u5931\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n    b: float\n    c: str\n\n\nprint(Model(a=3.1415, b=' 2.72 ', c=123).dict())\n</code></pre> <p>\u8fd9\u662f pydantic \u6df1\u601d\u719f\u8651\u7684\u51b3\u5b9a\uff0c\u901a\u5e38\u8fd9\u662f\u6700\u6709\u7528\u7684\u65b9\u6cd5\u3002 \u8bf7\u53c2\u9605\u6b64\u5904\uff0c\u4e86\u89e3\u6709\u5173\u8be5\u4e3b\u9898\u7684\u66f4\u957f\u65f6\u95f4\u8ba8\u8bba\u3002</p> <p>\u5c3d\u7ba1\u5982\u6b64\uff0c\u90e8\u5206\u652f\u6301\u4e25\u683c\u7c7b\u578b\u68c0\u67e5\u3002</p>"},{"location":"usage/models/#model-signature","title":"\u6a21\u578b\u7b7e\u540d(Model signature)","text":"<p>\u6240\u6709 pydantic \u6a21\u578b\u90fd\u5c06\u6839\u636e\u5176\u5b57\u6bb5\u751f\u6210\u7b7e\u540d\uff1a</p> <pre><code>import inspect\nfrom pydantic import BaseModel, Field\n\n\nclass FooModel(BaseModel):\n    id: int\n    name: str = None\n    description: str = 'Foo'\n    apple: int = Field(..., alias='pear')\n\n\nprint(inspect.signature(FooModel))\n</code></pre> <p>\u51c6\u786e\u7684\u7b7e\u540d\u5bf9\u4e8e\u5185\u7701\u76ee\u7684\u548c\u5e93\uff08\u5982<code>FastAPI</code>\u6216 <code>hypothesis</code> \uff09\u5f88\u6709\u7528\u3002</p> <p>\u751f\u6210\u7684\u7b7e\u540d\u4e5f\u5c06\u9075\u5faa\u81ea\u5b9a\u4e49\u7684 <code>__init__</code> \u51fd\u6570\uff1a</p> <pre><code>import inspect\n\nfrom pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    id: int\n    info: str = 'Foo'\n\n    def __init__(self, id: int = 1, *, bar: str, **data) -&gt; None:\n\"\"\"My custom init!\"\"\"\n        super().__init__(id=id, bar=bar, **data)\n\n\nprint(inspect.signature(MyModel))\n</code></pre> <p>\u8981\u5305\u542b\u5728\u7b7e\u540d\u4e2d\uff0c\u5b57\u6bb5\u7684\u522b\u540d\u6216\u540d\u79f0\u5fc5\u987b\u662f\u6709\u6548\u7684 Python \u6807\u8bc6\u7b26\u3002 pydantic \u66f4\u559c\u6b22\u522b\u540d\u800c\u4e0d\u662f\u540d\u79f0\uff0c\u4f46\u5982\u679c\u522b\u540d\u4e0d\u662f\u6709\u6548\u7684 Python \u6807\u8bc6\u7b26\uff0c\u5219\u53ef\u4ee5\u4f7f\u7528\u5b57\u6bb5\u540d\u79f0\u3002</p> <p>\u5982\u679c\u4e00\u4e2a\u5b57\u6bb5\u7684\u522b\u540d\u548c\u540d\u79f0\u90fd\u662f\u65e0\u6548\u7684\u6807\u8bc6\u7b26\uff0c\u5219\u4f1a\u6dfb\u52a0\u4e00\u4e2a <code>**data</code> \u53c2\u6570\u3002</p> <p>\u6b64\u5916\uff0c\u5982\u679c <code>Config.extra</code> \u4e3a <code>Extra.allow</code>\uff0c<code>**data</code> \u53c2\u6570\u5c06\u59cb\u7ec8\u51fa\u73b0\u5728\u7b7e\u540d\u4e2d\u3002</p> <p>Note</p> <p>\u6a21\u578b\u7b7e\u540d\u4e2d\u7684\u7c7b\u578b\u4e0e\u6a21\u578b\u6ce8\u91ca\u4e2d\u58f0\u660e\u7684\u7c7b\u578b\u76f8\u540c\uff0c\u4e0d\u4e00\u5b9a\u662f\u5b9e\u9645\u53ef\u4ee5\u63d0\u4f9b\u7ed9\u8be5\u5b57\u6bb5\u7684\u6240\u6709\u7c7b\u578b\u3002</p> <p>\u4e00\u65e6 #1055 \u5f97\u5230\u89e3\u51b3\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5728\u67d0\u4e00\u5929\u5f97\u5230\u89e3\u51b3\u3002</p>"},{"location":"usage/models/#structural-pattern-matching","title":"\u7ed3\u6784\u6a21\u5f0f\u5339\u914d(Structural pattern matching)","text":"<p>pydantic \u652f\u6301\u6a21\u578b\u7684\u7ed3\u6784\u6a21\u5f0f\u5339\u914d\uff0c\u5982 Python 3.10 \u4e2d\u7684 PEP 636 \u6240\u4ecb\u7ecd\u7684\u90a3\u6837\u3002</p> <pre><code># requires python3.10\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    species: str\n\n\na = Pet(name='Bones', species='dog')\n\nmatch a:\n    # match `species` to 'dog', declare and initialize `dog_name`\n    case Pet(species='dog', name=dog_name):\n        print(f'{dog_name} is a dog')\n    # default case\n    case _:\n        print('No dog matched')\n</code></pre> <p>Note</p> <p>match-case \u8bed\u53e5\u770b\u8d77\u6765\u597d\u50cf\u521b\u5efa\u4e86\u4e00\u4e2a\u65b0\u6a21\u578b\uff0c\u4f46\u4e0d\u8981\u88ab\u611a\u5f04\u4e86\uff1b</p> <p>\u5b83\u53ea\u662f\u83b7\u53d6\u5c5e\u6027\u5e76\u6bd4\u8f83\u5b83\u6216\u58f0\u660e\u548c\u521d\u59cb\u5316\u5b83\u7684\u8bed\u6cd5\u7cd6\u3002</p>"},{"location":"usage/mypy/","title":"\u548cmypy\u4e00\u8d77\u4f7f\u7528","text":"<p>pydantic models work with mypy provided you use the annotation-only version of required fields:</p> <pre><code># dont-execute\nfrom datetime import datetime\nfrom typing import List, Optional\nfrom pydantic import BaseModel, NoneStr\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: NoneStr = None\n    signup_ts: Optional[datetime] = None\n    list_of_ints: List[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n</code></pre> <p>You can run your code through mypy with:</p> <pre><code>mypy \\\n--ignore-missing-imports \\\n--follow-imports=skip \\\n--strict-optional \\\npydantic_mypy_test.py\n</code></pre> <p>If you call mypy on the example code above, you should see mypy detect the attribute access error: <pre><code>13: error: \"Model\" has no attribute \"middle_name\"\n</code></pre></p>"},{"location":"usage/mypy/#strict-optional","title":"Strict Optional","text":"<p>For your code to pass with <code>--strict-optional</code>, you need to to use <code>Optional[]</code> or an alias of <code>Optional[]</code> for all fields with <code>None</code> as the default. (This is standard with mypy.)</p> <p>Pydantic provides a few useful optional or union types:</p> <ul> <li><code>NoneStr</code> aka. <code>Optional[str]</code></li> <li><code>NoneBytes</code> aka. <code>Optional[bytes]</code></li> <li><code>StrBytes</code> aka. <code>Union[str, bytes]</code></li> <li><code>NoneStrBytes</code> aka. <code>Optional[StrBytes]</code></li> </ul> <p>If these aren't sufficient you can of course define your own.</p>"},{"location":"usage/mypy/#mypy-plugin","title":"Mypy Plugin","text":"<p>Pydantic ships with a mypy plugin that adds a number of important pydantic-specific features to mypy that improve its ability to type-check your code.</p> <p>See the pydantic mypy plugin docs for more details.</p>"},{"location":"usage/mypy/#other-pydantic-interfaces","title":"Other pydantic interfaces","text":"<p>Pydantic dataclasses and the <code>validate_arguments</code> decorator should also work well with mypy.</p>"},{"location":"usage/postponed_annotations/","title":"\u5ef6\u8fdf\u6ce8\u89e3","text":"<p>Note</p> <p>Both postponed annotations via the future import and <code>ForwardRef</code> require Python 3.7+.</p> <p>Postponed annotations (as described in PEP563) \"just work\".</p> <pre><code>from __future__ import annotations\nfrom typing import Any, List\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: List[int]\n    b: Any\n\n\nprint(Model(a=('1', 2, 3), b='ok'))\n</code></pre> <p>Internally, pydantic  will call a method similar to <code>typing.get_type_hints</code> to resolve annotations.</p> <p>In cases where the referenced type is not yet defined, <code>ForwardRef</code> can be used (although referencing the type directly or by its string is a simpler solution in the case of self-referencing models).</p> <p>In some cases, a <code>ForwardRef</code> won't be able to be resolved during model creation. For example, this happens whenever a model references itself as a field type. When this happens, you'll need to call <code>update_forward_refs</code> after the model has been created before it can be used:</p> <pre><code>from typing import ForwardRef\nfrom pydantic import BaseModel\n\nFoo = ForwardRef('Foo')\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    b: Foo = None\n\n\nFoo.update_forward_refs()\n\nprint(Foo())\nprint(Foo(b={'a': '321'}))\n</code></pre> <p>Warning</p> <p>To resolve strings (type names) into annotations (types), pydantic needs a namespace dict in which to perform the lookup. For this it uses <code>module.__dict__</code>, just like <code>get_type_hints</code>. This means pydantic may not play well with types not defined in the global scope of a module.</p> <p>For example, this works fine:</p> <pre><code>from __future__ import annotations\nfrom pydantic import BaseModel\nfrom pydantic import HttpUrl  # HttpUrl is defined in the module's global scope\n\n\ndef this_works():\n    class Model(BaseModel):\n        a: HttpUrl\n\n    print(Model(a='https://example.com'))\n\n\nthis_works()\n</code></pre> <p>While this will break:</p> <pre><code>from __future__ import annotations\nfrom pydantic import BaseModel\nfrom pydantic.errors import ConfigError\n\n\ndef this_is_broken():\n    from pydantic import HttpUrl  # HttpUrl is defined in function local scope\n\n    class Model(BaseModel):\n        a: HttpUrl\n\n    try:\n        Model(a='https://example.com')\n    except ConfigError as e:\n        print(e)\n\n    try:\n        Model.update_forward_refs()\n    except NameError as e:\n        print(e)\n\n\nthis_is_broken()\n</code></pre> <p>Resolving this is beyond the call for pydantic: either remove the future import or declare the types globally.</p>"},{"location":"usage/postponed_annotations/#self-referencing-models","title":"Self-referencing Models","text":"<p>Data structures with self-referencing models are also supported. Self-referencing fields will be automatically resolved after model creation.</p> <p>Within the model, you can refer to the not-yet-constructed model using a string:</p> <pre><code>from pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    #: The sibling of `Foo` is referenced by string\n    sibling: 'Foo' = None\n\n\nprint(Foo())\nprint(Foo(sibling={'a': '321'}))\n</code></pre> <p>Since Python 3.7, you can also refer it by its type, provided you import <code>annotations</code> (see above for support depending on Python and pydantic versions).</p> <pre><code>from __future__ import annotations\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    #: The sibling of `Foo` is referenced directly by type\n    sibling: Foo = None\n\n\nprint(Foo())\nprint(Foo(sibling={'a': '321'}))\n</code></pre>"},{"location":"usage/rich/","title":"\u548crich\u4e00\u8d77\u4f7f\u7528","text":"<p>Pydantic models may be printed with the Rich library which will add additional formatting and color to the output. Here's an example:</p> <p></p> <p>See the Rich documentation on pretty printing for more information.</p>"},{"location":"usage/schema/","title":"\u6a21\u578b\u56fe\u5f0f(schema)","text":"<p>Pydantic allows auto creation of JSON Schemas from models:</p> <pre><code># output-json\nfrom enum import Enum\nfrom pydantic import BaseModel, Field\n\n\nclass FooBar(BaseModel):\n    count: int\n    size: float = None\n\n\nclass Gender(str, Enum):\n    male = 'male'\n    female = 'female'\n    other = 'other'\n    not_given = 'not_given'\n\n\nclass MainModel(BaseModel):\n\"\"\"\n    This is the description of the main model\n    \"\"\"\n\n    foo_bar: FooBar = Field(...)\n    gender: Gender = Field(None, alias='Gender')\n    snap: int = Field(\n        42,\n        title='The Snap',\n        description='this is the value of snap',\n        gt=30,\n        lt=50,\n    )\n\n    class Config:\n        title = 'Main'\n\n\n# this is equivalent to json.dumps(MainModel.schema(), indent=2):\nprint(MainModel.schema_json(indent=2))\n</code></pre> <p>The generated schemas are compliant with the specifications: JSON Schema Core, JSON Schema Validation and OpenAPI.</p> <p><code>BaseModel.schema</code> will return a dict of the schema, while <code>BaseModel.schema_json</code> will return a JSON string representation of that dict.</p> <p>Sub-models used are added to the <code>definitions</code> JSON attribute and referenced, as per the spec.</p> <p>All sub-models' (and their sub-models') schemas are put directly in a top-level <code>definitions</code> JSON key for easy re-use and reference.</p> <p>\"Sub-models\" with modifications (via the <code>Field</code> class) like a custom title, description or default value, are recursively included instead of referenced.</p> <p>The <code>description</code> for models is taken from either the docstring of the class or the argument <code>description</code> to the <code>Field</code> class.</p> <p>The schema is generated by default using aliases as keys, but it can be generated using model property names instead by calling <code>MainModel.schema/schema_json(by_alias=False)</code>.</p> <p>The format of <code>$ref</code>s (<code>\"#/definitions/FooBar\"</code> above) can be altered by calling <code>schema()</code> or <code>schema_json()</code> with the <code>ref_template</code> keyword argument, e.g. <code>ApplePie.schema(ref_template='/schemas/{model}.json#/')</code>, here <code>{model}</code> will be replaced with the model naming using <code>str.format()</code>.</p>"},{"location":"usage/schema/#getting-schema-of-a-specified-type","title":"Getting schema of a specified type","text":"<p>Pydantic includes two standalone utility functions <code>schema_of</code> and <code>schema_json_of</code> that can be used to apply the schema generation logic used for pydantic models in a more ad-hoc way. These functions behave similarly to <code>BaseModel.schema</code> and <code>BaseModel.schema_json</code>, but work with arbitrary pydantic-compatible types.</p> <pre><code>from typing import Literal, Union\n\nfrom typing_extensions import Annotated\n\nfrom pydantic import BaseModel, Field, schema_json_of\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    cat_name: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    dog_name: str\n\n\nPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\nprint(schema_json_of(Pet, title='The Pet Schema', indent=2))\n</code></pre>"},{"location":"usage/schema/#field-customization","title":"Field customization","text":"<p>Optionally, the <code>Field</code> function can be used to provide extra information about the field and validations. It has the following arguments:</p> <ul> <li><code>default</code>: (a positional argument) the default value of the field.     Since the <code>Field</code> replaces the field's default, this first argument can be used to set the default.     Use ellipsis (<code>...</code>) to indicate the field is required.</li> <li><code>default_factory</code>: a zero-argument callable that will be called when a default value is needed for this field.     Among other purposes, this can be used to set dynamic default values.     It is forbidden to set both <code>default</code> and <code>default_factory</code>.</li> <li><code>alias</code>: the public name of the field</li> <li><code>title</code>: if omitted, <code>field_name.title()</code> is used</li> <li><code>description</code>: if omitted and the annotation is a sub-model,     the docstring of the sub-model will be used</li> <li><code>exclude</code>: exclude this field when dumping (<code>.dict</code> and <code>.json</code>) the instance. The exact syntax and configuration options are described in details in the exporting models section.</li> <li><code>include</code>: include (only) this field when dumping (<code>.dict</code> and <code>.json</code>) the instance. The exact syntax and configuration options are described in details in the exporting models section.</li> <li><code>const</code>: this argument must be the same as the field's default value if present.</li> <li><code>gt</code>: for numeric values (<code>int</code>, <code>float</code>, <code>Decimal</code>), adds a validation of \"greater than\" and an annotation   of <code>exclusiveMinimum</code> to the JSON Schema</li> <li><code>ge</code>: for numeric values, this adds a validation of \"greater than or equal\" and an annotation of <code>minimum</code> to the   JSON Schema</li> <li><code>lt</code>: for numeric values, this adds a validation of \"less than\" and an annotation of <code>exclusiveMaximum</code> to the   JSON Schema</li> <li><code>le</code>: for numeric values, this adds a validation of \"less than or equal\" and an annotation of <code>maximum</code> to the   JSON Schema</li> <li><code>multiple_of</code>: for numeric values, this adds a validation of \"a multiple of\" and an annotation of <code>multipleOf</code> to the   JSON Schema</li> <li><code>max_digits</code>: for <code>Decimal</code> values, this adds a validation to have a maximum number of digits within the decimal. It   does not include a zero before the decimal point or trailing decimal zeroes.</li> <li><code>decimal_places</code>: for <code>Decimal</code> values, this adds a validation to have at most a number of decimal places allowed. It   does not include trailing decimal zeroes.</li> <li><code>min_items</code>: for list values, this adds a corresponding validation and an annotation of <code>minItems</code> to the   JSON Schema</li> <li><code>max_items</code>: for list values, this adds a corresponding validation and an annotation of <code>maxItems</code> to the   JSON Schema</li> <li><code>unique_items</code>: for list values, this adds a corresponding validation and an annotation of <code>uniqueItems</code> to the   JSON Schema</li> <li><code>min_length</code>: for string values, this adds a corresponding validation and an annotation of <code>minLength</code> to the   JSON Schema</li> <li><code>max_length</code>: for string values, this adds a corresponding validation and an annotation of <code>maxLength</code> to the   JSON Schema</li> <li><code>allow_mutation</code>: a boolean which defaults to <code>True</code>. When False, the field raises a <code>TypeError</code> if the field is   assigned on an instance.  The model config must set <code>validate_assignment</code> to <code>True</code> for this check to be performed.</li> <li> <p><code>regex</code>: for string values, this adds a Regular Expression validation generated from the passed string and an   annotation of <code>pattern</code> to the JSON Schema</p> <p>Note</p> <p>pydantic validates strings using <code>re.match</code>, which treats regular expressions as implicitly anchored at the beginning. On the contrary, JSON Schema validators treat the <code>pattern</code> keyword as implicitly unanchored, more like what <code>re.search</code> does.</p> <p>For interoperability, depending on your desired behavior, either explicitly anchor your regular expressions with <code>^</code> (e.g. <code>^foo</code> to match any string starting with <code>foo</code>), or explicitly allow an arbitrary prefix with <code>.*?</code> (e.g. <code>.*?foo</code> to match any string containing the substring <code>foo</code>).</p> <p>See #1631 for a discussion of possible changes to pydantic behavior in v2.</p> </li> </ul> <ul> <li><code>repr</code>: a boolean which defaults to <code>True</code>. When False, the field shall be hidden from the object representation.</li> <li><code>**</code> any other keyword arguments (e.g. <code>examples</code>) will be added verbatim to the field's schema</li> </ul> <p>Instead of using <code>Field</code>, the <code>fields</code> property of the Config class can be used to set all of the arguments above except <code>default</code>.</p>"},{"location":"usage/schema/#unenforced-field-constraints","title":"Unenforced Field constraints","text":"<p>If pydantic finds constraints which are not being enforced, an error will be raised. If you want to force the constraint to appear in the schema, even though it's not being checked upon parsing, you can use variadic arguments to <code>Field()</code> with the raw schema attribute name:</p> <pre><code>from pydantic import BaseModel, Field, PositiveInt\n\ntry:\n    # this won't work since PositiveInt takes precedence over the\n    # constraints defined in Field meaning they're ignored\n    class Model(BaseModel):\n        foo: PositiveInt = Field(..., lt=10)\nexcept ValueError as e:\n    print(e)\n\n\n# but you can set the schema attribute directly:\n# (Note: here exclusiveMaximum will not be enforce)\nclass Model(BaseModel):\n    foo: PositiveInt = Field(..., exclusiveMaximum=10)\n\n\nprint(Model.schema())\n\n\n# if you find yourself needing this, an alternative is to declare\n# the constraints in Field (or you could use conint())\n# here both constraints will be enforced:\nclass Model(BaseModel):\n    # Here both constraints will be applied and the schema\n    # will be generated correctly\n    foo: int = Field(..., gt=0, lt=10)\n\n\nprint(Model.schema())\n</code></pre>"},{"location":"usage/schema/#typingannotated-fields","title":"typing.Annotated Fields","text":"<p>Rather than assigning a <code>Field</code> value, it can be specified in the type hint with <code>typing.Annotated</code>:</p> <pre><code>from uuid import uuid4\n\nfrom pydantic import BaseModel, Field\nfrom typing_extensions import Annotated\n\n\nclass Foo(BaseModel):\n    id: Annotated[str, Field(default_factory=lambda: uuid4().hex)]\n    name: Annotated[str, Field(max_length=256)] = 'Bar'\n</code></pre> <p><code>Field</code> can only be supplied once per field - an error will be raised if used in <code>Annotated</code> and as the assigned value. Defaults can be set outside <code>Annotated</code> as the assigned value or with <code>Field.default_factory</code> inside <code>Annotated</code> - the <code>Field.default</code> argument is not supported inside <code>Annotated</code>.</p> <p>For versions of Python prior to 3.9, <code>typing_extensions.Annotated</code> can be used.</p>"},{"location":"usage/schema/#modifying-schema-in-custom-fields","title":"Modifying schema in custom fields","text":"<p>Custom field types can customise the schema generated for them using the <code>__modify_schema__</code> class method; see Custom Data Types for more details.</p> <p><code>__modify_schema__</code> can also take a <code>field</code> argument which will have type <code>Optional[ModelField]</code>. pydantic will inspect the signature of <code>__modify_schema__</code> to determine whether the <code>field</code> argument should be included.</p> <pre><code># output-json\nfrom typing import Any, Callable, Dict, Generator, Optional\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.fields import ModelField\n\n\nclass RestrictedAlphabetStr(str):\n    @classmethod\n    def __get_validators__(cls) -&gt; Generator[Callable, None, None]:\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: str, field: ModelField):\n        alphabet = field.field_info.extra['alphabet']\n        if any(c not in alphabet for c in value):\n            raise ValueError(f'{value!r} is not restricted to {alphabet!r}')\n        return cls(value)\n\n    @classmethod\n    def __modify_schema__(\n        cls, field_schema: Dict[str, Any], field: Optional[ModelField]\n    ):\n        if field:\n            alphabet = field.field_info.extra['alphabet']\n            field_schema['examples'] = [c * 3 for c in alphabet]\n\n\nclass MyModel(BaseModel):\n    value: RestrictedAlphabetStr = Field(alphabet='ABC')\n\n\nprint(MyModel.schema_json(indent=2))\n</code></pre>"},{"location":"usage/schema/#json-schema-types","title":"JSON Schema Types","text":"<p>Types, custom field types, and constraints (like <code>max_length</code>) are mapped to the corresponding spec formats in the following priority order (when there is an equivalent available):</p> <ol> <li>JSON Schema Core</li> <li>JSON Schema Validation</li> <li>OpenAPI Data Types</li> <li>The standard <code>format</code> JSON field is used to define pydantic extensions for more complex <code>string</code> sub-types.</li> </ol> <p>The field schema mapping from Python / pydantic to JSON Schema is done as follows:</p>"},{"location":"usage/schema/#top-level-schema-generation","title":"Top-level schema generation","text":"<p>You can also generate a top-level JSON Schema that only includes a list of models and related sub-models in its <code>definitions</code>:</p> <pre><code># output-json\nimport json\nfrom pydantic import BaseModel\nfrom pydantic.schema import schema\n\n\nclass Foo(BaseModel):\n    a: str = None\n\n\nclass Model(BaseModel):\n    b: Foo\n\n\nclass Bar(BaseModel):\n    c: int\n\n\ntop_level_schema = schema([Model, Bar], title='My Schema')\nprint(json.dumps(top_level_schema, indent=2))\n</code></pre>"},{"location":"usage/schema/#schema-customization","title":"Schema customization","text":"<p>You can customize the generated <code>$ref</code> JSON location: the definitions are always stored under the key <code>definitions</code>, but a specified prefix can be used for the references.</p> <p>This is useful if you need to extend or modify the JSON Schema default definitions location. E.g. with OpenAPI:</p> <pre><code># output-json\nimport json\nfrom pydantic import BaseModel\nfrom pydantic.schema import schema\n\n\nclass Foo(BaseModel):\n    a: int\n\n\nclass Model(BaseModel):\n    a: Foo\n\n\n# Default location for OpenAPI\ntop_level_schema = schema([Model], ref_prefix='#/components/schemas/')\nprint(json.dumps(top_level_schema, indent=2))\n</code></pre> <p>It's also possible to extend/override the generated JSON schema in a model.</p> <p>To do it, use the <code>Config</code> sub-class attribute <code>schema_extra</code>.</p> <p>For example, you could add <code>examples</code> to the JSON Schema:</p> <pre><code># output-json\nfrom pydantic import BaseModel\n\n\nclass Person(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        schema_extra = {\n            'examples': [\n                {\n                    'name': 'John Doe',\n                    'age': 25,\n                }\n            ]\n        }\n\n\nprint(Person.schema_json(indent=2))\n</code></pre> <p>For more fine-grained control, you can alternatively set <code>schema_extra</code> to a callable and post-process the generated schema. The callable can have one or two positional arguments. The first will be the schema dictionary. The second, if accepted, will be the model class. The callable is expected to mutate the schema dictionary in-place; the return value is not used.</p> <p>For example, the <code>title</code> key can be removed from the model's <code>properties</code>:</p> <pre><code># output-json\nfrom typing import Dict, Any, Type\nfrom pydantic import BaseModel\n\n\nclass Person(BaseModel):\n    name: str\n    age: int\n\n    class Config:\n        @staticmethod\n        def schema_extra(schema: Dict[str, Any], model: Type['Person']) -&gt; None:\n            for prop in schema.get('properties', {}).values():\n                prop.pop('title', None)\n\n\nprint(Person.schema_json(indent=2))\n</code></pre>"},{"location":"usage/settings/","title":"\u914d\u7f6e\u7ba1\u7406","text":"<p>One of pydantic's most useful applications is settings management.</p> <p>If you create a model that inherits from <code>BaseSettings</code>, the model initialiser will attempt to determine the values of any fields not passed as keyword arguments by reading from the environment. (Default values will still be used if the matching environment variable is not set.)</p> <p>This makes it easy to:</p> <ul> <li>Create a clearly-defined, type-hinted application configuration class</li> <li>Automatically read modifications to the configuration from environment variables</li> <li>Manually override specific settings in the initialiser where desired (e.g. in unit tests)</li> </ul> <p>For example:</p> <pre><code>from typing import Set\n\nfrom pydantic import (\n    BaseModel,\n    BaseSettings,\n    PyObject,\n    RedisDsn,\n    PostgresDsn,\n    AmqpDsn,\n    Field,\n)\n\n\nclass SubModel(BaseModel):\n    foo = 'bar'\n    apple = 1\n\n\nclass Settings(BaseSettings):\n    auth_key: str\n    api_key: str = Field(..., env='my_api_key')\n\n    redis_dsn: RedisDsn = 'redis://user:pass@localhost:6379/1'\n    pg_dsn: PostgresDsn = 'postgres://user:pass@localhost:5432/foobar'\n    amqp_dsn: AmqpDsn = 'amqp://user:pass@localhost:5672/'\n\n    special_function: PyObject = 'math.cos'\n\n    # to override domains:\n    # export my_prefix_domains='[\"foo.com\", \"bar.com\"]'\n    domains: Set[str] = set()\n\n    # to override more_settings:\n    # export my_prefix_more_settings='{\"foo\": \"x\", \"apple\": 1}'\n    more_settings: SubModel = SubModel()\n\n    class Config:\n        env_prefix = 'my_prefix_'  # defaults to no prefix, i.e. \"\"\n        fields = {\n            'auth_key': {\n                'env': 'my_auth_key',\n            },\n            'redis_dsn': {\n                'env': ['service_redis_dsn', 'redis_url']\n            }\n        }\n\n\nprint(Settings().dict())\n</code></pre>"},{"location":"usage/settings/#environment-variable-names","title":"Environment variable names","text":"<p>The following rules are used to determine which environment variable(s) are read for a given field:</p> <ul> <li> <p>By default, the environment variable name is built by concatenating the prefix and field name.</p> <ul> <li>For example, to override <code>special_function</code> above, you could use:<pre><code>  export my_prefix_special_function='foo.bar'\n</code></pre> </li> </ul> <ul> <li>Note 1: The default prefix is an empty string.</li> <li>Note 2: Field aliases are ignored when building the environment variable name.</li> </ul> </li> </ul> <ul> <li>Custom environment variable names can be set in two ways:<ul> <li><code>Config.fields['field_name']['env']</code> (see <code>auth_key</code> and <code>redis_dsn</code> above)</li> <li><code>Field(..., env=...)</code> (see <code>api_key</code> above)</li> </ul> </li> <li>When specifying custom environment variable names, either a string or a list of strings may be provided.<ul> <li>When specifying a list of strings, order matters: the first detected value is used.</li> <li>For example, for <code>redis_dsn</code> above, <code>service_redis_dsn</code> would take precedence over <code>redis_url</code>.</li> </ul> </li> </ul> <p>Warning</p> <p>Since v1.0 pydantic does not consider field aliases when finding environment variables to populate settings models, use <code>env</code> instead as described above.</p> <p>To aid the transition from aliases to <code>env</code>, a warning will be raised when aliases are used on settings models without a custom env var name. If you really mean to use aliases, either ignore the warning or set <code>env</code> to suppress it.</p> <p>Case-sensitivity can be turned on through the <code>Config</code>:</p> <pre><code>from pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    redis_host = 'localhost'\n\n    class Config:\n        case_sensitive = True\n</code></pre> <p>When <code>case_sensitive</code> is <code>True</code>, the environment variable names must match field names (optionally with a prefix), so in this example <code>redis_host</code> could only be modified via <code>export redis_host</code>. If you want to name environment variables all upper-case, you should name attribute all upper-case too. You can still name environment variables anything you like through <code>Field(..., env=...)</code>.</p> <p>In Pydantic v1 <code>case_sensitive</code> is <code>False</code> by default and all variable names are converted to lower-case internally. If you want to define upper-case variable names on nested models like <code>SubModel</code> you have to set <code>case_sensitive=True</code> to disable this behaviour.</p> <p>Note</p> <p>On Windows, Python's <code>os</code> module always treats environment variables as case-insensitive, so the <code>case_sensitive</code> config setting will have no effect - settings will always be updated ignoring case.</p>"},{"location":"usage/settings/#parsing-environment-variable-values","title":"Parsing environment variable values","text":"<p>For most simple field types (such as <code>int</code>, <code>float</code>, <code>str</code>, etc.), the environment variable value is parsed the same way it would be if passed directly to the initialiser (as a string).</p> <p>Complex types like <code>list</code>, <code>set</code>, <code>dict</code>, and sub-models are populated from the environment by treating the environment variable's value as a JSON-encoded string.</p> <p>Another way to populate nested complex variables is to configure your model with the <code>env_nested_delimiter</code> config setting, then use an env variable with a name pointing to the nested module fields. What it does is simply explodes your variable into nested models or dicts. So if you define a variable <code>FOO__BAR__BAZ=123</code> it will convert it into <code>FOO={'BAR': {'BAZ': 123}}</code> If you have multiple variables with the same structure they will be merged.</p> <p>With the following environment variables: <pre><code># your environment\nexport V0=0\nexport SUB_MODEL='{\"v1\": \"json-1\", \"v2\": \"json-2\"}'\nexport SUB_MODEL__V2=nested-2\nexport SUB_MODEL__V3=3\nexport SUB_MODEL__DEEP__V4=v4\n</code></pre></p> <p>You could load a settings module thus: <pre><code>from pydantic import BaseModel, BaseSettings\n\n\nclass DeepSubModel(BaseModel):\n    v4: str\n\n\nclass SubModel(BaseModel):\n    v1: str\n    v2: bytes\n    v3: int\n    deep: DeepSubModel\n\n\nclass Settings(BaseSettings):\n    v0: str\n    sub_model: SubModel\n\n    class Config:\n        env_nested_delimiter = '__'\n\n\nprint(Settings().dict())\n</code></pre></p> <p><code>env_nested_delimiter</code> can be configured via the <code>Config</code> class as shown above, or via the <code>_env_nested_delimiter</code> keyword argument on instantiation.</p> <p>JSON is only parsed in top-level fields, if you need to parse JSON in sub-models, you will need to implement validators on those models.</p> <p>Nested environment variables take precedence over the top-level environment variable JSON (e.g. in the example above, <code>SUB_MODEL__V2</code> trumps <code>SUB_MODEL</code>).</p> <p>You may also populate a complex type by providing your own parsing function to the <code>parse_env_var</code> classmethod in the Config object.</p> <pre><code>import os\nfrom typing import Any, List\n\nfrom pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    numbers: List[int]\n\n    class Config:\n        @classmethod\n        def parse_env_var(cls, field_name: str, raw_val: str) -&gt; Any:\n            if field_name == 'numbers':\n                return [int(x) for x in raw_val.split(',')]\n            return cls.json_loads(raw_val)\n\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().dict())\n</code></pre>"},{"location":"usage/settings/#dotenv-env-support","title":"Dotenv (.env) support","text":"<p>Note</p> <p>dotenv file parsing requires python-dotenv to be installed. This can be done with either <code>pip install python-dotenv</code> or <code>pip install pydantic[dotenv]</code>.</p> <p>Dotenv files (generally named <code>.env</code>) are a common pattern that make it easy to use environment variables in a platform-independent manner.</p> <p>A dotenv file follows the same general principles of all environment variables, and looks something like:</p> <pre><code># ignore comment\nENVIRONMENT=\"production\"\nREDIS_ADDRESS=localhost:6379\nMEANING_OF_LIFE=42\nMY_VAR='Hello world'\n</code></pre> <p>Once you have your <code>.env</code> file filled with variables, pydantic supports loading it in two ways:</p> <p>1. setting <code>env_file</code> (and <code>env_file_encoding</code> if you don't want the default encoding of your OS) on <code>Config</code> in a <code>BaseSettings</code> class:</p> <pre><code>class Settings(BaseSettings):\n    ...\n\n    class Config:\n        env_file = '.env'\n        env_file_encoding = 'utf-8'\n</code></pre> <p>2. instantiating a <code>BaseSettings</code> derived class with the <code>_env_file</code> keyword argument (and the <code>_env_file_encoding</code> if needed):</p> <pre><code>settings = Settings(_env_file='prod.env', _env_file_encoding='utf-8')\n</code></pre> <p>In either case, the value of the passed argument can be any valid path or filename, either absolute or relative to the current working directory. From there, pydantic will handle everything for you by loading in your variables and validating them.</p> <p>Note</p> <p>If a filename is specified for <code>env_file</code>, Pydantic will only check the current working directory and won't check any parent directories for the <code>.env</code> file.</p> <p>Even when using a dotenv file, pydantic will still read environment variables as well as the dotenv file, environment variables will always take priority over values loaded from a dotenv file.</p> <p>Passing a file path via the <code>_env_file</code> keyword argument on instantiation (method 2) will override the value (if any) set on the <code>Config</code> class. If the above snippets were used in conjunction, <code>prod.env</code> would be loaded while <code>.env</code> would be ignored.</p> <p>If you need to load multiple dotenv files, you can pass the file paths as a <code>list</code> or <code>tuple</code>.</p> <p>Later files in the list/tuple will take priority over earlier files.</p> <pre><code>from pydantic import BaseSettings\n\nclass Settings(BaseSettings):\n    ...\n\n    class Config:\n        # `.env.prod` takes priority over `.env`\n        env_file = '.env', '.env.prod'\n</code></pre> <p>You can also use the keyword argument override to tell Pydantic not to load any file at all (even if one is set in the <code>Config</code> class) by passing <code>None</code> as the instantiation keyword argument, e.g. <code>settings = Settings(_env_file=None)</code>.</p> <p>Because python-dotenv is used to parse the file, bash-like semantics such as <code>export</code> can be used which (depending on your OS and environment) may allow your dotenv file to also be used with <code>source</code>, see python-dotenv's documentation for more details.</p>"},{"location":"usage/settings/#secret-support","title":"Secret Support","text":"<p>Placing secret values in files is a common pattern to provide sensitive configuration to an application.</p> <p>A secret file follows the same principal as a dotenv file except it only contains a single value and the file name is used as the key. A secret file will look like the following:</p> <p><code>/var/run/database_password</code>: <pre><code>super_secret_database_password\n</code></pre></p> <p>Once you have your secret files, pydantic supports loading it in two ways:</p> <p>1. setting <code>secrets_dir</code> on <code>Config</code> in a <code>BaseSettings</code> class to the directory where your secret files are stored:</p> <pre><code>class Settings(BaseSettings):\n    ...\n    database_password: str\n\n    class Config:\n        secrets_dir = '/var/run'\n</code></pre> <p>2. instantiating a <code>BaseSettings</code> derived class with the <code>_secrets_dir</code> keyword argument:</p> <pre><code>settings = Settings(_secrets_dir='/var/run')\n</code></pre> <p>In either case, the value of the passed argument can be any valid directory, either absolute or relative to the current working directory. Note that a non existent directory will only generate a warning. From there, pydantic will handle everything for you by loading in your variables and validating them.</p> <p>Even when using a secrets directory, pydantic will still read environment variables from a dotenv file or the environment, a dotenv file and environment variables will always take priority over values loaded from the secrets directory.</p> <p>Passing a file path via the <code>_secrets_dir</code> keyword argument on instantiation (method 2) will override the value (if any) set on the <code>Config</code> class.</p>"},{"location":"usage/settings/#use-case-docker-secrets","title":"Use Case: Docker Secrets","text":"<p>Docker Secrets can be used to provide sensitive configuration to an application running in a Docker container. To use these secrets in a pydantic application the process is simple. More information regarding creating, managing and using secrets in Docker see the official Docker documentation.</p> <p>First, define your Settings <pre><code>class Settings(BaseSettings):\n    my_secret_data: str\n\n    class Config:\n        secrets_dir = '/run/secrets'\n</code></pre></p> <p>Note</p> <p>By default Docker uses <code>/run/secrets</code> as the target mount point. If you want to use a different location, change <code>Config.secrets_dir</code> accordingly.</p> <p>Then, create your secret via the Docker CLI <pre><code>printf \"This is a secret\" | docker secret create my_secret_data -\n</code></pre></p> <p>Last, run your application inside a Docker container and supply your newly created secret <pre><code>docker service create --name pydantic-with-secrets --secret my_secret_data pydantic-app:latest\n</code></pre></p>"},{"location":"usage/settings/#field-value-priority","title":"Field value priority","text":"<p>In the case where a value is specified for the same <code>Settings</code> field in multiple ways, the selected value is determined as follows (in descending order of priority):</p> <ol> <li>Arguments passed to the <code>Settings</code> class initialiser.</li> <li>Environment variables, e.g. <code>my_prefix_special_function</code> as described above.</li> <li>Variables loaded from a dotenv (<code>.env</code>) file.</li> <li>Variables loaded from the secrets directory.</li> <li>The default field values for the <code>Settings</code> model.</li> </ol>"},{"location":"usage/settings/#customise-settings-sources","title":"Customise settings sources","text":"<p>If the default order of priority doesn't match your needs, it's possible to change it by overriding the <code>customise_sources</code> method on the <code>Config</code> class of your <code>Settings</code> .</p> <p><code>customise_sources</code> takes three callables as arguments and returns any number of callables as a tuple. In turn these callables are called to build the inputs to the fields of the settings class.</p> <p>Each callable should take an instance of the settings class as its sole argument and return a <code>dict</code>.</p>"},{"location":"usage/settings/#changing-priority","title":"Changing Priority","text":"<p>The order of the returned callables decides the priority of inputs; first item is the highest priority.</p> <pre><code>from typing import Tuple\nfrom pydantic import BaseSettings, PostgresDsn\nfrom pydantic.env_settings import SettingsSourceCallable\n\n\nclass Settings(BaseSettings):\n    database_dsn: PostgresDsn\n\n    class Config:\n        @classmethod\n        def customise_sources(\n            cls,\n            init_settings: SettingsSourceCallable,\n            env_settings: SettingsSourceCallable,\n            file_secret_settings: SettingsSourceCallable,\n        ) -&gt; Tuple[SettingsSourceCallable, ...]:\n            return env_settings, init_settings, file_secret_settings\n\n\nprint(Settings(database_dsn='postgres://postgres@localhost:5432/kwargs_db'))\n</code></pre> <p>By flipping <code>env_settings</code> and <code>init_settings</code>, environment variables now have precedence over <code>__init__</code> kwargs.</p>"},{"location":"usage/settings/#adding-sources","title":"Adding sources","text":"<p>As explained earlier, pydantic ships with multiples built-in settings sources. However, you may occasionally need to add your own custom sources, <code>customise_sources</code> makes this very easy:</p> <pre><code>import json\nfrom pathlib import Path\nfrom typing import Dict, Any\n\nfrom pydantic import BaseSettings\n\n\ndef json_config_settings_source(settings: BaseSettings) -&gt; Dict[str, Any]:\n\"\"\"\n    A simple settings source that loads variables from a JSON file\n    at the project's root.\n\n    Here we happen to choose to use the `env_file_encoding` from Config\n    when reading `config.json`\n    \"\"\"\n    encoding = settings.__config__.env_file_encoding\n    return json.loads(Path('config.json').read_text(encoding))\n\n\nclass Settings(BaseSettings):\n    foobar: str\n\n    class Config:\n        env_file_encoding = 'utf-8'\n\n        @classmethod\n        def customise_sources(\n            cls,\n            init_settings,\n            env_settings,\n            file_secret_settings,\n        ):\n            return (\n                init_settings,\n                json_config_settings_source,\n                env_settings,\n                file_secret_settings,\n            )\n\n\nprint(Settings())\n</code></pre>"},{"location":"usage/settings/#removing-sources","title":"Removing sources","text":"<p>You might also want to disable a source:</p> <pre><code>from typing import Tuple\n\nfrom pydantic import BaseSettings\nfrom pydantic.env_settings import SettingsSourceCallable\n\n\nclass Settings(BaseSettings):\n    my_api_key: str\n\n    class Config:\n        @classmethod\n        def customise_sources(\n            cls,\n            init_settings: SettingsSourceCallable,\n            env_settings: SettingsSourceCallable,\n            file_secret_settings: SettingsSourceCallable,\n        ) -&gt; Tuple[SettingsSourceCallable, ...]:\n            # here we choose to ignore arguments from init_settings\n            return env_settings, file_secret_settings\n\n\nprint(Settings(my_api_key='this is ignored'))\n# requires: `MY_API_KEY` env variable to be set, e.g. `export MY_API_KEY=xxx`\n</code></pre>"},{"location":"usage/types/","title":"\u5b57\u6bb5\u7c7b\u578b","text":"<p>\u5728\u53ef\u80fd\u7684\u60c5\u51b5\u4e0b pydantic \u4f7f\u7528 \u6807\u51c6\u5e93\u7c7b\u578b \u6765\u5b9a\u4e49\u5b57\u6bb5\uff0c\u4ece\u800c\u5e73\u6ed1\u5b66\u4e60\u66f2\u7ebf\u3002 \u7136\u800c\uff0c\u5bf9\u4e8e\u8bb8\u591a\u6709\u7528\u7684\u5e94\u7528\u7a0b\u5e8f\uff0c\u4e0d\u5b58\u5728\u6807\u51c6\u5e93\u7c7b\u578b\uff0c\u56e0\u6b64 pydantic \u5b9e\u73b0 \u8bb8\u591a\u5e38\u7528\u7c7b\u578b\u3002</p> <p>\u5982\u679c\u6ca1\u6709\u9002\u5408\u60a8\u76ee\u7684\u7684\u73b0\u6709\u7c7b\u578b\uff0c\u60a8\u8fd8\u53ef\u4ee5\u4f7f\u7528\u81ea\u5b9a\u4e49\u5c5e\u6027\u548c\u9a8c\u8bc1\u6765\u5b9e\u73b0\u60a8\u7684\u81ea\u5df1\u7684 pydantic \u517c\u5bb9\u7c7b\u578b\u3002</p>"},{"location":"usage/types/#standard-library-types","title":"\u6807\u51c6\u5e93\u7c7b\u578b(Standard Library Types)","text":"<p>pydantic \u652f\u6301 Python \u6807\u51c6\u5e93\u4e2d\u7684\u8bb8\u591a\u5e38\u89c1\u7c7b\u578b\u3002 \u5982\u679c\u60a8\u9700\u8981\u66f4\u4e25\u683c\u7684\u5904\u7406\uff0c\u8bf7\u53c2\u9605 \u4e25\u683c\u7c7b\u578b\uff1b \u5982\u679c\u60a8\u9700\u8981\u9650\u5236\u5141\u8bb8\u7684\u503c\uff08\u4f8b\u5982\u9700\u8981\u4e00\u4e2a\u6b63\u6574\u6570\uff09\uff0c\u8bf7\u53c2\u9605 Constrained Types\u3002</p> <p><code>None</code>\u3001<code>type(None)</code> \u6216 <code>Literal[None]</code>\uff08\u7b49\u540c\u4e8e PEP 484\uff09 : \u53ea\u5141\u8bb8 <code>None</code> \u503c</p> <code>bool</code> \u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Booleans\uff0c\u4e86\u89e3\u6709\u5173\u5982\u4f55\u9a8c\u8bc1\u5e03\u5c14\u503c\u4ee5\u53ca\u5141\u8bb8\u4f7f\u7528\u54ea\u4e9b\u503c\u7684\u8be6\u7ec6\u4fe1\u606f <code>int</code> pydantic \u4f7f\u7528 <code>int(v)</code> \u5c06\u7c7b\u578b\u5f3a\u5236\u8f6c\u6362\u4e3a <code>int</code>\uff1b \u8bf7\u53c2\u9605 this \u5173\u4e8e\u6570\u636e\u8f6c\u6362\u671f\u95f4\u4fe1\u606f\u4e22\u5931\u7684\u8b66\u544a <code>float</code> \u7c7b\u4f3c\u5730\uff0c<code>float(v)</code> \u7528\u4e8e\u5c06\u503c\u5f3a\u5236\u8f6c\u6362\u4e3a\u6d6e\u70b9\u6570 <code>str</code> \u5b57\u7b26\u4e32\u6309\u539f\u6837\u63a5\u53d7\uff0c<code>int</code> <code>float</code> \u548c <code>Decimal</code> \u4f7f\u7528 <code>str(v)</code> \u5f3a\u5236\u8f6c\u6362\uff0c<code>bytes</code> \u548c <code>bytearray</code> \u4f7f\u7528 <code>v.decode()</code> \u8f6c\u6362\uff0c\u679a\u4e3e\u7ee7\u627f\u81ea <code>str</code> \u4f7f\u7528 <code>v.value</code> \u8fdb\u884c\u8f6c\u6362\uff0c\u6240\u6709\u5176\u4ed6\u7c7b\u578b\u90fd\u4f1a\u5bfc\u81f4\u9519\u8bef <code>bytes</code> <code>bytes</code> \u6309\u539f\u6837\u63a5\u53d7\uff0c<code>bytearray</code> \u4f7f\u7528 <code>bytes(v)</code> \u8f6c\u6362\uff0c<code>str</code> \u4f7f\u7528 <code>v.encode()</code> \u8f6c\u6362\uff0c<code>int</code>\u3001<code>float</code> \u548c <code>Decimal</code> \u662f \u4f7f\u7528 <code>str(v).encode()</code> \u5f3a\u5236 <code>list</code> \u5141\u8bb8 <code>list</code>\u3001<code>tuple</code>\u3001<code>set</code>\u3001<code>frozenset</code>\u3001<code>deque</code> \u6216\u751f\u6210\u5668\u548c\u8f6c\u6362\u4e3a\u5217\u8868\uff1b \u6709\u5173\u5b50\u7c7b\u578b\u7ea6\u675f\uff0c\u8bf7\u53c2\u89c1\u4e0b\u9762\u7684<code>typing.List</code> <code>tuple</code> \u5141\u8bb8 <code>list</code>\u3001<code>tuple</code>\u3001<code>set</code>\u3001<code>frozenset</code>\u3001<code>deque</code> \u6216\u751f\u6210\u5668\u548c\u8f6c\u6362\u4e3a\u5143\u7ec4\uff1b \u6709\u5173\u5b50\u7c7b\u578b\u7ea6\u675f\uff0c\u8bf7\u53c2\u89c1\u4e0b\u9762\u7684<code>typing.Tuple</code> <code>dict</code> <code>dict(v)</code> \u7528\u4e8e\u5c1d\u8bd5\u8f6c\u6362\u5b57\u5178\uff1b \u8bf7\u53c2\u9605\u4e0b\u9762\u7684 <code>typing.Dict</code> \u4e86\u89e3\u5b50\u7c7b\u578b\u7ea6\u675f <code>set</code> \u5141\u8bb8\u5c06 <code>list</code>\u3001<code>tuple</code>\u3001<code>set</code>\u3001<code>frozenset</code>\u3001<code>deque</code> \u6216\u751f\u6210\u5668\u548c\u5f3a\u5236\u8f6c\u6362\u4e3a\u4e00\u4e2a\u96c6\u5408\uff1b \u6709\u5173\u5b50\u7c7b\u578b\u7ea6\u675f\uff0c\u8bf7\u53c2\u89c1\u4e0b\u9762\u7684<code>typing.Set</code> <code>frozenset</code> \u5141\u8bb8 <code>list</code>\u3001<code>tuple</code>\u3001<code>set</code>\u3001<code>frozenset</code>\u3001<code>deque</code> \u6216\u751f\u6210\u5668\u548c\u5f3a\u5236\u8f6c\u6362\u4e3a\u51bb\u7ed3\u96c6\uff1b \u6709\u5173\u5b50\u7c7b\u578b\u7ea6\u675f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684<code>typing.FrozenSet</code> <code>deque</code> \u5141\u8bb8 <code>list</code>\u3001<code>tuple</code>\u3001<code>set</code>\u3001<code>frozenset</code>\u3001<code>deque</code> \u6216\u751f\u6210\u5668\u548c\u8f6c\u6362\u4e3a\u53cc\u7aef\u961f\u5217\uff1b \u6709\u5173\u5b50\u7c7b\u578b\u7ea6\u675f\uff0c\u8bf7\u53c2\u89c1\u4e0b\u9762\u7684<code>typing.Deque</code> <code>datetime.date</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Datetime Types <code>datetime.time</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Datetime Types <code>datetime.datetime</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Datetime Types <code>datetime.timedelta</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Datetime Types <code>typing.Any</code> \u5141\u8bb8\u4efb\u4f55\u503c\uff0c\u5305\u62ec<code>None</code>\uff0c\u56e0\u6b64<code>Any</code>\u5b57\u6bb5\u662f\u53ef\u9009\u7684 <code>typing.Annotated</code> \u6839\u636e PEP-593\uff0c\u5141\u8bb8\u4f7f\u7528\u4efb\u610f\u5143\u6570\u636e\u5305\u88c5\u53e6\u4e00\u79cd\u7c7b\u578b\u3002 <code>Annotated</code> \u63d0\u793a\u53ef\u80fd\u5305\u542b\u5bf9 <code>Field</code> \u51fd\u6570 \u7684\u5355\u4e2a\u8c03\u7528\uff0c\u4f46\u5176\u4ed6\u5143\u6570\u636e\u5c06\u88ab\u5ffd\u7565\u5e76\u4f7f\u7528\u6839\u7c7b\u578b\u3002 <code>typing.TypeVar</code> \u6839\u636e <code>constraints</code> \u6216 <code>bound</code> \u9650\u5236\u5141\u8bb8\u7684\u503c\uff0c\u53c2\u89c1 TypeVar <code>typing.Union</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Union <code>typing.Optional</code> <code>Optional[x]</code> \u53ea\u662f <code>Union[x, None]</code> \u7684\u7b80\u5199\uff1b \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Union\uff0c\u6709\u5173\u53ef\u4ee5\u63a5\u6536<code>None</code>\u4f5c\u4e3a\u503c\u7684\u5fc5\u586b\u5b57\u6bb5\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 Required Fields\u3002 <code>typing.List</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Typing Iterables <code>typing.Tuple</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Typing Iterables <code>subclass of typing.NamedTuple</code> \u4e0e <code>tuple</code> \u76f8\u540c\uff0c\u4f46\u4f7f\u7528\u7ed9\u5b9a\u7684 <code>namedtuple</code> \u5b9e\u4f8b\u5316\u5e76\u9a8c\u8bc1\u5b57\u6bb5\uff0c\u56e0\u4e3a\u5b83\u4eec\u662f\u5e26\u6ce8\u91ca\u7684\u3002 \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 \u6ce8\u91ca\u7c7b\u578b <code>subclass of collections.namedtuple</code> \u4e0e <code>subclass of typing.NamedTuple</code> \u76f8\u540c\uff0c\u4f46\u6240\u6709\u5b57\u6bb5\u90fd\u5c06\u5177\u6709 <code>Any</code> \u7c7b\u578b\uff0c\u56e0\u4e3a\u5b83\u4eec\u6ca1\u6709\u6ce8\u91ca <code>typing.Dict</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Typing Iterables <code>subclass of typing.TypedDict</code> \u4e0e <code>dict</code> \u76f8\u540c\uff0c\u4f46 pydantic \u5c06\u9a8c\u8bc1\u5b57\u5178\uff0c\u56e0\u4e3a\u952e\u88ab\u6ce8\u91ca\u4e86\u3002 \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 \u6ce8\u91ca\u7c7b\u578b <code>typing.Set</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Typing Iterables <code>typing.FrozenSet</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Typing Iterables <code>typing.Deque</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Typing Iterables <code>typing.Sequence</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Typing Iterables <code>typing.Iterable</code> \u8fd9\u662f\u4e3a\u4e0d\u5e94\u4f7f\u7528\u7684\u8fed\u4ee3\u5668\u4fdd\u7559\u7684\u3002 \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Infinite Generators <code>typing.Type</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Type <code>typing.Callable</code> \u6709\u5173\u89e3\u6790\u548c\u9a8c\u8bc1\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 Callable <code>typing.Pattern</code> \u5c06\u5bfc\u81f4\u8f93\u5165\u503c\u88ab\u4f20\u9012\u7ed9 <code>re.compile(v)</code> \u4ee5\u521b\u5efa\u6b63\u5219\u8868\u8fbe\u5f0f\u6a21\u5f0f <code>ipaddress.IPv4Address</code> \u901a\u8fc7\u5c06\u503c\u4f20\u9012\u7ed9 <code>IPv4Address(v)</code> \u6765\u7b80\u5355\u5730\u4f7f\u7528\u7c7b\u578b\u672c\u8eab\u8fdb\u884c\u9a8c\u8bc1\uff1b \u6709\u5173\u5176\u4ed6\u81ea\u5b9a\u4e49 IP \u5730\u5740\u7c7b\u578b\uff0c\u8bf7\u53c2\u9605 Pydantic Types <code>ipaddress.IPv4Interface</code> \u901a\u8fc7\u5c06\u503c\u4f20\u9012\u7ed9 <code>IPv4Address(v)</code> \u6765\u7b80\u5355\u5730\u4f7f\u7528\u7c7b\u578b\u672c\u8eab\u8fdb\u884c\u9a8c\u8bc1\uff1b \u6709\u5173\u5176\u4ed6\u81ea\u5b9a\u4e49 IP \u5730\u5740\u7c7b\u578b\uff0c\u8bf7\u53c2\u9605 Pydantic Types <code>ipaddress.IPv4Network</code> \u901a\u8fc7\u5c06\u503c\u4f20\u9012\u7ed9 <code>IPv4Network(v)</code> \u6765\u7b80\u5355\u5730\u4f7f\u7528\u7c7b\u578b\u672c\u8eab\u8fdb\u884c\u9a8c\u8bc1\uff1b \u6709\u5173\u5176\u4ed6\u81ea\u5b9a\u4e49 IP \u5730\u5740\u7c7b\u578b\uff0c\u8bf7\u53c2\u9605 Pydantic Types <code>ipaddress.IPv6Address</code> \u901a\u8fc7\u5c06\u503c\u4f20\u9012\u7ed9 <code>IPv6Address(v)</code> \u6765\u7b80\u5355\u5730\u4f7f\u7528\u7c7b\u578b\u672c\u8eab\u8fdb\u884c\u9a8c\u8bc1\uff1b \u6709\u5173\u5176\u4ed6\u81ea\u5b9a\u4e49 IP \u5730\u5740\u7c7b\u578b\uff0c\u8bf7\u53c2\u9605 Pydantic Types <code>ipaddress.IPv6Interface</code> \u901a\u8fc7\u5c06\u503c\u4f20\u9012\u7ed9 <code>IPv6Interface(v)</code> \u6765\u7b80\u5355\u5730\u4f7f\u7528\u7c7b\u578b\u672c\u8eab\u8fdb\u884c\u9a8c\u8bc1\uff1b \u6709\u5173\u5176\u4ed6\u81ea\u5b9a\u4e49 IP \u5730\u5740\u7c7b\u578b\uff0c\u8bf7\u53c2\u9605 Pydantic Types <code>ipaddress.IPv6Network</code> \u901a\u8fc7\u5c06\u503c\u4f20\u9012\u7ed9 <code>IPv6Network(v)</code> \u6765\u7b80\u5355\u5730\u4f7f\u7528\u7c7b\u578b\u672c\u8eab\u8fdb\u884c\u9a8c\u8bc1\uff1b \u6709\u5173\u5176\u4ed6\u81ea\u5b9a\u4e49 IP \u5730\u5740\u7c7b\u578b\uff0c\u8bf7\u53c2\u9605 Pydantic Types <code>enum.Enum</code> \u68c0\u67e5\u8be5\u503c\u662f\u5426\u4e3a\u6709\u6548\u7684 Enum \u5b9e\u4f8b <code>subclass of enum.Enum</code> \u68c0\u67e5\u8be5\u503c\u662f\u5426\u662f\u679a\u4e3e\u7684\u6709\u6548\u6210\u5458\uff1b \u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 \u679a\u4e3e\u548c\u9009\u62e9 <code>enum.IntEnum</code> \u68c0\u67e5\u8be5\u503c\u662f\u5426\u4e3a\u6709\u6548\u7684 IntEnum \u5b9e\u4f8b <code>subclass of enum.IntEnum</code> \u68c0\u67e5\u8be5\u503c\u662f\u5426\u662f\u6574\u6570\u679a\u4e3e\u7684\u6709\u6548\u6210\u5458\uff1b \u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 \u679a\u4e3e\u548c\u9009\u62e9 <code>decimal.Decimal</code> pydantic \u5c1d\u8bd5\u5c06\u503c\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u5c06\u5b57\u7b26\u4e32\u4f20\u9012\u7ed9\u201cDecimal(v)\u201d <code>pathlib.Path</code> \u901a\u8fc7\u5c06\u503c\u4f20\u9012\u7ed9 <code>Path(v)</code> \u6765\u7b80\u5355\u5730\u4f7f\u7528\u7c7b\u578b\u672c\u8eab\u8fdb\u884c\u9a8c\u8bc1\uff1b \u6709\u5173\u5176\u4ed6\u66f4\u4e25\u683c\u7684\u8def\u5f84\u7c7b\u578b\uff0c\u8bf7\u53c2\u9605 Pydantic Types <code>uuid.UUID</code> \u5b57\u7b26\u4e32\u548c\u5b57\u8282\uff08\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\uff09\u88ab\u4f20\u9012\u7ed9 <code>UUID(v)</code>\uff0c\u5bf9\u4e8e <code>bytes</code> \u548c <code>bytearray</code> \u56de\u9000\u5230 <code>UUID(bytes=v)</code>\uff1b \u6709\u5173\u5176\u4ed6\u66f4\u4e25\u683c\u7684 UUID \u7c7b\u578b\uff0c\u8bf7\u53c2\u9605 Pydantic Types <code>ByteSize</code> \u5c06\u5e26\u5355\u4f4d\u7684\u5b57\u8282\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u5b57\u8282"},{"location":"usage/types/#typing-iterables","title":"\u53ef\u8fed\u4ee3\u7c7b\u578b(Typing Iterables)","text":"<p>pydantic \u4f7f\u7528 PEP 484 \u4e2d\u5b9a\u4e49\u7684\u6807\u51c6\u5e93\u201c\u952e\u5165\u201d\u7c7b\u578b\u6765\u5b9a\u4e49\u590d\u6742\u5bf9\u8c61\u3002</p> <pre><code>from typing import (\n    Deque, Dict, FrozenSet, List, Optional, Sequence, Set, Tuple, Union\n)\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_list: list = None\n    list_of_ints: List[int] = None\n\n    simple_tuple: tuple = None\n    tuple_of_different_types: Tuple[int, float, str, bool] = None\n\n    simple_dict: dict = None\n    dict_str_float: Dict[str, float] = None\n\n    simple_set: set = None\n    set_bytes: Set[bytes] = None\n    frozen_set: FrozenSet[int] = None\n\n    str_or_bytes: Union[str, bytes] = None\n    none_or_str: Optional[str] = None\n\n    sequence_of_ints: Sequence[int] = None\n\n    compound: Dict[Union[str, bytes], List[Set[int]]] = None\n\n    deque: Deque[int] = None\n\n\nprint(Model(simple_list=['1', '2', '3']).simple_list)\nprint(Model(list_of_ints=['1', '2', '3']).list_of_ints)\n\nprint(Model(simple_dict={'a': 1, b'b': 2}).simple_dict)\nprint(Model(dict_str_float={'a': 1, b'b': 2}).dict_str_float)\n\nprint(Model(simple_tuple=[1, 2, 3, 4]).simple_tuple)\nprint(Model(tuple_of_different_types=[4, 3, 2, 1]).tuple_of_different_types)\n\nprint(Model(sequence_of_ints=[1, 2, 3, 4]).sequence_of_ints)\nprint(Model(sequence_of_ints=(1, 2, 3, 4)).sequence_of_ints)\n\nprint(Model(deque=[1, 2, 3]).deque)\n</code></pre>"},{"location":"usage/types/#infinite-generators","title":"\u65e0\u9650\u751f\u6210\u5668(Infinite Generators)","text":"<p>\u5982\u679c\u4f60\u6709\u4e00\u4e2a\u751f\u6210\u5668\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528\u4e0a\u9762\u63cf\u8ff0\u7684<code>Sequence</code>\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u751f\u6210\u5668\u5c06\u88ab\u4f7f\u7528\u5e76\u4f5c\u4e3a\u5217\u8868\u5b58\u50a8\u5728\u6a21\u578b\u4e2d\uff0c\u5176\u503c\u5c06\u4f7f\u7528<code>Sequence</code>\u7684\u5b50\u7c7b\u578b\uff08\u4f8b\u5982<code>Sequence[int]</code>\u4e2d\u7684<code>int</code>\uff09\u8fdb\u884c\u9a8c\u8bc1\u3002</p> <p>\u4f46\u662f\u5982\u679c\u4f60\u6709\u4e00\u4e2a\u4f60\u4e0d\u60f3\u88ab\u6d88\u8017\u7684\u751f\u6210\u5668\uff0c\u4f8b\u5982 \u65e0\u9650\u751f\u6210\u5668\u6216\u8fdc\u7a0b\u6570\u636e\u52a0\u8f7d\u5668\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>Iterable</code> \u5b9a\u4e49\u5176\u7c7b\u578b\uff1a</p> <pre><code>from typing import Iterable\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    infinite: Iterable[int]\n\n\ndef infinite_ints():\n    i = 0\n    while True:\n        yield i\n        i += 1\n\n\nm = Model(infinite=infinite_ints())\nprint(m)\n\nfor i in m.infinite:\n    print(i)\n    if i == 10:\n        break\n</code></pre> <p>Warning</p> <p><code>Iterable</code> \u5b57\u6bb5\u53ea\u6267\u884c\u4e00\u4e2a\u7b80\u5355\u7684\u68c0\u67e5\uff0c\u4ee5\u786e\u4fdd\u53c2\u6570\u662f\u53ef\u8fed\u4ee3\u7684\u5e76\u4e14\u4e0d\u4f1a\u88ab\u6d88\u8017\u3002</p> <p>\u4e0d\u4f1a\u5bf9\u5b83\u4eec\u7684\u503c\u8fdb\u884c\u9a8c\u8bc1\uff0c\u56e0\u4e3a\u5982\u679c\u4e0d\u4f7f\u7528\u53ef\u8fed\u4ee3\u5bf9\u8c61\u5c31\u65e0\u6cd5\u5b8c\u6210\u9a8c\u8bc1\u3002</p> <p>Tip</p> <p>\u5982\u679c\u60a8\u60f3\u9a8c\u8bc1\u65e0\u9650\u751f\u6210\u5668\u7684\u503c\uff0c\u60a8\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u5355\u72ec\u7684\u6a21\u578b\u5e76\u5728\u4f7f\u7528\u751f\u6210\u5668\u65f6\u4f7f\u7528\u5b83\uff0c\u5e76\u6839\u636e\u9700\u8981\u62a5\u544a\u9a8c\u8bc1\u9519\u8bef\u3002</p> <p>pydantic \u65e0\u6cd5\u81ea\u52a8\u4e3a\u60a8\u9a8c\u8bc1\u8fd9\u4e9b\u503c\uff0c\u56e0\u4e3a\u5b83\u9700\u8981\u4f7f\u7528\u65e0\u9650\u751f\u6210\u5668\u3002</p>"},{"location":"usage/types/#validating-the-first-value","title":"\u9a8c\u8bc1\u7b2c\u4e00\u4e2a\u503c(Validating the first value)","text":"<p>\u60a8\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a validator \u6765\u9a8c\u8bc1\u65e0\u9650\u751f\u6210\u5668\u4e2d\u7684\u7b2c\u4e00\u4e2a\u503c\uff0c\u4f46\u4ecd\u7136\u4e0d\u4f1a\u5b8c\u5168\u6d88\u8017\u5b83\u3002</p> <pre><code>import itertools\nfrom typing import Iterable\nfrom pydantic import BaseModel, validator, ValidationError\nfrom pydantic.fields import ModelField\n\n\nclass Model(BaseModel):\n    infinite: Iterable[int]\n\n    @validator('infinite')\n    # You don't need to add the \"ModelField\", but it will help your\n    # editor give you completion and catch errors\n    def infinite_first_int(cls, iterable, field: ModelField):\n        first_value = next(iterable)\n        if field.sub_fields:\n            # The Iterable had a parameter type, in this case it's int\n            # We use it to validate the first value\n            sub_field = field.sub_fields[0]\n            v, error = sub_field.validate(first_value, {}, loc='first_value')\n            if error:\n                raise ValidationError([error], cls)\n        # This creates a new generator that returns the first value and then\n        # the rest of the values from the (already started) iterable\n        return itertools.chain([first_value], iterable)\n\n\ndef infinite_ints():\n    i = 0\n    while True:\n        yield i\n        i += 1\n\n\nm = Model(infinite=infinite_ints())\nprint(m)\n\n\ndef infinite_strs():\n    while True:\n        yield from 'allthesingleladies'\n\n\ntry:\n    Model(infinite=infinite_strs())\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/types/#unions","title":"\u8054\u5408(Unions)","text":"<p><code>Union</code> \u7c7b\u578b\u5141\u8bb8\u6a21\u578b\u5c5e\u6027\u63a5\u53d7\u4e0d\u540c\u7684\u7c7b\u578b\uff0c\u4f8b\u5982\uff1a</p> <p>Info</p> <p>\u4f7f\u7528 <code>Union</code> \u53ef\u80fd\u4f1a\u5f97\u5230\u610f\u60f3\u4e0d\u5230\u7684\u5f3a\u5236\u8f6c\u6362\uff1b \u89c1\u4e0b\u6587\u3002</p> <p>\u4e0d\u8fc7\u60a8\u8fd8\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 \u667a\u80fd\u8054\u5408 \u4f7f\u68c0\u67e5\u66f4\u6162\u4f46\u66f4\u4e25\u683c</p> <pre><code>from uuid import UUID\nfrom typing import Union\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: Union[int, str, UUID]\n    name: str\n\n\nuser_01 = User(id=123, name='John Doe')\nprint(user_01)\nprint(user_01.id)\nuser_02 = User(id='1234', name='John Doe')\nprint(user_02)\nprint(user_02.id)\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\nprint(user_03.id)\nprint(user_03_uuid.int)\n</code></pre> <p>\u4f46\u662f\uff0c\u5982\u4e0a\u6240\u793a\uff0cpydantic \u5c06\u5c1d\u8bd5<code>match</code>\u5728 <code>Union</code> \u4e0b\u5b9a\u4e49\u7684\u4efb\u4f55\u7c7b\u578b\uff0c\u5e76\u5c06\u4f7f\u7528\u7b2c\u4e00\u4e2a\u5339\u914d\u7684\u7c7b\u578b\u3002 \u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c<code>user_03</code>\u7684<code>id</code>\u88ab\u5b9a\u4e49\u4e3a<code>uuid.UUID</code>\u7c7b\uff08\u5728\u5c5e\u6027\u7684 <code>Union</code> \u6ce8\u91ca\u4e0b\u5b9a\u4e49\uff09\uff0c\u4f46<code>uuid.UUID</code>\u53ef\u4ee5\u7f16\u7ec4\u4e3a<code>int</code> \u5b83\u9009\u62e9\u5339\u914d<code>int</code>\u7c7b\u578b\u5e76\u5ffd\u7565\u5176\u4ed6\u7c7b\u578b\u3002</p> <p>Warning</p> <p><code>typing.Union</code> \u5728 \u5b9a\u4e49 \u65f6\u4e5f\u4f1a\u5ffd\u7565\u987a\u5e8f\uff0c\u6240\u4ee5 <code>Union[int, float] == Union[float, int]</code> \u5f53\u4e0e\u57fa\u4e8e\u5176\u4ed6\u7c7b\u578b\u5b9a\u4e49\u4e2d\u7684 <code>Union</code> \u7c7b\u578b\u987a\u5e8f\u7684\u5339\u914d\u76f8\u7ed3\u5408\u65f6\uff0c\u4f8b\u5982 <code>List</code> \u548c <code>Dict</code> \u7c7b\u578b\uff08\u56e0\u4e3a Python \u5c06\u8fd9\u4e9b\u5b9a\u4e49\u89c6\u4e3a\u5355\u4f8b\uff09\u3002</p> <p>\u4f8b\u5982\uff0c<code>Dict[str, Union[int, float]] == Dict[str, Union[float, int]]</code> \u7684\u987a\u5e8f\u57fa\u4e8e\u7b2c\u4e00\u6b21\u5b9a\u4e49\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0c\u8fd9\u4e5f\u53ef\u80fd \u53d7\u7b2c\u4e09\u65b9\u5e93\u5f71\u54cd \u53ca\u5176\u5185\u90e8\u7c7b\u578b\u5b9a\u4e49\u548c\u5bfc\u5165\u987a\u5e8f\u3002</p> <p>\u56e0\u6b64\uff0c\u5efa\u8bae\u5728\u5b9a\u4e49 <code>Union</code> \u6ce8\u89e3\u65f6\uff0c\u9996\u5148\u5305\u542b\u6700\u5177\u4f53\u7684\u7c7b\u578b\uff0c\u7136\u540e\u662f\u4e0d\u592a\u5177\u4f53\u7684\u7c7b\u578b\u3002</p> <p>\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c<code>UUID</code> \u7c7b\u5e94\u8be5\u5728 <code>int</code> \u548c <code>str</code> \u7c7b\u4e4b\u524d\uff0c\u4ee5\u6392\u9664\u8fd9\u6837\u7684\u610f\u5916\u8868\u793a\uff1a</p> <pre><code>from uuid import UUID\nfrom typing import Union\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: Union[UUID, int, str]\n    name: str\n\n\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\nprint(user_03.id)\nprint(user_03_uuid.int)\n</code></pre> <p>Tip</p> <p><code>Optional[x]</code> \u7c7b\u578b\u662f <code>Union[x, None]</code> \u7684\u7b80\u5199\u3002</p> <p><code>Optional[x]</code> \u4e5f\u53ef\u7528\u4e8e\u6307\u5b9a\u4e00\u4e2a\u5fc5\u586b\u5b57\u6bb5\uff0c\u8be5\u5b57\u6bb5\u53ef\u4ee5\u5c06 <code>None</code> \u4f5c\u4e3a\u503c\u3002</p> <p>\u5728\u5fc5\u586b\u5b57\u6bb5 \u4e2d\u67e5\u770b\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\u3002</p>"},{"location":"usage/types/#discriminated-unions-aka-tagged-unions","title":"\u533a\u522b\u8054\u5408\u3010Discriminated Unions (a.k.a. Tagged Unions)\u3011","text":"<p>\u5f53 <code>Union</code> \u4e0e\u591a\u4e2a\u5b50\u6a21\u578b\u4e00\u8d77\u4f7f\u7528\u65f6\uff0c\u60a8\u6709\u65f6\u4f1a\u786e\u5207\u5730\u77e5\u9053\u9700\u8981\u68c0\u67e5\u548c\u9a8c\u8bc1\u54ea\u4e2a\u5b50\u6a21\u578b\u5e76\u5e0c\u671b\u5f3a\u5236\u6267\u884c\u6b64\u64cd\u4f5c\u3002</p> <p>\u4e3a\u6b64\uff0c\u60a8\u53ef\u4ee5\u5728\u6bcf\u4e2a\u5177\u6709\u5224\u522b\u503c\u7684\u5b50\u6a21\u578b\u4e2d\u8bbe\u7f6e\u76f8\u540c\u7684\u5b57\u6bb5 - \u8ba9\u6211\u4eec\u79f0\u4e4b\u4e3a <code>my_discriminator</code>\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u6216\u591a\u4e2a\uff09<code>Literal</code>\u503c\u3002</p> <p>\u5bf9\u4e8e\u60a8\u7684 <code>Union</code>\uff0c\u60a8\u53ef\u4ee5\u5728\u5176\u503c\u4e2d\u8bbe\u7f6e\u9274\u522b\u5668\uff1a<code>Field(discriminator='my_discriminator')</code>\u3002</p> <p>\u5efa\u7acb\u53d7\u6b67\u89c6\u7684\u5de5\u4f1a\u6709\u5f88\u591a\u597d\u5904\uff1a</p> <ul> <li>\u9a8c\u8bc1\u901f\u5ea6\u66f4\u5feb\uff0c\u56e0\u4e3a\u5b83\u53ea\u9488\u5bf9\u4e00\u4e2a\u6a21\u578b\u8fdb\u884c\u5c1d\u8bd5</li> <li>\u5931\u8d25\u65f6\u4ec5\u5f15\u53d1\u4e00\u4e2a\u663e\u5f0f\u9519\u8bef</li> <li>\u751f\u6210\u7684 JSON \u6a21\u5f0f\u5b9e\u73b0\u4e86\u76f8\u5173\u7684 OpenAPI \u89c4\u8303</li> </ul> <pre><code>from typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    meows: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    barks: float\n\n\nclass Lizard(BaseModel):\n    pet_type: Literal['reptile', 'lizard']\n    scales: bool\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n    n: int\n\n\nprint(Model(pet={'pet_type': 'dog', 'barks': 3.14}, n=1))\ntry:\n    Model(pet={'pet_type': 'dog'}, n=1)\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>Note</p> <p>\u4f7f\u7528 Annotated Fields syntax \u53ef\u4ee5\u65b9\u4fbf\u5730\u91cd\u65b0\u7ec4\u5408 <code>Union</code> \u548c <code>discriminator</code> \u4fe1\u606f\u3002 \u8bf7\u53c2\u9605\u4e0b\u9762\u7684\u793a\u4f8b\uff01</p> <p>Warning</p> <p>\u533a\u522b\u8054\u5408\u4e0d\u80fd\u4ec5\u4e0e\u5355\u4e2a\u53d8\u4f53\u4e00\u8d77\u4f7f\u7528\uff0c\u4f8b\u5982 <code>Union[Cat]</code>\u3002</p> <p>Python \u5728\u89e3\u91ca\u65f6\u5c06 <code>Union[T]</code> \u66f4\u6539\u4e3a <code>T</code>\uff0c\u56e0\u6b64 <code>pydantic</code> \u65e0\u6cd5\u533a\u5206 <code>Union[T]</code> \u548c <code>T</code> \u7684\u5b57\u6bb5\u3002</p>"},{"location":"usage/types/#nested-discriminated-unions","title":"\u5d4c\u5957\u7684\u533a\u522b\u8054\u5408(Nested Discriminated Unions)","text":"<p>\u4e00\u4e2a\u5b57\u6bb5\u53ea\u80fd\u8bbe\u7f6e\u4e00\u4e2a\u9274\u522b\u5668(discriminator)\uff0c\u4f46\u6709\u65f6\u4f60\u60f3\u7ec4\u5408\u591a\u4e2a\u9274\u522b\u5668(discriminator)\u3002</p> <p>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u59cb\u7ec8\u53ef\u4ee5\u4f7f\u7528 <code>__root__</code> \u521b\u5efa\u201c\u4e2d\u95f4(intermediate)\u201d\u6a21\u578b\u5e76\u6dfb\u52a0\u9274\u522b\u5668\u3002</p> <pre><code>from typing import Literal, Union\n\nfrom typing_extensions import Annotated\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['black']\n    black_name: str\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['white']\n    white_name: str\n\n\n# Can also be written with a custom root type\n#\n# class Cat(BaseModel):\n#   __root__: Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\nCat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    name: str\n\n\nPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n\nclass Model(BaseModel):\n    pet: Pet\n    n: int\n\n\nm = Model(pet={'pet_type': 'cat', 'color': 'black', 'black_name': 'felix'}, n=1)\nprint(m)\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'red'}, n='1')\nexcept ValidationError as e:\n    print(e)\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'black'}, n='1')\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/types/#enums-and-choices","title":"\u679a\u4e3e\u548c\u9009\u62e9(Enums and Choices)","text":"<p>pydantic \u4f7f\u7528 Python \u7684\u6807\u51c6<code>enum</code>\u7c7b\u6765\u5b9a\u4e49\u9009\u62e9\u3002</p> <pre><code>from enum import Enum, IntEnum\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass FruitEnum(str, Enum):\n    pear = 'pear'\n    banana = 'banana'\n\n\nclass ToolEnum(IntEnum):\n    spanner = 1\n    wrench = 2\n\n\nclass CookingModel(BaseModel):\n    fruit: FruitEnum = FruitEnum.pear\n    tool: ToolEnum = ToolEnum.spanner\n\n\nprint(CookingModel())\nprint(CookingModel(tool=2, fruit='banana'))\ntry:\n    CookingModel(fruit='other')\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/types/#datetime-types","title":"\u65e5\u671f\u65f6\u95f4\u7c7b\u578b(Datetime Types)","text":"<p>Pydantic \u652f\u6301\u4ee5\u4e0b datetime \u7c7b\u578b\uff1a</p> <ul> <li> <p><code>datetime</code> \u5b57\u6bb5\u53ef\u4ee5\u662f:</p> <ul> <li><code>datetime</code>\uff0c\u73b0\u6709\u7684 <code>datetime</code> \u5bf9\u8c61</li> <li><code>int</code> \u6216 <code>float</code>\uff0c\u5047\u5b9a\u4e3a Unix \u65f6\u95f4\uff0c\u5373\u81ea 1970 \u5e74 1 \u6708 1 \u65e5\u4ee5\u6765\u7684\u79d2\u6570\uff08\u5982\u679c &gt;= <code>-2e10</code> \u6216 &lt;= <code>2e10</code>\uff09\u6216\u6beb\u79d2\uff08\u5982\u679c &lt; <code>-2e10</code> \u6216 &gt; <code>2e10</code>\uff09</li> <li> <p><code>str</code>, \u4ee5\u4e0b\u683c\u5f0f\u6709\u6548\uff1a</p> <ul> <li><code>YYYY-MM-DD[T]HH:MM[:SS[.ffffff]][Z or [\u00b1]HH[:]MM]</code></li> <li><code>int</code> \u6216 <code>float</code> \u4f5c\u4e3a\u5b57\u7b26\u4e32\uff08\u5047\u5b9a\u4e3a Unix \u65f6\u95f4\uff09</li> </ul> </li> </ul> </li> </ul> <ul> <li> <p><code>date</code> \u5b57\u6bb5\u53ef\u4ee5\u662f:</p> <ul> <li><code>date</code>, \u73b0\u6709\u7684 <code>date</code> \u5bf9\u8c61</li> <li><code>int</code> \u6216 <code>float</code>, \u89c1 <code>datetime</code></li> <li> <p><code>str</code>, \u4ee5\u4e0b\u683c\u5f0f\u6709\u6548\uff1a</p> <ul> <li><code>YYYY-MM-DD</code></li> <li><code>int</code> \u6216 <code>float</code>, \u89c1 <code>datetime</code></li> </ul> </li> </ul> </li> </ul> <ul> <li> <p><code>time</code> \u5b57\u6bb5\u53ef\u4ee5\u662f:</p> <ul> <li><code>time</code>, \u73b0\u6709\u7684 <code>time</code> \u5bf9\u8c61</li> <li> <p><code>str</code>, \u4ee5\u4e0b\u683c\u5f0f\u6709\u6548\uff1a</p> <ul> <li><code>HH:MM[:SS[.ffffff]][Z or [\u00b1]HH[:]MM]</code></li> </ul> </li> </ul> </li> </ul> <ul> <li> <p><code>timedelta</code> \u5b57\u6bb5\u53ef\u4ee5\u662f:</p> <ul> <li><code>timedelta</code>, \u73b0\u6709\u7684 <code>timedelta</code> \u5bf9\u8c61</li> <li><code>int</code> \u6216 <code>float</code>, \u5047\u5b9a\u4e3a\u79d2</li> <li> <p><code>str</code>, \u4ee5\u4e0b\u683c\u5f0f\u6709\u6548\uff1a</p> <ul> <li><code>[-][DD ][HH:MM]SS[.ffffff]</code></li> <li><code>[\u00b1]P[DD]DT[HH]H[MM]M[SS]S</code> (ISO 8601 timedelta \u7684\u683c\u5f0f)</li> </ul> </li> </ul> </li> </ul> <pre><code>from datetime import date, datetime, time, timedelta\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    d: date = None\n    dt: datetime = None\n    t: time = None\n    td: timedelta = None\n\n\nm = Model(\n    d=1966280412345.6789,\n    dt='2032-04-23T10:20:30.400+02:30',\n    t=time(4, 8, 16),\n    td='P3DT12H30M5S',\n)\n\nprint(m.dict())\n</code></pre>"},{"location":"usage/types/#booleans","title":"\u5e03\u5c14\u7c7b\u578b(Booleans)","text":"<p>Warning</p> <p>\u4ece v1.0 \u7248\u672c\u5f00\u59cb\uff0c\u89e3\u6790 <code>bool</code> \u5b57\u6bb5\u7684\u903b\u8f91\u53d1\u751f\u4e86\u53d8\u5316\u3002</p> <p>\u5728 v1.0 \u4e4b\u524d\uff0c<code>bool</code> \u89e3\u6790\u4ece\u672a\u5931\u8d25\uff0c\u5bfc\u81f4\u4e00\u4e9b\u610f\u5916\u7ed3\u679c\u3002</p> <p>\u65b0\u903b\u8f91\u5982\u4e0b\u6240\u8ff0\u3002</p> <p>\u5982\u679c\u503c\u4e0d\u662f\u4ee5\u4e0b\u4e4b\u4e00\uff0c\u6807\u51c6\u7684 <code>bool</code> \u5b57\u6bb5\u5c06\u5f15\u53d1 <code>ValidationError</code>\uff1a</p> <ul> <li>\u4e00\u4e2a\u6709\u6548\u7684\u5e03\u5c14\u503c\uff08\u5373<code>True</code>\u6216<code>False</code>\uff09\uff0c</li> <li>\u6574\u6570<code>0</code>\u6216<code>1</code>\uff0c</li> <li>\u4e00\u4e2a <code>str</code> \uff0c\u5f53\u8f6c\u6362\u4e3a\u5c0f\u5199\u65f6\uff0c\u5b83\u662f\u5176\u4e2d\u4e4b\u4e00   <code>'0', 'off', 'f', 'false', 'n', 'no', '1', 'on', 't', 'true', 'y', 'yes'</code></li> <li>\u89e3\u7801\u4e3a <code>str</code> \u65f6\u6709\u6548\uff08\u6839\u636e\u524d\u9762\u7684\u89c4\u5219\uff09\u7684 <code>bytes</code></li> </ul> <p>Note</p> <p>\u5982\u679c\u4f60\u60f3\u8981\u66f4\u4e25\u683c\u7684\u5e03\u5c14\u903b\u8f91\uff08\u4f8b\u5982\uff0c\u4e00\u4e2a\u53ea\u5141\u8bb8 <code>True</code> \u548c <code>False</code> \u7684\u5b57\u6bb5\uff09\u4f60\u53ef\u4ee5\u4f7f\u7528 <code>StrictBool</code>\u3002</p> <p>\u8fd9\u662f\u4e00\u4e2a\u6f14\u793a\u5176\u4e2d\u4e00\u4e9b\u884c\u4e3a\u7684\u811a\u672c\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass BooleanModel(BaseModel):\n    bool_value: bool\n\n\nprint(BooleanModel(bool_value=False))\nprint(BooleanModel(bool_value='False'))\ntry:\n    BooleanModel(bool_value=[])\nexcept ValidationError as e:\n    print(str(e))\n</code></pre>"},{"location":"usage/types/#callable","title":"\u53ef\u8c03\u7528\u7c7b\u578b(Callable)","text":"<p>\u5b57\u6bb5\u4e5f\u53ef\u4ee5\u662f <code>Callable</code> \u7c7b\u578b\uff1a</p> <pre><code>from typing import Callable\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    callback: Callable[[int], int]\n\n\nm = Foo(callback=lambda x: x)\nprint(m)\n</code></pre> <p>Warning</p> <p>\u53ef\u8c03\u7528\u5b57\u6bb5\u4ec5\u6267\u884c\u7b80\u5355\u68c0\u67e5\u53c2\u6570\u662f\u5426\u53ef\u8c03\u7528\uff1b \u4e0d\u6267\u884c\u53c2\u6570\u3001\u5b83\u4eec\u7684\u7c7b\u578b\u6216\u8fd4\u56de\u7c7b\u578b\u7684\u9a8c\u8bc1\u3002</p>"},{"location":"usage/types/#type","title":"\u7c7b\u578b(Type)","text":"<p>pydantic \u652f\u6301\u4f7f\u7528 <code>Type[T]</code> \u6765\u6307\u5b9a\u5b57\u6bb5\u53ea\u80fd\u63a5\u53d7\u4f5c\u4e3a <code>T</code> \u5b50\u7c7b\u7684\u7c7b\uff08\u800c\u4e0d\u662f\u5b9e\u4f8b\uff09\u3002</p> <pre><code>from typing import Type\n\nfrom pydantic import BaseModel\nfrom pydantic import ValidationError\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Other:\n    pass\n\n\nclass SimpleModel(BaseModel):\n    just_subclasses: Type[Foo]\n\n\nSimpleModel(just_subclasses=Foo)\nSimpleModel(just_subclasses=Bar)\ntry:\n    SimpleModel(just_subclasses=Other)\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u4f7f\u7528 <code>Type</code> \u6765\u6307\u5b9a\u5141\u8bb8\u4f7f\u7528\u4efb\u4f55\u7c7b\u3002</p> <pre><code># dont-upgrade\nfrom typing import Type\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo:\n    pass\n\n\nclass LenientSimpleModel(BaseModel):\n    any_class_goes: Type\n\n\nLenientSimpleModel(any_class_goes=int)\nLenientSimpleModel(any_class_goes=Foo)\ntry:\n    LenientSimpleModel(any_class_goes=Foo())\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/types/#typevar","title":"\u7c7b\u578b\u58f0\u660e(TypeVar)","text":"<p><code>TypeVar</code> \u652f\u6301\u4e0d\u53d7\u7ea6\u675f\u3001\u53d7\u7ea6\u675f\u6216\u6709\u754c\u9650\u3002</p> <pre><code>from typing import TypeVar\nfrom pydantic import BaseModel\n\nFoobar = TypeVar('Foobar')\nBoundFloat = TypeVar('BoundFloat', bound=float)\nIntStr = TypeVar('IntStr', int, str)\n\n\nclass Model(BaseModel):\n    a: Foobar  # equivalent of \": Any\"\n    b: BoundFloat  # equivalent of \": float\"\n    c: IntStr  # equivalent of \": Union[int, str]\"\n\n\nprint(Model(a=[1], b=4.2, c='x'))\n\n# a may be None and is therefore optional\nprint(Model(b=1, c=1))\n</code></pre>"},{"location":"usage/types/#literal-type","title":"\u6587\u5b57\u7c7b\u578b(Literal Type)","text":"<p>Note</p> <p>\u8fd9\u662f\u4ece Python 3.8 \u5f00\u59cb\u7684 Python \u6807\u51c6\u5e93\u7684\u4e00\u4e2a\u65b0\u7279\u6027\uff1b \u5728 Python 3.8 \u4e4b\u524d\uff0c\u5b83\u9700\u8981 typing-extensions \u5305\u3002</p> <p>pydantic \u652f\u6301\u4f7f\u7528 <code>typing.Literal</code>\uff08\u6216 Python 3.8 \u4e4b\u524d\u7684 <code>typing_extensions.Literal</code>\uff09\u4f5c\u4e3a\u4e00\u79cd\u8f7b\u91cf\u7ea7\u7684\u65b9\u5f0f\u6765\u6307\u5b9a\u4e00\u4e2a\u5b57\u6bb5\u53ea\u80fd\u63a5\u53d7\u7279\u5b9a\u7684\u6587\u5b57\u503c\uff1a</p> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Pie(BaseModel):\n    flavor: Literal['apple', 'pumpkin']\n\n\nPie(flavor='apple')\nPie(flavor='pumpkin')\ntry:\n    Pie(flavor='cherry')\nexcept ValidationError as e:\n    print(str(e))\n</code></pre> <p>\u8fd9\u79cd\u5b57\u6bb5\u7c7b\u578b\u7684\u4e00\u4e2a\u597d\u5904\u662f\u5b83\u53ef\u4ee5\u7528\u6765\u68c0\u67e5\u4e00\u4e2a\u6216\u591a\u4e2a\u7279\u5b9a\u503c\u662f\u5426\u76f8\u7b49\uff0c\u800c\u65e0\u9700\u58f0\u660e\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\uff1a</p> <pre><code>from typing import ClassVar, List, Union\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Cake(BaseModel):\n    kind: Literal['cake']\n    required_utensils: ClassVar[List[str]] = ['fork', 'knife']\n\n\nclass IceCream(BaseModel):\n    kind: Literal['icecream']\n    required_utensils: ClassVar[List[str]] = ['spoon']\n\n\nclass Meal(BaseModel):\n    dessert: Union[Cake, IceCream]\n\n\nprint(type(Meal(dessert={'kind': 'cake'}).dessert).__name__)\nprint(type(Meal(dessert={'kind': 'icecream'}).dessert).__name__)\ntry:\n    Meal(dessert={'kind': 'pie'})\nexcept ValidationError as e:\n    print(str(e))\n</code></pre> <p>\u901a\u8fc7\u5728\u5e26\u6ce8\u91ca\u7684 <code>Union</code> \u4e2d\u6b63\u786e\u6392\u5e8f\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u5b83\u6765\u89e3\u6790\u9012\u51cf\u7279\u5f02\u6027\u7684\u7c7b\u578b\uff1a</p> <pre><code>from typing import Optional, Union\n\nfrom typing import Literal\n\nfrom pydantic import BaseModel\n\n\nclass Dessert(BaseModel):\n    kind: str\n\n\nclass Pie(Dessert):\n    kind: Literal['pie']\n    flavor: Optional[str]\n\n\nclass ApplePie(Pie):\n    flavor: Literal['apple']\n\n\nclass PumpkinPie(Pie):\n    flavor: Literal['pumpkin']\n\n\nclass Meal(BaseModel):\n    dessert: Union[ApplePie, PumpkinPie, Pie, Dessert]\n\n\nprint(type(Meal(dessert={'kind': 'pie', 'flavor': 'apple'}).dessert).__name__)\nprint(type(Meal(dessert={'kind': 'pie', 'flavor': 'pumpkin'}).dessert).__name__)\nprint(type(Meal(dessert={'kind': 'pie'}).dessert).__name__)\nprint(type(Meal(dessert={'kind': 'cake'}).dessert).__name__)\n</code></pre>"},{"location":"usage/types/#annotated-types","title":"\u5df2\u6ce8\u89e3\u7c7b\u578b(Annotated Types)","text":""},{"location":"usage/types/#namedtuple","title":"\u547d\u540d\u5143\u7ec4(NamedTuple)","text":"<pre><code>from typing import NamedTuple\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n\n\nclass Model(BaseModel):\n    p: Point\n\n\nprint(Model(p=('1', '2')))\n\ntry:\n    Model(p=('1.3', '2'))\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/types/#typeddict","title":"\u6807\u8bb0\u7c7b\u578b\u5b57\u5178(TypedDict)","text":"<p>Note</p> <p>\u8fd9\u662f\u4ece Python 3.8 \u5f00\u59cb\u7684 Python \u6807\u51c6\u5e93\u7684\u4e00\u4e2a\u65b0\u7279\u6027\u3002 \u5728 Python 3.8 \u4e4b\u524d\uff0c\u5b83\u9700\u8981 typing-extensions \u5305\u3002</p> <p>\u4f46\u4ec5\u81ea Python 3.9 \u8d77\u624d\u6b63\u786e\u533a\u5206\u5fc5\u586b\u5b57\u6bb5\u548c\u53ef\u9009\u5b57\u6bb5\u3002</p> <p>\u56e0\u6b64\uff0c\u6211\u4eec\u5efa\u8bae\u5728 Python 3.8 \u4e2d\u4e5f\u4f7f\u7528 typing-extensions\u3002</p> <pre><code>from typing_extensions import TypedDict\n\nfrom pydantic import BaseModel, Extra, ValidationError\n\n\n# `total=False` means keys are non-required\nclass UserIdentity(TypedDict, total=False):\n    name: str\n    surname: str\n\n\nclass User(TypedDict):\n    identity: UserIdentity\n    age: int\n\n\nclass Model(BaseModel):\n    u: User\n\n    class Config:\n        extra = Extra.forbid\n\n\nprint(Model(u={'identity': {'name': 'Smith', 'surname': 'John'}, 'age': '37'}))\n\nprint(Model(u={'identity': {'name': None, 'surname': 'John'}, 'age': '37'}))\n\nprint(Model(u={'identity': {}, 'age': '37'}))\n\n\ntry:\n    Model(u={'identity': {'name': ['Smith'], 'surname': 'John'}, 'age': '24'})\nexcept ValidationError as e:\n    print(e)\n\ntry:\n    Model(\n        u={\n            'identity': {'name': 'Smith', 'surname': 'John'},\n            'age': '37',\n            'email': 'john.smith@me.com',\n        }\n    )\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/types/#pydanticpydantic-types","title":"Pydantic\u7279\u6709\u7c7b\u578b(Pydantic Types)","text":"<p>pydantic \u8fd8\u63d0\u4f9b\u4e86\u591a\u79cd\u5176\u4ed6\u6709\u7528\u7684\u7c7b\u578b\uff1a</p> <code>FilePath</code> \u7c7b\u4f3c <code>Path</code>, \u4f46\u8def\u5f84\u5fc5\u987b\u5b58\u5728\u5e76\u4e14\u662f\u4e00\u4e2a\u6587\u4ef6 <code>DirectoryPath</code> \u7c7b\u4f3c <code>Path</code>, \u4f46\u8def\u5f84\u5fc5\u987b\u5b58\u5728\u5e76\u4e14\u662f\u4e00\u4e2a\u76ee\u5f55 <code>PastDate</code> \u7c7b\u4f3c <code>date</code>, \u4f46\u65e5\u671f\u5e94\u8be5\u662f\u8fc7\u53bb\u7684 <code>FutureDate</code> \u7c7b\u4f3c <code>date</code>, \u4f46\u65e5\u671f\u5e94\u8be5\u5728\u672a\u6765 <code>EmailStr</code> \u9700\u8981\u5b89\u88c5 email-validator\uff1b \u8f93\u5165\u5b57\u7b26\u4e32\u5fc5\u987b\u662f\u4e00\u4e2a\u6709\u6548\u7684\u7535\u5b50\u90ae\u4ef6\u5730\u5740\uff0c\u8f93\u51fa\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u5b57\u7b26\u4e32 <code>NameEmail</code> <p>\u9700\u8981\u5b89\u88c5 email-validator\uff1b</p> <p>\u8f93\u5165\u5b57\u7b26\u4e32\u5fc5\u987b\u662f\u6709\u6548\u7684\u7535\u5b50\u90ae\u4ef6\u5730\u5740\u6216\u683c\u5f0f\u4e3a<code>Fred Bloggs &lt;fred.bloggs@example.com&gt;</code>\uff0c\u8f93\u51fa\u662f\u4e00\u4e2a <code>NameEmail</code> \u5bf9\u8c61\uff0c\u5b83\u5177\u6709\u4e24\u4e2a\u5c5e\u6027\uff1a<code>name</code> \u548c <code>email</code>\u3002</p> <p>\u5bf9\u4e8e <code>Fred Bloggs &lt;fred.bloggs@example.com&gt;</code>\uff0c\u540d\u79f0\u5c06\u662f <code>Fred Bloggs</code>\uff1b</p> <p>\u5bf9\u4e8e <code>fred.bloggs@example.com</code>\uff0c\u5b83\u5c06\u662f <code>fred.bloggs</code>\u3002</p> <code>PyObject</code> \u9700\u8981\u4e00\u4e2a\u5b57\u7b26\u4e32\u5e76\u52a0\u8f7d\u5728\u8be5\u4e0b\u5212\u7ebf\u8def\u5f84\u4e2d\u53ef\u5bfc\u5165\u7684 Python \u5bf9\u8c61\uff1b \u4f8b\u5982 \u5982\u679c\u63d0\u4f9b\u4e86 <code>math.cos</code>\uff0c\u5219\u7ed3\u679c\u5b57\u6bb5\u503c\u5c06\u662f\u51fd\u6570 <code>cos</code> <code>Color</code> \u7528\u4e8e\u89e3\u6790 HTML \u548c CSS \u989c\u8272\uff1b \u53c2\u89c1\u989c\u8272\u7c7b\u578b <code>Json</code> \u5728\u89e3\u6790\u4e4b\u524d\u52a0\u8f7d JSON \u7684\u7279\u6b8a\u7c7b\u578b\u5305\u88c5\u5668\uff1b \u53c2\u89c1 JSON \u7c7b\u578b <code>PaymentCardNumber</code> \u7528\u4e8e\u89e3\u6790\u548c\u9a8c\u8bc1\u652f\u4ed8\u5361\uff1b \u53c2\u89c1\u652f\u4ed8\u5361 <code>AnyUrl</code> \u4efb\u4f55\u7f51\u5740\uff1b \u53c2\u89c1 URL <code>AnyHttpUrl</code> \u4e00\u4e2a HTTP \u7f51\u5740\uff1b \u53c2\u89c1 URL <code>HttpUrl</code> \u66f4\u4e25\u683c\u7684 HTTP URL\uff1b \u53c2\u89c1 URL <code>FileUrl</code> \u6587\u4ef6\u8def\u5f84 URL\uff1b \u53c2\u89c1 URL <code>PostgresDsn</code> \u6587\u4ef6\u8def\u5f84 URL\uff1b \u53c2\u89c1 URL <code>CockroachDsn</code> cockroachdb DSN \u6837\u5f0f\u7684 URL\uff1b \u53c2\u89c1 URL <code>AmqpDsn</code> RabbitMQ\u3001StormMQ\u3001ActiveMQ \u7b49\u4f7f\u7528\u7684 <code>AMQP</code> DSN \u6837\u5f0f URL\uff1b \u53c2\u89c1 URL <code>RedisDsn</code> \u4e00\u4e2a redis DSN \u6837\u5f0f\u7684 URL\uff1b \u53c2\u89c1 URL <code>MongoDsn</code> \u4e00\u4e2a MongoDB DSN \u6837\u5f0f\u7684 URL\uff1b \u53c2\u89c1 URL <code>KafkaDsn</code> kafka DSN \u6837\u5f0f\u7684 URL\uff1b \u53c2\u89c1 URL <code>stricturl</code> \u4efb\u610f URL \u7ea6\u675f\u7684\u7c7b\u578b\u65b9\u6cd5\uff1b \u53c2\u89c1 URL <code>UUID1</code> \u9700\u8981\u7c7b\u578b 1 \u7684\u6709\u6548 UUID; \u53c2\u89c1 <code>UUID</code> above <code>UUID3</code> \u9700\u8981\u7c7b\u578b 3 \u7684\u6709\u6548 UUID; \u53c2\u89c1 <code>UUID</code> above <code>UUID4</code> \u9700\u8981\u7c7b\u578b 4 \u7684\u6709\u6548 UUID; \u53c2\u89c1 <code>UUID</code> above <code>UUID5</code> \u9700\u8981\u7c7b\u578b 5 \u7684\u6709\u6548 UUID; \u53c2\u89c1 <code>UUID</code> above <code>SecretBytes</code> \u503c\u90e8\u5206\u4fdd\u5bc6\u7684\u5b57\u8282; \u53c2\u89c1 Secrets <code>SecretStr</code> \u503c\u90e8\u5206\u4fdd\u5bc6\u7684\u5b57\u7b26\u4e32; \u53c2\u89c1 Secrets <code>IPvAnyAddress</code> \u5141\u8bb8 <code>IPv4Address</code> \u6216 <code>IPv6Address</code> <code>IPvAnyInterface</code> \u5141\u8bb8 <code>IPv4Interface</code> \u6216 <code>IPv6Interface</code> <code>IPvAnyNetwork</code> \u5141\u8bb8 <code>IPv4Network</code> \u6216 <code>IPv6Network</code> <code>NegativeFloat</code> \u5141\u8bb8\u4e00\u4e2a\u8d1f\u6570\u7684\u6d6e\u70b9\u6570\uff1b \u4f7f\u7528\u6807\u51c6\u7684 <code>float</code> \u89e3\u6790\u7136\u540e\u68c0\u67e5\u503c\u662f\u5426\u5c0f\u4e8e 0\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>NegativeInt</code> \u5141\u8bb8\u4e00\u4e2a\u8d1f\u6570\u7684\u6574\u6570\uff1b \u4f7f\u7528\u6807\u51c6\u7684 <code>int</code> \u89e3\u6790\u7136\u540e\u68c0\u67e5\u503c\u662f\u5426\u5c0f\u4e8e 0\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>PositiveFloat</code> \u5141\u8bb8\u4e00\u4e2a\u6b63\u7684\u6d6e\u70b9\u6570\uff1b \u4f7f\u7528\u6807\u51c6\u7684 <code>float</code> \u89e3\u6790\u7136\u540e\u68c0\u67e5\u503c\u662f\u5426\u5927\u4e8e 0\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>PositiveInt</code> \u5141\u8bb8\u4e00\u4e2a\u6b63\u6574\u6570\uff1b \u4f7f\u7528\u6807\u51c6\u7684 <code>int</code> \u89e3\u6790\u7136\u540e\u68c0\u67e5\u503c\u662f\u5426\u5927\u4e8e 0\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>conbytes</code> \u7528\u4e8e\u7ea6\u675f\u5b57\u8282\u7684\u7c7b\u578b\u65b9\u6cd5\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>condecimal</code> \u7528\u4e8e\u7ea6\u675f Decimals \u7684\u7c7b\u578b\u65b9\u6cd5\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>confloat</code> \u7528\u4e8e\u7ea6\u675f\u6d6e\u70b9\u6570\u7684\u7c7b\u578b\u65b9\u6cd5\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>conint</code> \u7528\u4e8e\u7ea6\u675f\u6574\u6570\u7684\u7c7b\u578b\u65b9\u6cd5\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>condate</code> \u9650\u5236\u65e5\u671f\u7684\u7c7b\u578b\u65b9\u6cd5\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>conlist</code> \u7528\u4e8e\u7ea6\u675f\u5217\u8868\u7684\u7c7b\u578b\u65b9\u6cd5\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>conset</code> \u7ea6\u675f\u96c6\u7684\u7c7b\u578b\u65b9\u6cd5\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>confrozenset</code> \u7528\u4e8e\u7ea6\u675f\u51bb\u7ed3\u96c6\u7684\u7c7b\u578b\u65b9\u6cd5\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b <code>constr</code> \u7528\u4e8e\u7ea6\u675f \u5b57\u7b26\u4e32 \u7684\u7c7b\u578b\u65b9\u6cd5\uff1b \u53c2\u89c1 \u7ea6\u675f\u7c7b\u578b"},{"location":"usage/types/#urls","title":"\u94fe\u63a5\u7c7b\u578b(URLs)","text":"<p>\u5bf9\u4e8e URI/URL \u9a8c\u8bc1\uff0c\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u7c7b\u578b\uff1a</p> <ul> <li><code>AnyUrl</code>: \u5141\u8bb8\u4efb\u4f55\u65b9\u6848\uff0c\u4e0d\u9700\u8981 TLD\uff0c\u9700\u8981\u4e3b\u673a\u5730\u5740</li> <li><code>AnyHttpUrl</code>: \u65b9\u6848 <code>http</code> \u6216 <code>https</code>\uff0c\u4e0d\u9700\u8981 TLD\uff0c\u9700\u8981\u4e3b\u673a\u5730\u5740</li> <li><code>HttpUrl</code>: \u65b9\u6848 <code>http</code> \u6216 <code>https</code>\uff0c\u9700\u8981 TLD\uff0c\u9700\u8981\u4e3b\u673a\u5730\u5740\uff0c\u6700\u5927\u957f\u5ea6 2083</li> <li><code>FileUrl</code>: \u5339\u914d <code>file</code>, \u4e0d\u9700\u8981\u4e3b\u673a\u5730\u5740</li> <li><code>PostgresDsn</code>: \u9700\u8981\u7528\u6237\u4fe1\u606f\uff0c\u4e0d\u9700\u8981 TLD\uff0c\u9700\u8981\u4e3b\u673a\u5730\u5740\uff0c\u4ece V.10 \u5f00\u59cb\uff0c<code>PostgresDsn</code> \u652f\u6301\u591a\u4e2a\u4e3b\u673a\u3002 \u4ee5\u4e0b\u65b9\u6848\u662f\u88ab\u652f\u6301\u7684:<ul> <li><code>postgres</code></li> <li><code>postgresql</code></li> <li><code>postgresql+asyncpg</code></li> <li><code>postgresql+pg8000</code></li> <li><code>postgresql+psycopg</code></li> <li><code>postgresql+psycopg2</code></li> <li><code>postgresql+psycopg2cffi</code></li> <li><code>postgresql+py-postgresql</code></li> <li><code>postgresql+pygresql</code></li> </ul> </li> <li><code>CockroachDsn</code>: \u65b9\u6848 <code>cockroachdb</code>\uff0c\u9700\u8981\u7528\u6237\u4fe1\u606f\uff0c\u4e0d\u9700\u8981 TLD\uff0c\u9700\u8981\u4e3b\u673a\u5730\u5740\u3002 \u6b64\u5916\uff0c\u5b83\u652f\u6301\u7684 DBAPI \u65b9\u8a00\uff1a<ul> <li><code>cockroachdb+asyncpg</code></li> <li><code>cockroachdb+psycopg2</code></li> </ul> </li> <li><code>AmqpDsn</code>: \u6a21\u5f0f <code>amqp</code> \u6216 <code>amqps</code>\uff0c\u4e0d\u9700\u8981\u7528\u6237\u4fe1\u606f\uff0c\u4e0d\u9700\u8981 TLD\uff0c\u4e0d\u9700\u8981\u4e3b\u673a\u5730\u5740</li> <li><code>RedisDsn</code>: \u5339\u914d <code>redis</code> \u6216 <code>rediss</code>\uff0c\u4e0d\u9700\u8981\u7528\u6237\u4fe1\u606f\uff0c\u4e0d\u9700\u8981 tld\uff0c\u4e0d\u9700\u8981\u4e3b\u673a\u5730\u5740\uff08\u5df2\u66f4\u6539\uff1a\u7528\u6237\u4fe1\u606f\uff09\uff08\u4f8b\u5982\uff0c<code>rediss://:pass@localhost</code>\uff09</li> <li><code>MongoDsn</code> : \u5339\u914d <code>mongodb</code>, \u4e0d\u9700\u8981\u7528\u6237\u4fe1\u606f\uff0c\u4e0d\u9700\u8981\u6570\u636e\u5e93\u540d\u79f0\uff0c\u4ece v1.6 \u5f00\u59cb\u4e0d\u9700\u8981\u7aef\u53e3\uff09\uff0c\u7528\u6237\u4fe1\u606f\u53ef\u4ee5\u5728\u6ca1\u6709\u7528\u6237\u90e8\u5206\u7684\u60c5\u51b5\u4e0b\u4f20\u9012\uff08\u4f8b\u5982\uff0c<code>mongodb://mongodb0.example.com:27017</code>\uff09</li> <li><code>stricturl</code>: \u5177\u6709\u4ee5\u4e0b\u5173\u952e\u5b57\u53c2\u6570\u7684\u65b9\u6cd5\uff1a<ul> <li><code>strip_whitespace: bool = True</code></li> <li><code>min_length: int = 1</code></li> <li><code>max_length: int = 2 ** 16</code></li> <li><code>tld_required: bool = True</code></li> <li><code>host_required: bool = True</code></li> <li><code>allowed_schemes: Optional[Set[str]] = None</code></li> </ul> </li> </ul> <p>Warning</p> <p>\u5728 V1.10.0 \u548c v1.10.1 \u4e2d\uff0c<code>stricturl</code> \u8fd8\u91c7\u7528\u53ef\u9009\u7684 <code>quote_plus</code> \u53c2\u6570\uff0c\u5e76\u4e14 URL \u7ec4\u4ef6\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u91c7\u7528\u767e\u5206\u6bd4\u7f16\u7801\u3002 \u6b64\u529f\u80fd\u5df2\u5728 v1.10.2 \u4e2d\u5220\u9664\uff0c\u8bf7\u53c2\u9605 #4470 \u4e86\u89e3\u8bf4\u660e\u548c\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\u3002</p> <p>\u5f53\u63d0\u4f9b\u65e0\u6548 URL \u65f6\uff0c\u4e0a\u8ff0\u7c7b\u578b\uff08\u5168\u90e8\u7ee7\u627f\u81ea <code>AnyUrl</code>\uff09\u5c06\u5c1d\u8bd5\u7ed9\u51fa\u63cf\u8ff0\u6027\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\n\nm = MyModel(url='http://www.example.com')\nprint(m.url)\n\ntry:\n    MyModel(url='ftp://invalid.url')\nexcept ValidationError as e:\n    print(e)\n\ntry:\n    MyModel(url='not a url')\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>\u5982\u679c\u60a8\u9700\u8981\u81ea\u5b9a\u4e49 URI/URL \u7c7b\u578b\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e0e\u4e0a\u9762\u5b9a\u4e49\u7684\u7c7b\u578b\u7c7b\u4f3c\u7684\u65b9\u5f0f\u521b\u5efa\u5b83\u3002</p>"},{"location":"usage/types/#url-properties","title":"\u7f51\u5740\u5c5e\u6027(URL Properties)","text":"<p>\u5047\u8bbe\u8f93\u5165 URL \u4e3a<code>http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit</code>\uff0c\u4e0a\u8ff0\u7c7b\u578b\u5bfc\u51fa\u4ee5\u4e0b\u5c5e\u6027\uff1a</p> <ul> <li><code>scheme</code>: \u59cb\u7ec8\u8bbe\u7f6e - url \u65b9\u6848\uff08\u4e0a\u9762\u7684 <code>http</code>\uff09</li> <li><code>host</code>: \u59cb\u7ec8\u8bbe\u7f6e - \u7f51\u5740\u4e3b\u673a\uff08\u4e0a\u9762\u7684\u201cexample.com\u201d\uff09</li> <li> <p><code>host_type</code>: \u59cb\u7ec8\u8bbe\u7f6e - \u63cf\u8ff0\u4e3b\u673a\u7c7b\u578b\uff0c\u6216\u8005\uff1a</p> <ul> <li><code>domain</code>: \u4f8b\u5982 <code>example.com</code>,</li> <li><code>int_domain</code>: \u56fd\u9645\u57df\u540d\uff0c\u89c1\u4e0b\u6587\uff0c\u4f8b\u5982 <code>exampl\u00a3e.org</code>,</li> <li><code>ipv4</code>: IP V4 \u5730\u5740\uff0c\u4f8b\u5982 <code>127.0.0.1</code>\uff0c\u6216</li> <li><code>ipv6</code>: IP V6 \u5730\u5740\uff0c\u4f8b\u5982 <code>2001:db8:ff00:42</code></li> </ul> </li> </ul> <ul> <li><code>user</code>: \u53ef\u9009 - \u7528\u6237\u540d\uff08\u5982\u679c\u5305\u542b\uff09\uff08\u4e0a\u9762\u7684 <code>samuel</code>\uff09</li> <li><code>password</code>: \u53ef\u9009 - \u5982\u679c\u5305\u542b\u5bc6\u7801\uff08\u4e0a\u9762\u7684 <code>pass</code>\uff09</li> <li><code>tld</code>: \u53ef\u9009 - \u9876\u7ea7\u57df\uff08\u4e0a\u9762\u7684\u201ccom\u201d\uff09\uff0c \u6ce8\u610f\uff1a\u8fd9\u5bf9\u4e8e\u4efb\u4f55\u4e8c\u7ea7\u57df\u90fd\u662f\u9519\u8bef\u7684\uff0c\u4f8b\u5982 \u201cco.uk\u201d. \u5982\u679c\u60a8\u9700\u8981\u5b8c\u6574\u7684 TLD \u9a8c\u8bc1\uff0c\u60a8\u9700\u8981\u5b9e\u65bd\u81ea\u5df1\u7684 TLD \u5217\u8868</li> <li><code>port</code>: \u53ef\u9009 - \u7aef\u53e3\uff08\u4e0a\u9762\u7684\u201c8000\u201d\uff09</li> <li><code>path</code>: \u53ef\u9009 - \u8def\u5f84\uff08\u4e0a\u9762\u7684<code>/the/path/</code>\uff09</li> <li><code>query</code>: \u53ef\u9009 - URL \u67e5\u8be2\uff08\u53c8\u540d GET \u53c2\u6570\u6216\u201c\u641c\u7d22\u5b57\u7b26\u4e32\u201d\uff09\uff08\u4e0a\u9762\u7684 <code>query=here</code>\uff09</li> <li><code>fragment</code>: \u53ef\u9009 - \u7247\u6bb5\uff08\u4e0a\u9762\u7684<code>fragment=is;this=bit</code>\uff09</li> </ul> <p>\u5982\u679c\u9700\u8981\u8fdb\u4e00\u6b65\u9a8c\u8bc1\uff0c\u9a8c\u8bc1\u5668\u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e9b\u5c5e\u6027\u6765\u5f3a\u5236\u6267\u884c\u7279\u5b9a\u884c\u4e3a\uff1a</p> <pre><code>from pydantic import BaseModel, HttpUrl, PostgresDsn, ValidationError, validator\n\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\n\nm = MyModel(url='http://www.example.com')\n\n# the repr() method for a url will display all properties of the url\nprint(repr(m.url))\nprint(m.url.scheme)\nprint(m.url.host)\nprint(m.url.host_type)\nprint(m.url.port)\n\n\nclass MyDatabaseModel(BaseModel):\n    db: PostgresDsn\n\n    @validator('db')\n    def check_db_name(cls, v):\n        assert v.path and len(v.path) &gt; 1, 'database must be provided'\n        return v\n\n\nm = MyDatabaseModel(db='postgres://user:pass@localhost:5432/foobar')\nprint(m.db)\n\ntry:\n    MyDatabaseModel(db='postgres://user:pass@localhost:5432')\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/types/#international-domains","title":"\u56fd\u9645\u57df\u540d(International Domains)","text":"<p>\u201c\u56fd\u9645\u57df\u201d\uff08\u4f8b\u5982\uff0c\u4e3b\u673a\u6216 TLD \u5305\u542b\u975e ascii \u5b57\u7b26\u7684 URL\uff09\u5c06\u901a\u8fc7 punycode \u8fdb\u884c\u7f16\u7801\uff08\u53c2\u89c1 \u672c\u6587 \u5f88\u597d\u5730\u8bf4\u660e\u4e86\u4e3a\u4ec0\u4e48\u8fd9\u5f88\u91cd\u8981\uff09\uff1a</p> <pre><code>from pydantic import BaseModel, HttpUrl\n\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\n\nm1 = MyModel(url='http://puny\u00a3code.com')\nprint(m1.url)\nprint(m1.url.host_type)\nm2 = MyModel(url='https://www.\u0430\u0440\u0440\u04cf\u0435.com/')\nprint(m2.url)\nprint(m2.url.host_type)\nm3 = MyModel(url='https://www.example.\u73e0\u5b9d/')\nprint(m3.url)\nprint(m3.url.host_type)\n</code></pre> <p>Warning</p>"},{"location":"usage/types/#_1","title":"\u4e3b\u673a\u540d\u4e2d\u7684\u4e0b\u5212\u7ebf","text":"<p>\u5728 pydantic \u4e2d\uff0c\u57df\u7684\u6240\u6709\u90e8\u5206\u90fd\u5141\u8bb8\u4f7f\u7528\u4e0b\u5212\u7ebf\uff0c\u9664\u4e86 tld\u3002\u4ece\u6280\u672f\u4e0a\u8bb2\uff0c\u8fd9\u53ef\u80fd\u662f\u9519\u8bef\u7684\u2014\u2014\u7406\u8bba\u4e0a\u4e3b\u673a\u540d\u4e0d\u80fd\u6709\u4e0b\u5212\u7ebf\uff0c\u4f46\u5b50\u57df\u53ef\u4ee5\u3002</p> <p>\u89e3\u91ca\u8fd9\u4e00\u70b9\uff1b \u8003\u8651\u4ee5\u4e0b\u4e24\u79cd\u60c5\u51b5\uff1a</p> <ul> <li><code>exam_ple.co.uk</code>: \u4e3b\u673a\u540d\u662f <code>exam_ple</code>\uff0c\u8fd9\u662f\u4e0d\u5141\u8bb8\u7684\uff0c\u56e0\u4e3a\u5b83\u5305\u542b\u4e0b\u5212\u7ebf</li> <li><code>foo_bar.example.com</code> \u4e3b\u673a\u540d\u662f <code>example</code>\uff0c\u5e94\u8be5\u5141\u8bb8\uff0c\u56e0\u4e3a\u4e0b\u5212\u7ebf\u5728\u5b50\u57df\u4e2d</li> </ul> <p>\u5982\u679c\u6ca1\u6709\u8be6\u5c3d\u7684 TLD \u5217\u8868\uff0c\u5c31\u4e0d\u53ef\u80fd\u533a\u5206\u8fd9\u4e24\u8005\u3002 \u56e0\u6b64\u5141\u8bb8\u4f7f\u7528\u4e0b\u5212\u7ebf\uff0c\u4f46\u5982\u679c\u9700\u8981\uff0c\u60a8\u59cb\u7ec8\u53ef\u4ee5\u5728\u9a8c\u8bc1\u5668\u4e2d\u8fdb\u884c\u8fdb\u4e00\u6b65\u9a8c\u8bc1\u3002</p> <p>\u6b64\u5916\uff0cChrome\u3001Firefox \u548c Safari \u76ee\u524d\u90fd\u63a5\u53d7 <code>http://exam_ple.com</code> \u4f5c\u4e3a URL\uff0c\u6240\u4ee5\u6211\u4eec\u7684\u5173\u7cfb\u5f88\u597d\uff08\u6216\u8005\u81f3\u5c11\u662f\u5927\uff09\u3002</p>"},{"location":"usage/types/#color-type","title":"\u989c\u8272\u7c7b\u578b(Color Type)","text":"<p>\u60a8\u53ef\u4ee5\u6839\u636e CSS3 \u89c4\u8303 \u4f7f\u7528 <code>Color</code> \u6570\u636e\u7c7b\u578b\u6765\u5b58\u50a8\u989c\u8272\u3002 \u989c\u8272\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u5b9a\u4e49\uff1a</p> <ul> <li>name (\u4f8b\u5982 <code>\"Black\"</code>, <code>\"azure\"</code>)</li> <li>hexadecimal value   (\u4f8b\u5982 <code>\"0x000\"</code>, <code>\"#FFFFFF\"</code>, <code>\"7fffd4\"</code>)</li> <li>RGB/RGBA \u5143\u7ec4 (\u4f8b\u5982 <code>(255, 255, 255)</code>, <code>(255, 255, 255, 0.5)</code>)</li> <li>RGB/RGBA \u5b57\u7b26\u4e32   (\u4f8b\u5982 <code>\"rgb(255, 255, 255)\"</code>, <code>\"rgba(255, 255, 255, 0.5)\"</code>)</li> <li>HSL \u5b57\u7b26\u4e32   (\u4f8b\u5982 <code>\"hsl(270, 60%, 70%)\"</code>, <code>\"hsl(270, 60%, 70%, .5)\"</code>)</li> </ul> <pre><code>from pydantic import BaseModel, ValidationError\nfrom pydantic.color import Color\n\nc = Color('ff00ff')\nprint(c.as_named())\nprint(c.as_hex())\nc2 = Color('green')\nprint(c2.as_rgb_tuple())\nprint(c2.original())\nprint(repr(Color('hsl(180, 100%, 50%)')))\n\n\nclass Model(BaseModel):\n    color: Color\n\n\nprint(Model(color='purple'))\ntry:\n    Model(color='hello')\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p><code>Color</code> \u62e5\u6709\u4e0b\u5217\u65b9\u6cd5:</p> <code>original</code> \u4f20\u9012\u7ed9 <code>Color</code> \u7684\u539f\u59cb\u5b57\u7b26\u4e32\u6216\u5143\u7ec4 <code>as_named</code> \u8fd4\u56de\u547d\u540d\u7684 CSS3 \u989c\u8272\uff1b \u5982\u679c\u8bbe\u7f6e\u4e86 alpha \u901a\u9053\u6216\u4e0d\u5b58\u5728\u8fd9\u6837\u7684\u989c\u8272\uff0c\u5219\u5931\u8d25\uff0c\u9664\u975e\u63d0\u4f9b\u4e86 <code>fallback=True</code>\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u5b83\u4f1a\u56de\u9000\u5230 <code>as_hex</code> <code>as_hex</code> \u8fd4\u56de\u683c\u5f0f\u4e3a <code>#fff</code> \u6216 <code>#ffffff</code> \u7684\u5b57\u7b26\u4e32\uff1b \u5982\u679c\u8bbe\u7f6e\u4e86 alpha \u901a\u9053\uff0c\u5c06\u5305\u542b 4\uff08\u6216 8\uff09\u4e2a\u5341\u516d\u8fdb\u5236\u503c\uff0c \u4f8b\u5982 <code>#7f33cc26</code> <code>as_rgb</code> \u5982\u679c\u8bbe\u7f6e\u4e86 alpha \u901a\u9053\uff0c\u5219\u8fd4\u56de\u683c\u5f0f\u4e3a <code>rgb(&lt;red&gt;, &lt;green&gt;, &lt;blue&gt;)</code> \u6216 <code>rgba(&lt;red&gt;, &lt;green&gt;, &lt;blue&gt;, &lt;alpha&gt;)</code> \u7684\u5b57\u7b26\u4e32 <code>as_rgb_tuple</code> \u8fd4\u56de RGB(a) \u683c\u5f0f\u7684 3 \u5143\u7ec4\u6216 4 \u5143\u7ec4\u3002 <code>alpha</code> \u5173\u952e\u5b57\u53c2\u6570\u53ef\u7528\u4e8e\u5b9a\u4e49\u662f\u5426\u5e94\u5305\u542b alpha \u901a\u9053\uff1b \u9009\u9879\uff1a<code>True</code> - \u59cb\u7ec8\u5305\u62ec\uff0c<code>False</code> - \u4ece\u4e0d\u5305\u62ec\uff0c<code>None</code>\uff08\u9ed8\u8ba4\uff09- \u5982\u679c\u8bbe\u7f6e\u5219\u5305\u62ec <code>as_hsl</code> \u683c\u5f0f\u4e3a<code>hsl(&lt;hue deg&gt;, &lt;saturation %&gt;, &lt;lightness %&gt;)</code>\u6216<code>hsl(&lt;hue deg&gt;, &lt;saturation %&gt;, &lt;lightness %&gt;, &lt;alpha&gt;)</code>\u7684\u5b57\u7b26\u4e32\uff0c\u5982\u679c alpha \u901a\u9053\u5df2\u8bbe\u7f6e <code>as_hsl_tuple</code> \u8fd4\u56de HSL(a) \u683c\u5f0f\u7684 3 \u5143\u7ec4\u6216 4 \u5143\u7ec4\u3002 <code>alpha</code> \u5173\u952e\u5b57\u53c2\u6570\u53ef\u7528\u4e8e\u5b9a\u4e49\u662f\u5426\u5e94\u5305\u542b alpha \u901a\u9053\uff1b \u9009\u9879\uff1a<code>True</code> - \u59cb\u7ec8\u5305\u62ec\uff0c<code>False</code> - \u4ece\u4e0d\u5305\u62ec\uff0c<code>None</code>\uff08\u9ed8\u8ba4\u503c\uff09- \u5982\u679c\u8bbe\u7f6e\u5219\u5305\u62ec <p><code>Color</code> \u7684<code>__str__</code> \u65b9\u6cd5\u8fd4\u56de<code>self.as_named(fallback=True)</code>\u3002</p> <p>Note</p> <p><code>as_hsl*</code> \u6307\u7684\u662f html \u548c\u4e16\u754c\u4e0a\u5927\u591a\u6570\u5730\u65b9\u4f7f\u7528\u7684\u8272\u8c03\u3001\u9971\u548c\u5ea6\u3001\u4eae\u5ea6<code>HSL</code>\uff0cnot Python \u7684<code>colorsys</code>\u4e2d\u4f7f\u7528\u7684<code>HLS</code>\u3002</p>"},{"location":"usage/types/#secret-types","title":"\u4fdd\u5bc6\u7c7b\u578b(Secret Types)","text":"<p>\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>SecretStr</code> \u548c <code>SecretBytes</code> \u6570\u636e\u7c7b\u578b\u6765\u5b58\u50a8\u60a8\u4e0d\u5e0c\u671b\u5728\u65e5\u5fd7\u8bb0\u5f55\u6216\u56de\u6eaf\u4e2d\u53ef\u89c1\u7684\u654f\u611f\u4fe1\u606f\u3002 <code>SecretStr</code> \u548c <code>SecretBytes</code> \u53ef\u4ee5\u5e42\u7b49\u5730\u521d\u59cb\u5316\uff0c\u4e5f\u53ef\u4ee5\u5206\u522b\u4f7f\u7528 <code>str</code> \u6216 <code>bytes</code> \u8fdb\u884c\u521d\u59cb\u5316\u3002 <code>SecretStr</code> \u548c <code>SecretBytes</code> \u5728\u8f6c\u6362\u4e3a json \u65f6\u5c06\u88ab\u683c\u5f0f\u5316\u4e3a <code>'**********'</code> \u6216 <code>''</code>\u3002</p> <pre><code>from pydantic import BaseModel, SecretStr, SecretBytes, ValidationError\n\n\nclass SimpleModel(BaseModel):\n    password: SecretStr\n    password_bytes: SecretBytes\n\n\nsm = SimpleModel(password='IAmSensitive', password_bytes=b'IAmSensitiveBytes')\n\n# Standard access methods will not display the secret\nprint(sm)\nprint(sm.password)\nprint(sm.dict())\nprint(sm.json())\n\n# Use get_secret_value method to see the secret's content.\nprint(sm.password.get_secret_value())\nprint(sm.password_bytes.get_secret_value())\n\ntry:\n    SimpleModel(password=[1, 2, 3], password_bytes=[1, 2, 3])\nexcept ValidationError as e:\n    print(e)\n\n\n# If you want the secret to be dumped as plain-text using the json method,\n# you can use json_encoders in the Config class.\nclass SimpleModelDumpable(BaseModel):\n    password: SecretStr\n    password_bytes: SecretBytes\n\n    class Config:\n        json_encoders = {\n            SecretStr: lambda v: v.get_secret_value() if v else None,\n            SecretBytes: lambda v: v.get_secret_value() if v else None,\n        }\n\n\nsm2 = SimpleModelDumpable(\n    password='IAmSensitive', password_bytes=b'IAmSensitiveBytes'\n)\n\n# Standard access methods will not display the secret\nprint(sm2)\nprint(sm2.password)\nprint(sm2.dict())\n\n# But the json method will\nprint(sm2.json())\n</code></pre>"},{"location":"usage/types/#jsonjson-type","title":"Json\u7c7b\u578b(Json Type)","text":"<p>\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>Json</code> \u6570\u636e\u7c7b\u578b\u8ba9 pydantic \u9996\u5148\u52a0\u8f7d\u539f\u59cb JSON \u5b57\u7b26\u4e32\u3002 \u5b83\u8fd8\u53ef\u4ee5\u9009\u62e9\u7528\u4e8e\u5c06\u52a0\u8f7d\u7684\u5bf9\u8c61\u89e3\u6790\u4e3a\u53e6\u4e00\u79cd\u7c7b\u578b\uff0c\u57fa\u4e8e\u53c2\u6570\u5316\u7684<code>Json</code>\u7c7b\u578b\uff1a</p> <pre><code>from typing import Any, List\n\nfrom pydantic import BaseModel, Json, ValidationError\n\n\nclass AnyJsonModel(BaseModel):\n    json_obj: Json[Any]\n\n\nclass ConstrainedJsonModel(BaseModel):\n    json_obj: Json[List[int]]\n\n\nprint(AnyJsonModel(json_obj='{\"b\": 1}'))\nprint(ConstrainedJsonModel(json_obj='[1, 2, 3]'))\ntry:\n    ConstrainedJsonModel(json_obj=12)\nexcept ValidationError as e:\n    print(e)\n\ntry:\n    ConstrainedJsonModel(json_obj='[a, b]')\nexcept ValidationError as e:\n    print(e)\n\ntry:\n    ConstrainedJsonModel(json_obj='[\"a\", \"b\"]')\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/types/#payment-card-numbers","title":"\u652f\u4ed8\u5361\u53f7\u7801(Payment Card Numbers)","text":"<p><code>PaymentCardNumber</code> \u7c7b\u578b\u9a8c\u8bc1\u652f\u4ed8\u5361\uff08\u4f8b\u5982\u501f\u8bb0\u5361\u6216\u4fe1\u7528\u5361\uff09\u3002</p> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\nfrom pydantic.types import PaymentCardBrand, PaymentCardNumber, constr\n\n\nclass Card(BaseModel):\n    name: constr(strip_whitespace=True, min_length=1)\n    number: PaymentCardNumber\n    exp: date\n\n    @property\n    def brand(self) -&gt; PaymentCardBrand:\n        return self.number.brand\n\n    @property\n    def expired(self) -&gt; bool:\n        return self.exp &lt; date.today()\n\n\ncard = Card(\n    name='Georg Wilhelm Friedrich Hegel',\n    number='4000000000000002',\n    exp=date(2023, 9, 30),\n)\n\nassert card.number.brand == PaymentCardBrand.visa\nassert card.number.bin == '400000'\nassert card.number.last4 == '0002'\nassert card.number.masked == '400000******0002'\n</code></pre> <p><code>PaymentCardBrand</code> \u53ef\u4ee5\u662f\u57fa\u4e8e BIN \u7684\u4ee5\u4e0b\u4e4b\u4e00\uff1a</p> <ul> <li><code>PaymentCardBrand.amex</code></li> <li><code>PaymentCardBrand.mastercard</code></li> <li><code>PaymentCardBrand.visa</code></li> <li><code>PaymentCardBrand.other</code></li> </ul> <p>\u5b9e\u9645\u9a8c\u8bc1\u9a8c\u8bc1\u5361\u53f7\u662f\uff1a</p> <ul> <li>\u53ea\u6709\u6570\u5b57\u7684<code>str</code></li> <li>luhn \u6709\u6548\u7684</li> <li>\u57fa\u4e8e BIN \u7684\u6b63\u786e\u957f\u5ea6\uff0c\u5982\u679c\u662f\u7f8e\u56fd\u8fd0\u901a\u5361\u3001\u4e07\u4e8b\u8fbe\u5361\u6216\u7ef4\u8428\u5361\uff0c\u4ee5\u53ca\u6240\u6709\u5176\u4ed6\u54c1\u724c\u7684 12 \u5230 19 \u4f4d\u6570\u5b57</li> </ul>"},{"location":"usage/types/#constrained-types","title":"\u7ea6\u675f\u7c7b\u578b(Constrained Types)","text":"<p>\u53ef\u4ee5\u4f7f\u7528 <code>con*</code> \u7c7b\u578b\u51fd\u6570\u6765\u9650\u5236\u8bb8\u591a\u5e38\u89c1\u7c7b\u578b\u7684\u503c\uff1a</p> <pre><code>from decimal import Decimal\n\nfrom pydantic import (\n    BaseModel,\n    NegativeFloat,\n    NegativeInt,\n    PositiveFloat,\n    PositiveInt,\n    NonNegativeFloat,\n    NonNegativeInt,\n    NonPositiveFloat,\n    NonPositiveInt,\n    conbytes,\n    condecimal,\n    confloat,\n    conint,\n    conlist,\n    conset,\n    constr,\n    Field,\n)\n\n\nclass Model(BaseModel):\n    upper_bytes: conbytes(to_upper=True)\n    lower_bytes: conbytes(to_lower=True)\n    short_bytes: conbytes(min_length=2, max_length=10)\n    strip_bytes: conbytes(strip_whitespace=True)\n\n    upper_str: constr(to_upper=True)\n    lower_str: constr(to_lower=True)\n    short_str: constr(min_length=2, max_length=10)\n    regex_str: constr(regex=r'^apple (pie|tart|sandwich)$')\n    strip_str: constr(strip_whitespace=True)\n\n    big_int: conint(gt=1000, lt=1024)\n    mod_int: conint(multiple_of=5)\n    pos_int: PositiveInt\n    neg_int: NegativeInt\n    non_neg_int: NonNegativeInt\n    non_pos_int: NonPositiveInt\n\n    big_float: confloat(gt=1000, lt=1024)\n    unit_interval: confloat(ge=0, le=1)\n    mod_float: confloat(multiple_of=0.5)\n    pos_float: PositiveFloat\n    neg_float: NegativeFloat\n    non_neg_float: NonNegativeFloat\n    non_pos_float: NonPositiveFloat\n\n    short_list: conlist(int, min_items=1, max_items=4)\n    short_set: conset(int, min_items=1, max_items=4)\n\n    decimal_positive: condecimal(gt=0)\n    decimal_negative: condecimal(lt=0)\n    decimal_max_digits_and_places: condecimal(max_digits=2, decimal_places=2)\n    mod_decimal: condecimal(multiple_of=Decimal('0.25'))\n\n    bigger_int: int = Field(..., gt=10000)\n</code></pre> <p>\u5176\u4e2d <code>Field</code> \u6307\u7684\u662f \u5b57\u6bb5\u51fd\u6570\u3002</p>"},{"location":"usage/types/#conlist","title":"<code>conlist</code> \u7684\u53c2\u6570","text":"<p>\u4f7f\u7528 <code>conlist</code> \u7c7b\u578b\u51fd\u6570\u65f6\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570</p> <ul> <li><code>item_type: Type[T]</code>: \u5217\u8868\u9879\u7684\u7c7b\u578b</li> <li><code>min_items: int = None</code>: \u5217\u8868\u4e2d\u7684\u6700\u5c0f\u9879\u76ee\u6570</li> <li><code>max_items: int = None</code>: \u5217\u8868\u4e2d\u7684\u6700\u5927\u9879\u76ee\u6570</li> <li><code>unique_items: bool = None</code>: \u5f3a\u5236\u5217\u8868\u5143\u7d20\u662f\u552f\u4e00\u7684</li> </ul>"},{"location":"usage/types/#conset","title":"<code>conset</code> \u7684\u53c2\u6570","text":"<p>\u4f7f\u7528 <code>conset</code> \u7c7b\u578b\u51fd\u6570\u65f6\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570</p> <ul> <li><code>item_type: Type[T]</code>: \u8bbe\u7f6e\u9879\u76ee\u7684\u7c7b\u578b</li> <li><code>min_items: int = None</code>: \u96c6\u5408\u4e2d\u7684\u6700\u5c0f\u9879\u76ee\u6570</li> <li><code>max_items: int = None</code>: \u96c6\u5408\u4e2d\u7684\u6700\u5927\u9879\u76ee\u6570</li> </ul>"},{"location":"usage/types/#confrozenset","title":"<code>confrozenset</code> \u7684\u53c2\u6570","text":"<p>\u4f7f\u7528 <code>confrozenset</code> \u7c7b\u578b\u51fd\u6570\u65f6\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570</p> <ul> <li><code>item_type: Type[T]</code>: frozenset \u9879\u76ee\u7684\u7c7b\u578b</li> <li><code>min_items: int = None</code>: frozenset \u4e2d\u7684\u6700\u5c0f\u9879\u76ee\u6570</li> <li><code>max_items: int = None</code>: frozenset \u4e2d\u7684\u6700\u5927\u9879\u76ee\u6570</li> </ul>"},{"location":"usage/types/#conint","title":"<code>conint</code> \u7684\u53c2\u6570","text":"<p>\u4f7f\u7528 <code>conint</code> \u7c7b\u578b\u51fd\u6570\u65f6\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570</p> <ul> <li><code>strict: bool = False</code>: \u63a7\u5236\u7c7b\u578b\u5f3a\u5236</li> <li><code>gt: int = None</code>: \u5f3a\u5236\u6574\u6570\u5927\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>ge: int = None</code>: \u5f3a\u5236\u6574\u6570\u5927\u4e8e\u6216\u7b49\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>lt: int = None</code>: \u5f3a\u5236\u6574\u6570\u5c0f\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>le: int = None</code>: \u5f3a\u5236\u6574\u6570\u5c0f\u4e8e\u6216\u7b49\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>multiple_of: int = None</code>: \u5f3a\u5236\u6574\u6570\u4e3a\u8bbe\u5b9a\u503c\u7684\u500d\u6570</li> </ul>"},{"location":"usage/types/#confloat","title":"<code>confloat</code> \u7684\u53c2\u6570","text":"<p>\u4f7f\u7528 <code>confloat</code> \u7c7b\u578b\u51fd\u6570\u65f6\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570</p> <ul> <li><code>strict: bool = False</code>: \u63a7\u5236\u7c7b\u578b\u5f3a\u5236</li> <li><code>gt: float = None</code>: \u5f3a\u5236\u6d6e\u52a8\u5927\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>ge: float = None</code>: \u5f3a\u5236float\u5927\u4e8e\u7b49\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>lt: float = None</code>: \u5f3a\u5236 float \u5c0f\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>le: float = None</code>: \u5f3a\u5236 float \u5c0f\u4e8e\u6216\u7b49\u4e8e\u8bbe\u7f6e\u503c</li> <li><code>multiple_of: float = None</code>: \u5f3a\u5236 float \u662f\u8bbe\u7f6e\u503c\u7684\u500d\u6570</li> <li><code>allow_inf_nan: bool = True</code>: \u662f\u5426\u5141\u8bb8\u65e0\u7a77\u5927\uff08<code>+inf</code> \u548c <code>-inf</code>\uff09\u548c NaN \u503c\uff0c\u9ed8\u8ba4\u4e3a <code>True</code>\uff0c\u8bbe\u7f6e\u4e3a <code>False</code> \u4ee5\u4e0e <code>JSON</code> \u517c\u5bb9\uff0c   \u89c1 #3994 \u83b7\u53d6\u66f4\u591a\u8be6\u60c5, \u5728 V1.10 \u7248\u672c\u4e2d\u6dfb\u52a0</li> </ul>"},{"location":"usage/types/#condecimal","title":"<code>condecimal</code> \u7684\u53c2\u6570","text":"<p>\u4f7f\u7528 <code>condecimal</code> \u7c7b\u578b\u51fd\u6570\u65f6\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570</p> <ul> <li><code>gt: Decimal = None</code>: \u5f3a\u5236\u5c0f\u6570\u5927\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>ge: Decimal = None</code>: \u5f3a\u5236\u5c0f\u6570\u5927\u4e8e\u6216\u7b49\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>lt: Decimal = None</code>: \u5f3a\u5236\u5c0f\u6570\u5c0f\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>le: Decimal = None</code>: \u5f3a\u5236\u5c0f\u6570\u5c0f\u4e8e\u6216\u7b49\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>max_digits: int = None</code>: \u5c0f\u6570\u70b9\u5185\u7684\u6700\u5927\u4f4d\u6570\u3002 \u5b83\u4e0d\u5305\u62ec\u5c0f\u6570\u70b9\u524d\u7684\u96f6\u6216\u5c3e\u968f\u7684\u5c0f\u6570\u96f6</li> <li><code>decimal_places: int = None</code>: \u5141\u8bb8\u7684\u6700\u5927\u5c0f\u6570\u4f4d\u6570\u3002 \u5b83\u4e0d\u5305\u62ec\u5c3e\u968f\u7684\u5c0f\u6570\u96f6</li> <li><code>multiple_of: Decimal = None</code>: \u5f3a\u5236\u5c0f\u6570\u4e3a\u8bbe\u5b9a\u503c\u7684\u500d\u6570</li> </ul>"},{"location":"usage/types/#constr","title":"<code>constr</code> \u7684\u53c2\u6570","text":"<p>\u4f7f\u7528 <code>constr</code> \u7c7b\u578b\u51fd\u6570\u65f6\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570</p> <ul> <li><code>strip_whitespace: bool = False</code>: \u5220\u9664\u524d\u5bfc\u548c\u5c3e\u968f\u7a7a\u683c</li> <li><code>to_upper: bool = False</code>: \u5c06\u6240\u6709\u5b57\u7b26\u8f6c\u4e3a\u5927\u5199</li> <li><code>to_lower: bool = False</code>: \u5c06\u6240\u6709\u5b57\u7b26\u53d8\u4e3a\u5c0f\u5199</li> <li><code>strict: bool = False</code>: \u63a7\u5236\u7c7b\u578b\u5f3a\u5236</li> <li><code>min_length: int = None</code>: \u5b57\u7b26\u4e32\u7684\u6700\u5c0f\u957f\u5ea6</li> <li><code>max_length: int = None</code>: \u5b57\u7b26\u4e32\u7684\u6700\u5927\u957f\u5ea6</li> <li><code>curtail_length: int = None</code>: \u5f53\u5b57\u7b26\u4e32\u957f\u5ea6\u8d85\u8fc7\u8bbe\u5b9a\u503c\u65f6\uff0c\u5c06\u5b57\u7b26\u4e32\u957f\u5ea6\u6536\u7f29\u5230\u8bbe\u5b9a\u503c</li> <li><code>regex: str = None</code>: \u7528\u4e8e\u9a8c\u8bc1\u5b57\u7b26\u4e32\u7684\u6b63\u5219\u8868\u8fbe\u5f0f</li> </ul>"},{"location":"usage/types/#conbytes","title":"<code>conbytes</code> \u7684\u53c2\u6570","text":"<p>\u4f7f\u7528 <code>conbytes</code> \u7c7b\u578b\u51fd\u6570\u65f6\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570</p> <ul> <li><code>strip_whitespace: bool = False</code>: \u5220\u9664\u524d\u5bfc\u548c\u5c3e\u968f\u7a7a\u683c</li> <li><code>to_upper: bool = False</code>: \u5c06\u6240\u6709\u5b57\u7b26\u8f6c\u4e3a\u5927\u5199</li> <li><code>to_lower: bool = False</code>: \u5c06\u6240\u6709\u5b57\u7b26\u53d8\u4e3a\u5c0f\u5199</li> <li><code>min_length: int = None</code>: \u5b57\u8282\u4e32\u7684\u6700\u5c0f\u957f\u5ea6</li> <li><code>max_length: int = None</code>: \u5b57\u8282\u4e32\u7684\u6700\u5927\u957f\u5ea6</li> <li><code>strict: bool = False</code>: \u63a7\u5236\u7c7b\u578b\u5f3a\u5236</li> </ul>"},{"location":"usage/types/#condate","title":"<code>condate</code> \u7684\u53c2\u6570","text":"<p>\u4f7f\u7528 <code>condate</code> \u7c7b\u578b\u51fd\u6570\u65f6\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570</p> <ul> <li><code>gt: date = None</code>: \u5f3a\u5236\u65e5\u671f\u5927\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>ge: date = None</code>: \u5f3a\u5236\u65e5\u671f\u5927\u4e8e\u6216\u7b49\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>lt: date = None</code>: \u5f3a\u5236\u65e5\u671f\u5c0f\u4e8e\u8bbe\u5b9a\u503c</li> <li><code>le: date = None</code>: \u5f3a\u5236\u65e5\u671f\u5c0f\u4e8e\u6216\u7b49\u4e8e\u8bbe\u5b9a\u503c</li> </ul>"},{"location":"usage/types/#strict-types","title":"\u4e25\u683c\u7c7b\u578b(Strict Types)","text":"<p>\u60a8\u53ef\u4ee5\u4f7f\u7528<code>StrictStr</code>\u3001<code>StrictBytes</code>\u3001<code>StrictInt</code>\u3001<code>StrictFloat</code>\u548c<code>StrictBool</code>\u7c7b\u578b\u6765\u9632\u6b62\u6765\u81ea\u517c\u5bb9\u7c7b\u578b\u7684\u5f3a\u5236\u8f6c\u6362\u3002</p> <p>\u53ea\u6709\u5f53\u9a8c\u8bc1\u503c\u5c5e\u4e8e\u76f8\u5e94\u7c7b\u578b\u6216\u8be5\u7c7b\u578b\u7684\u5b50\u7c7b\u578b\u65f6\uff0c\u8fd9\u4e9b\u7c7b\u578b\u624d\u4f1a\u901a\u8fc7\u9a8c\u8bc1\u3002</p> <p>\u6b64\u884c\u4e3a\u4e5f\u901a\u8fc7<code>ConstrainedStr</code>\u3001<code>ConstrainedBytes</code>\u3001<code>ConstrainedFloat</code>\u548c<code>ConstrainedInt</code>\u7c7b\u7684<code>strict</code>\u5b57\u6bb5\u516c\u5f00\uff0c\u5e76\u4e14\u53ef\u4ee5\u4e0e\u5927\u91cf\u590d\u6742\u7684\u9a8c\u8bc1\u89c4\u5219\u7ed3\u5408\u4f7f\u7528\u3002</p> <p>\u4ee5\u4e0b\u6ce8\u610f\u4e8b\u9879\u9002\u7528\uff1a</p> <ul> <li><code>StrictBytes</code>\uff08\u4ee5\u53ca <code>ConstrainedBytes</code> \u7684 <code>strict</code> \u9009\u9879\uff09\u5c06\u63a5\u53d7 <code>bytes</code> \u548c <code>bytearray</code> \u7c7b\u578b\u3002</li> <li><code>StrictInt</code>\uff08\u4ee5\u53ca <code>ConstrainedInt</code> \u7684 <code>strict</code> \u9009\u9879\uff09\u5c06\u4e0d\u63a5\u53d7 <code>bool</code> \u7c7b\u578b\uff0c\u5373\u4f7f <code>bool</code> \u662f Python \u4e2d <code>int</code> \u7684\u5b50\u7c7b\u3002 \u5176\u4ed6\u5b50\u7c7b\u5c06\u8d77\u4f5c\u7528\u3002</li> <li><code>StrictFloat</code>\uff08\u4ee5\u53ca <code>ConstrainedFloat</code> \u7684 <code>strict</code> \u9009\u9879\uff09\u5c06\u4e0d\u63a5\u53d7 <code>int</code>\u3002</li> </ul> <pre><code>from pydantic import (\n    BaseModel,\n    StrictBytes,\n    StrictBool,\n    StrictInt,\n    ValidationError,\n    confloat,\n)\n\n\nclass StrictBytesModel(BaseModel):\n    strict_bytes: StrictBytes\n\n\ntry:\n    StrictBytesModel(strict_bytes='hello world')\nexcept ValidationError as e:\n    print(e)\n\n\nclass StrictIntModel(BaseModel):\n    strict_int: StrictInt\n\n\ntry:\n    StrictIntModel(strict_int=3.14159)\nexcept ValidationError as e:\n    print(e)\n\n\nclass ConstrainedFloatModel(BaseModel):\n    constrained_float: confloat(strict=True, ge=0.0)\n\n\ntry:\n    ConstrainedFloatModel(constrained_float=3)\nexcept ValidationError as e:\n    print(e)\n\ntry:\n    ConstrainedFloatModel(constrained_float=-1.23)\nexcept ValidationError as e:\n    print(e)\n\n\nclass StrictBoolModel(BaseModel):\n    strict_bool: StrictBool\n\n\ntry:\n    StrictBoolModel(strict_bool='False')\nexcept ValidationError as e:\n    print(str(e))\n</code></pre>"},{"location":"usage/types/#bytesize","title":"\u5b57\u8282\u5927\u5c0f\u7c7b\u578b(ByteSize)","text":"<p>\u60a8\u53ef\u4ee5\u4f7f\u7528<code>ByteSize</code>\u6570\u636e\u7c7b\u578b\u5c06\u5b57\u8282\u5b57\u7b26\u4e32\u8868\u793a\u5f62\u5f0f\u8f6c\u6362\u4e3a\u539f\u59cb\u5b57\u8282\uff0c\u5e76\u6253\u5370\u51fa\u4eba\u7c7b\u53ef\u8bfb\u7684\u5b57\u8282\u7248\u672c\u3002</p> <p>Info</p> <p>\u8bf7\u6ce8\u610f\uff0c<code>1b</code> \u5c06\u88ab\u89e3\u6790\u4e3a<code>1 byte</code>\u800c\u4e0d\u662f<code>1 bit</code>\u3002</p> <pre><code>from pydantic import BaseModel, ByteSize\n\n\nclass MyModel(BaseModel):\n    size: ByteSize\n\n\nprint(MyModel(size=52000).size)\nprint(MyModel(size='3000 KiB').size)\n\nm = MyModel(size='50 PB')\nprint(m.size.human_readable())\nprint(m.size.human_readable(decimal=True))\n\nprint(m.size.to('TiB'))\n</code></pre>"},{"location":"usage/types/#custom-data-types","title":"\u81ea\u5b9a\u4e49\u6570\u636e\u7c7b\u578b(Custom Data Types)","text":"<p>\u60a8\u8fd8\u53ef\u4ee5\u5b9a\u4e49\u81ea\u5df1\u7684\u81ea\u5b9a\u4e49\u6570\u636e\u7c7b\u578b\u3002 \u6709\u51e0\u79cd\u65b9\u6cd5\u53ef\u4ee5\u5b9e\u73b0\u5b83\u3002</p>"},{"location":"usage/types/#__get_validators__-classes-with-__get_validators__","title":"\u5e26\u6709 <code>__get_validators__</code> \u7684\u7c7b (Classes with <code>__get_validators__</code>)","text":"<p>\u60a8\u4f7f\u7528\u5e26\u6709\u7c7b\u65b9\u6cd5 <code>__get_validators__</code> \u7684\u81ea\u5b9a\u4e49\u7c7b\u3002 \u5b83\u5c06\u88ab\u8c03\u7528\u4ee5\u83b7\u53d6\u9a8c\u8bc1\u5668\u6765\u89e3\u6790\u548c\u9a8c\u8bc1\u8f93\u5165\u6570\u636e\u3002</p> <p>Tip</p> <p>\u8fd9\u4e9b\u9a8c\u8bc1\u5668\u5177\u6709\u4e0e Validators \u4e2d\u76f8\u540c\u7684\u8bed\u4e49\uff0c\u60a8\u53ef\u4ee5\u58f0\u660e\u53c2\u6570 <code>config</code>\u3001<code>field</code> \u7b49\u3002</p> <pre><code>import re\nfrom pydantic import BaseModel\n\n# https://en.wikipedia.org/wiki/Postcodes_in_the_United_Kingdom#Validation\npost_code_regex = re.compile(\n    r'(?:'\n    r'([A-Z]{1,2}[0-9][A-Z0-9]?|ASCN|STHL|TDCU|BBND|[BFS]IQQ|PCRN|TKCA) ?'\n    r'([0-9][A-Z]{2})|'\n    r'(BFPO) ?([0-9]{1,4})|'\n    r'(KY[0-9]|MSR|VG|AI)[ -]?[0-9]{4}|'\n    r'([A-Z]{2}) ?([0-9]{2})|'\n    r'(GE) ?(CX)|'\n    r'(GIR) ?(0A{2})|'\n    r'(SAN) ?(TA1)'\n    r')'\n)\n\n\nclass PostCode(str):\n\"\"\"\n    Partial UK postcode validation. Note: this is just an example, and is not\n    intended for use in production; in particular this does NOT guarantee\n    a postcode exists, just that it has a valid format.\n    \"\"\"\n\n    @classmethod\n    def __get_validators__(cls):\n        # one or more validators may be yielded which will be called in the\n        # order to validate the input, each validator will receive as an input\n        # the value returned from the previous validator\n        yield cls.validate\n\n    @classmethod\n    def __modify_schema__(cls, field_schema):\n        # __modify_schema__ should mutate the dict it receives in place,\n        # the returned value will be ignored\n        field_schema.update(\n            # simplified regex here for brevity, see the wikipedia link above\n            pattern='^[A-Z]{1,2}[0-9][A-Z0-9]? ?[0-9][A-Z]{2}$',\n            # some example postcodes\n            examples=['SP11 9DG', 'w1j7bu'],\n        )\n\n    @classmethod\n    def validate(cls, v):\n        if not isinstance(v, str):\n            raise TypeError('string required')\n        m = post_code_regex.fullmatch(v.upper())\n        if not m:\n            raise ValueError('invalid postcode format')\n        # you could also return a string here which would mean model.post_code\n        # would be a string, pydantic won't care but you could end up with some\n        # confusion since the value's type won't match the type annotation\n        # exactly\n        return cls(f'{m.group(1)} {m.group(2)}')\n\n    def __repr__(self):\n        return f'PostCode({super().__repr__()})'\n\n\nclass Model(BaseModel):\n    post_code: PostCode\n\n\nmodel = Model(post_code='sw8 5el')\nprint(model)\nprint(model.post_code)\nprint(Model.schema())\n</code></pre> <p>\u7c7b\u4f3c\u7684\u9a8c\u8bc1\u53ef\u4ee5\u4f7f\u7528 <code>constr(regex=...)</code> \u6765\u5b9e\u73b0\uff0c\u9664\u4e86\u503c\u4e0d\u4f1a\u7528\u7a7a\u683c\u683c\u5f0f\u5316\uff0c\u6a21\u5f0f\u5c06\u53ea\u5305\u542b\u5b8c\u6574\u6a21\u5f0f\uff0c\u8fd4\u56de\u503c\u5c06\u662f \u9999\u8349\u5b57\u7b26\u4e32\u3002</p> <p>\u6709\u5173\u5982\u4f55\u751f\u6210\u6a21\u578b\u67b6\u6784\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 schema\u3002</p>"},{"location":"usage/types/#arbitrary-types-allowed","title":"\u5141\u8bb8\u4efb\u610f\u7c7b\u578b(Arbitrary Types Allowed)","text":"<p>\u60a8\u53ef\u4ee5\u4f7f\u7528 \u6a21\u578b\u914d\u7f6e \u4e2d\u7684 <code>arbitrary_types_allowed</code> \u914d\u7f6e\u5141\u8bb8\u4efb\u610f\u7c7b\u578b\u3002</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\n# This is not a pydantic model, it's an arbitrary class\nclass Pet:\n    def __init__(self, name: str):\n        self.name = name\n\n\nclass Model(BaseModel):\n    pet: Pet\n    owner: str\n\n    class Config:\n        arbitrary_types_allowed = True\n\n\npet = Pet(name='Hedwig')\n# A simple check of instance type is used to validate the data\nmodel = Model(owner='Harry', pet=pet)\nprint(model)\nprint(model.pet)\nprint(model.pet.name)\nprint(type(model.pet))\ntry:\n    # If the value is not an instance of the type, it's invalid\n    Model(owner='Harry', pet='Hedwig')\nexcept ValidationError as e:\n    print(e)\n# Nothing in the instance of the arbitrary type is checked\n# Here name probably should have been a str, but it's not validated\npet2 = Pet(name=42)\nmodel2 = Model(owner='Harry', pet=pet2)\nprint(model2)\nprint(model2.pet)\nprint(model2.pet.name)\nprint(type(model2.pet))\n</code></pre>"},{"location":"usage/types/#generic-classes-as-types","title":"\u4f5c\u4e3a\u7c7b\u578b\u7684\u901a\u7528\u7c7b(Generic Classes as Types)","text":"<p>Warning</p> <p>\u8fd9\u662f\u4e00\u79cd\u60a8\u4e00\u5f00\u59cb\u53ef\u80fd\u4e0d\u9700\u8981\u7684\u9ad8\u7ea7\u6280\u672f\u3002 \u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u4f1a\u4f7f\u7528\u6807\u51c6\u7684 pydantic \u6a21\u578b\u3002</p> <p>\u60a8\u53ef\u4ee5\u4f7f\u7528 Generic Classes \u4f5c\u4e3a\u5b57\u6bb5\u7c7b\u578b\uff0c\u5e76\u6839\u636e\u201c\u7c7b\u578b\u53c2\u6570(type parameters)\u201d\uff08\u6216\u5b50\u7c7b\u578b\uff09\u6267\u884c\u81ea\u5b9a\u4e49\u9a8c\u8bc1 \u4e0e <code>__get_validators__</code> \u3002</p> <p>\u5982\u679c\u60a8\u7528\u4f5c\u5b50\u7c7b\u578b\u7684\u901a\u7528\u7c7b\u5177\u6709\u7c7b\u65b9\u6cd5<code>__get_validators__</code>\uff0c\u5219\u65e0\u9700\u4f7f\u7528<code>arbitrary_types_allowed</code>\u5373\u53ef\u5de5\u4f5c\u3002</p> <p>\u56e0\u4e3a\u60a8\u53ef\u4ee5\u58f0\u660e\u63a5\u6536\u5f53\u524d <code>field</code> \u7684\u9a8c\u8bc1\u5668\uff0c\u6240\u4ee5\u60a8\u53ef\u4ee5\u63d0\u53d6 <code>sub_field</code> \uff08\u4ece\u901a\u7528\u7c7b\u7c7b\u578b\u53c2\u6570\uff09\u5e76\u4f7f\u7528\u5b83\u4eec\u9a8c\u8bc1\u6570\u636e\u3002</p> <pre><code>from pydantic import BaseModel, ValidationError\nfrom pydantic.fields import ModelField\nfrom typing import TypeVar, Generic\n\nAgedType = TypeVar('AgedType')\nQualityType = TypeVar('QualityType')\n\n\n# This is not a pydantic model, it's an arbitrary generic class\nclass TastingModel(Generic[AgedType, QualityType]):\n    def __init__(self, name: str, aged: AgedType, quality: QualityType):\n        self.name = name\n        self.aged = aged\n        self.quality = quality\n\n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n\n    @classmethod\n    # You don't need to add the \"ModelField\", but it will help your\n    # editor give you completion and catch errors\n    def validate(cls, v, field: ModelField):\n        if not isinstance(v, cls):\n            # The value is not even a TastingModel\n            raise TypeError('Invalid value')\n        if not field.sub_fields:\n            # Generic parameters were not provided so we don't try to validate\n            # them and just return the value as is\n            return v\n        aged_f = field.sub_fields[0]\n        quality_f = field.sub_fields[1]\n        errors = []\n        # Here we don't need the validated value, but we want the errors\n        valid_value, error = aged_f.validate(v.aged, {}, loc='aged')\n        if error:\n            errors.append(error)\n        # Here we don't need the validated value, but we want the errors\n        valid_value, error = quality_f.validate(v.quality, {}, loc='quality')\n        if error:\n            errors.append(error)\n        if errors:\n            raise ValidationError(errors, cls)\n        # Validation passed without errors, return the same instance received\n        return v\n\n\nclass Model(BaseModel):\n    # for wine, \"aged\" is an int with years, \"quality\" is a float\n    wine: TastingModel[int, float]\n    # for cheese, \"aged\" is a bool, \"quality\" is a str\n    cheese: TastingModel[bool, str]\n    # for thing, \"aged\" is a Any, \"quality\" is Any\n    thing: TastingModel\n\n\nmodel = Model(\n    # This wine was aged for 20 years and has a quality of 85.6\n    wine=TastingModel(name='Cabernet Sauvignon', aged=20, quality=85.6),\n    # This cheese is aged (is mature) and has \"Good\" quality\n    cheese=TastingModel(name='Gouda', aged=True, quality='Good'),\n    # This Python thing has aged \"Not much\" and has a quality \"Awesome\"\n    thing=TastingModel(name='Python', aged='Not much', quality='Awesome'),\n)\nprint(model)\nprint(model.wine.aged)\nprint(model.wine.quality)\nprint(model.cheese.aged)\nprint(model.cheese.quality)\nprint(model.thing.aged)\ntry:\n    # If the values of the sub-types are invalid, we get an error\n    Model(\n        # For wine, aged should be an int with the years, and quality a float\n        wine=TastingModel(name='Merlot', aged=True, quality='Kinda good'),\n        # For cheese, aged should be a bool, and quality a str\n        cheese=TastingModel(name='Gouda', aged='yeah', quality=5),\n        # For thing, no type parameters are declared, and we skipped validation\n        # in those cases in the Assessment.validate() function\n        thing=TastingModel(name='Python', aged='Not much', quality='Awesome'),\n    )\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/validation_decorator/","title":"\u6821\u9a8c\u88c5\u9970\u5668","text":"<p>The <code>validate_arguments</code> decorator allows the arguments passed to a function to be parsed and validated using the function's annotations before the function is called. While under the hood this uses the same approach of model creation and initialisation; it provides an extremely easy way to apply validation to your code with minimal boilerplate.</p> <p>In Beta</p> <p>The <code>validate_arguments</code> decorator is in beta, it has been added to pydantic in v1.5 on a provisional basis. It may change significantly in future releases and its interface will not be concrete until v2. Feedback from the community while it's still provisional would be extremely useful; either comment on #1205 or create a new issue.</p> <p>Example of usage:</p> <pre><code>from pydantic import validate_arguments, ValidationError\n\n\n@validate_arguments\ndef repeat(s: str, count: int, *, separator: bytes = b'') -&gt; bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n\nb = repeat('x', '4', separator=' ')\nprint(b)\n\ntry:\n    c = repeat('hello', 'wrong')\nexcept ValidationError as exc:\n    print(exc)\n</code></pre>"},{"location":"usage/validation_decorator/#argument-types","title":"Argument Types","text":"<p>Argument types are inferred from type annotations on the function, arguments without a type decorator are considered as <code>Any</code>. Since <code>validate_arguments</code> internally uses a standard <code>BaseModel</code>, all types listed in types can be validated, including pydantic models and custom types. As with the rest of pydantic, types can be coerced by the decorator before they're passed to the actual function:</p> <pre><code>import os\nfrom pathlib import Path\nfrom typing import Pattern, Optional\n\nfrom pydantic import validate_arguments, DirectoryPath\n\n\n@validate_arguments\ndef find_file(path: DirectoryPath, regex: Pattern, max=None) -&gt; Optional[Path]:\n    for i, f in enumerate(path.glob('**/*')):\n        if max and i &gt; max:\n            return\n        if f.is_file() and regex.fullmatch(str(f.relative_to(path))):\n            return f\n\n\n# note: this_dir is a string here\nthis_dir = os.path.dirname(__file__)\n\nprint(find_file(this_dir, '^validation.*'))\nprint(find_file(this_dir, '^foobar.*', max=3))\n</code></pre> <p>A few notes:</p> <ul> <li>though they're passed as strings, <code>path</code> and <code>regex</code> are converted to a <code>Path</code> object and regex respectively by the decorator</li> <li><code>max</code> has no type annotation, so will be considered as <code>Any</code> by the decorator</li> </ul> <p>Type coercion like this can be extremely helpful but also confusing or not desired, see below for a discussion of <code>validate_arguments</code>'s limitations in this regard.</p>"},{"location":"usage/validation_decorator/#function-signatures","title":"Function Signatures","text":"<p>The decorator is designed to work with functions using all possible parameter configurations and all possible combinations of these:</p> <ul> <li>positional or keyword arguments with or without defaults</li> <li>variable positional arguments defined via <code>*</code> (often <code>*args</code>)</li> <li>variable keyword arguments defined via <code>**</code> (often <code>**kwargs</code>)</li> <li>keyword only arguments - arguments after <code>*,</code></li> <li>positional only arguments - arguments before <code>, /</code> (new in Python 3.8)</li> </ul> <p>To demonstrate all the above parameter types:</p> <pre><code># requires python3.8\nfrom pydantic import validate_arguments\n\n\n@validate_arguments\ndef pos_or_kw(a: int, b: int = 2) -&gt; str:\n    return f'a={a} b={b}'\n\n\nprint(pos_or_kw(1))\nprint(pos_or_kw(a=1))\nprint(pos_or_kw(1, 3))\nprint(pos_or_kw(a=1, b=3))\n\n\n@validate_arguments\ndef kw_only(*, a: int, b: int = 2) -&gt; str:\n    return f'a={a} b={b}'\n\n\nprint(kw_only(a=1))\nprint(kw_only(a=1, b=3))\n\n\n@validate_arguments\ndef pos_only(a: int, b: int = 2, /) -&gt; str:  # python 3.8 only\n    return f'a={a} b={b}'\n\n\nprint(pos_only(1))\nprint(pos_only(1, 2))\n\n\n@validate_arguments\ndef var_args(*args: int) -&gt; str:\n    return str(args)\n\n\nprint(var_args(1))\nprint(var_args(1, 2))\nprint(var_args(1, 2, 3))\n\n\n@validate_arguments\ndef var_kwargs(**kwargs: int) -&gt; str:\n    return str(kwargs)\n\n\nprint(var_kwargs(a=1))\nprint(var_kwargs(a=1, b=2))\n\n\n@validate_arguments\ndef armageddon(\n    a: int,\n    /,  # python 3.8 only\n    b: int,\n    c: int = None,\n    *d: int,\n    e: int,\n    f: int = None,\n    **g: int,\n) -&gt; str:\n    return f'a={a} b={b} c={c} d={d} e={e} f={f} g={g}'\n\n\nprint(armageddon(1, 2, e=3))\nprint(armageddon(1, 2, 3, 4, 5, 6, e=8, f=9, g=10, spam=11))\n</code></pre>"},{"location":"usage/validation_decorator/#using-field-to-describe-function-arguments","title":"Using Field to describe function arguments","text":"<p>Field can also be used with <code>validate_arguments</code> to provide extra information about the field and validations. In general it should be used in a type hint with Annotated, unless <code>default_factory</code> is specified, in which case it should be used as the default value of the field:</p> <pre><code>from datetime import datetime\nfrom pydantic import validate_arguments, Field, ValidationError\nfrom pydantic.typing import Annotated\n\n\n@validate_arguments\ndef how_many(num: Annotated[int, Field(gt=10)]):\n    return num\n\n\ntry:\n    how_many(1)\nexcept ValidationError as e:\n    print(e)\n\n\n@validate_arguments\ndef when(dt: datetime = Field(default_factory=datetime.now)):\n    return dt\n\n\nprint(type(when()))\n</code></pre> <p>The alias can be used with the decorator as normal.</p> <pre><code>from pydantic import Field, validate_arguments\nfrom pydantic.typing import Annotated\n\n\n@validate_arguments\ndef how_many(num: Annotated[int, Field(gt=10, alias='number')]):\n    return num\n\n\nhow_many(number=42)\n</code></pre>"},{"location":"usage/validation_decorator/#usage-with-mypy","title":"Usage with mypy","text":"<p>The <code>validate_arguments</code> decorator should work \"out of the box\" with mypy since it's defined to return a function with the same signature as the function it decorates. The only limitation is that since we trick mypy into thinking the function returned by the decorator is the same as the function being decorated; access to the raw function or other attributes will require <code>type: ignore</code>.</p>"},{"location":"usage/validation_decorator/#validate-without-calling-the-function","title":"Validate without calling the function","text":"<p>By default, arguments validation is done by directly calling the decorated function with parameters. But what if you wanted to validate them without actually calling the function? To do that you can call the <code>validate</code> method bound to the decorated function.</p> <pre><code>from pydantic import validate_arguments, ValidationError\n\n\n@validate_arguments\ndef slow_sum(a: int, b: int) -&gt; int:\n    print(f'Called with a={a}, b={b}')\n    return a + b\n\n\nslow_sum(1, 1)\n\nslow_sum.validate(2, 2)\n\ntry:\n    slow_sum.validate(1, 'b')\nexcept ValidationError as exc:\n    print(exc)\n</code></pre>"},{"location":"usage/validation_decorator/#raw-function","title":"Raw function","text":"<p>The raw function which was decorated is accessible, this is useful if in some scenarios you trust your input arguments and want to call the function in the most performant way (see notes on performance below):</p> <pre><code>from pydantic import validate_arguments\n\n\n@validate_arguments\ndef repeat(s: str, count: int, *, separator: bytes = b'') -&gt; bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n\nb = repeat.raw_function('good bye', 2, separator=b', ')\nprint(b)\n</code></pre>"},{"location":"usage/validation_decorator/#async-functions","title":"Async Functions","text":"<p><code>validate_arguments</code> can also be used on async functions:</p> <pre><code>class Connection:\n    async def execute(self, sql, *args):\n        return 'testing@example.com'\n\n\nconn = Connection()\n# ignore-above\nimport asyncio\nfrom pydantic import PositiveInt, ValidationError, validate_arguments\n\n\n@validate_arguments\nasync def get_user_email(user_id: PositiveInt):\n    # `conn` is some fictional connection to a database\n    email = await conn.execute('select email from users where id=$1', user_id)\n    if email is None:\n        raise RuntimeError('user not found')\n    else:\n        return email\n\n\nasync def main():\n    email = await get_user_email(123)\n    print(email)\n    try:\n        await get_user_email(-4)\n    except ValidationError as exc:\n        print(exc.errors())\n\n\nasyncio.run(main())\n# requires: `conn.execute()` that will return `'testing@example.com'`\n</code></pre>"},{"location":"usage/validation_decorator/#custom-config","title":"Custom Config","text":"<p>The model behind <code>validate_arguments</code> can be customised using a config setting which is equivalent to setting the <code>Config</code> sub-class in normal models.</p> <p>Warning</p> <p>The <code>fields</code> and <code>alias_generator</code> properties of <code>Config</code> which allow aliases to be configured are not supported yet with <code>@validate_arguments</code>, using them will raise an error.</p> <p>Configuration is set using the <code>config</code> keyword argument to the decorator, it may be either a config class or a dict of properties which are converted to a class later.</p> <pre><code>from pydantic import ValidationError, validate_arguments\n\n\nclass Foobar:\n    def __init__(self, v: str):\n        self.v = v\n\n    def __add__(self, other: 'Foobar') -&gt; str:\n        return f'{self} + {other}'\n\n    def __str__(self) -&gt; str:\n        return f'Foobar({self.v})'\n\n\n@validate_arguments(config=dict(arbitrary_types_allowed=True))\ndef add_foobars(a: Foobar, b: Foobar):\n    return a + b\n\n\nc = add_foobars(Foobar('a'), Foobar('b'))\nprint(c)\n\ntry:\n    add_foobars(1, 2)\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/validation_decorator/#limitations","title":"Limitations","text":"<p><code>validate_arguments</code> has been released on a provisional basis without all the bells and whistles, which may be added later, see #1205 for some more discussion of this.</p> <p>In particular:</p>"},{"location":"usage/validation_decorator/#validation-exception","title":"Validation Exception","text":"<p>Currently upon validation failure, a standard pydantic <code>ValidationError</code> is raised, see model error handling.</p> <p>This is helpful since it's <code>str()</code> method provides useful details of the error which occurred and methods like <code>.errors()</code> and <code>.json()</code> can be useful when exposing the errors to end users, however <code>ValidationError</code> inherits from <code>ValueError</code> not <code>TypeError</code> which may be unexpected since Python would raise a <code>TypeError</code> upon invalid or missing arguments. This may be addressed in future by either allow a custom error or raising a different exception by default, or both.</p>"},{"location":"usage/validation_decorator/#coercion-and-strictness","title":"Coercion and Strictness","text":"<p>pydantic currently leans on the side of trying to coerce types rather than raise an error if a type is wrong, see model data conversion and <code>validate_arguments</code> is no different.</p> <p>See #1098 and other issues with the \"strictness\" label for a discussion of this. If pydantic gets a \"strict\" mode in future, <code>validate_arguments</code> will have an option to use this, it may even become the default for the decorator.</p>"},{"location":"usage/validation_decorator/#performance","title":"Performance","text":"<p>We've made a big effort to make pydantic as performant as possible and argument inspect and model creation is only performed once when the function is defined, however there will still be a performance impact to using the <code>validate_arguments</code> decorator compared to calling the raw function.</p> <p>In many situations this will have little or no noticeable effect, however be aware that <code>validate_arguments</code> is not an equivalent or alternative to function definitions in strongly typed languages; it never will be.</p>"},{"location":"usage/validation_decorator/#return-value","title":"Return Value","text":"<p>The return value of the function is not validated against its return type annotation, this may be added as an option in future.</p>"},{"location":"usage/validation_decorator/#config-and-validators","title":"Config and Validators","text":"<p><code>fields</code> and <code>alias_generator</code> on custom <code>Config</code> are not supported, see above.</p> <p>Neither are validators.</p>"},{"location":"usage/validation_decorator/#model-fields-and-reserved-arguments","title":"Model fields and reserved arguments","text":"<p>The following names may not be used by arguments since they can be used internally to store information about the function's signature:</p> <ul> <li><code>v__args</code></li> <li><code>v__kwargs</code></li> <li><code>v__positional_only</code></li> </ul> <p>These names (together with <code>\"args\"</code> and <code>\"kwargs\"</code>) may or may not (depending on the function's signature) appear as fields on the internal pydantic model accessible via <code>.model</code> thus this model isn't especially useful (e.g. for generating a schema) at the moment.</p> <p>This should be fixable in future as the way error are raised is changed.</p>"},{"location":"usage/validators/","title":"\u5b57\u6bb5\u6821\u9a8c","text":"<p>Custom validation and complex relationships between objects can be achieved using the <code>validator</code> decorator.</p> <pre><code>from pydantic import BaseModel, ValidationError, validator\n\n\nclass UserModel(BaseModel):\n    name: str\n    username: str\n    password1: str\n    password2: str\n\n    @validator('name')\n    def name_must_contain_space(cls, v):\n        if ' ' not in v:\n            raise ValueError('must contain a space')\n        return v.title()\n\n    @validator('password2')\n    def passwords_match(cls, v, values, **kwargs):\n        if 'password1' in values and v != values['password1']:\n            raise ValueError('passwords do not match')\n        return v\n\n    @validator('username')\n    def username_alphanumeric(cls, v):\n        assert v.isalnum(), 'must be alphanumeric'\n        return v\n\n\nuser = UserModel(\n    name='samuel colvin',\n    username='scolvin',\n    password1='zxcvbn',\n    password2='zxcvbn',\n)\nprint(user)\n\ntry:\n    UserModel(\n        name='samuel',\n        username='scolvin',\n        password1='zxcvbn',\n        password2='zxcvbn2',\n    )\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>A few things to note on validators:</p> <ul> <li>validators are \"class methods\", so the first argument value they receive is the <code>UserModel</code> class, not an instance   of <code>UserModel</code>.</li> <li>the second argument is always the field value to validate; it can be named as you please</li> <li>you can also add any subset of the following arguments to the signature (the names must match):<ul> <li><code>values</code>: a dict containing the name-to-value mapping of any previously-validated fields</li> <li><code>config</code>: the model config</li> <li><code>field</code>: the field being validated. Type of object is <code>pydantic.fields.ModelField</code>.</li> <li><code>**kwargs</code>: if provided, this will include the arguments above not explicitly listed in the signature</li> </ul> </li> <li>validators should either return the parsed value or raise a <code>ValueError</code>, <code>TypeError</code>, or <code>AssertionError</code>   (<code>assert</code> statements may be used).</li> </ul> <p>Warning</p> <p>If you make use of <code>assert</code> statements, keep in mind that running Python with the <code>-O</code> optimization flag disables <code>assert</code> statements, and validators will stop working.</p> <ul> <li> <p>where validators rely on other values, you should be aware that:</p> <ul> <li>Validation is done in the order fields are defined.   E.g. in the example above, <code>password2</code> has access to <code>password1</code> (and <code>name</code>),   but <code>password1</code> does not have access to <code>password2</code>. See Field Ordering   for more information on how fields are ordered</li> </ul> <ul> <li>If validation fails on another field (or that field is missing) it will not be included in <code>values</code>, hence   <code>if 'password1' in values and ...</code> in this example.</li> </ul> </li> </ul>"},{"location":"usage/validators/#pre-and-per-item-validators","title":"Pre and per-item validators","text":"<p>Validators can do a few more complex things:</p> <pre><code>from typing import List\nfrom pydantic import BaseModel, ValidationError, validator\n\n\nclass DemoModel(BaseModel):\n    square_numbers: List[int] = []\n    cube_numbers: List[int] = []\n\n    # '*' is the same as 'cube_numbers', 'square_numbers' here:\n    @validator('*', pre=True)\n    def split_str(cls, v):\n        if isinstance(v, str):\n            return v.split('|')\n        return v\n\n    @validator('cube_numbers', 'square_numbers')\n    def check_sum(cls, v):\n        if sum(v) &gt; 42:\n            raise ValueError('sum of numbers greater than 42')\n        return v\n\n    @validator('square_numbers', each_item=True)\n    def check_squares(cls, v):\n        assert v ** 0.5 % 1 == 0, f'{v} is not a square number'\n        return v\n\n    @validator('cube_numbers', each_item=True)\n    def check_cubes(cls, v):\n        # 64 ** (1 / 3) == 3.9999999999999996 (!)\n        # this is not a good way of checking cubes\n        assert v ** (1 / 3) % 1 == 0, f'{v} is not a cubed number'\n        return v\n\n\nprint(DemoModel(square_numbers=[1, 4, 9]))\nprint(DemoModel(square_numbers='1|4|16'))\nprint(DemoModel(square_numbers=[16], cube_numbers=[8, 27]))\ntry:\n    DemoModel(square_numbers=[1, 4, 2])\nexcept ValidationError as e:\n    print(e)\n\ntry:\n    DemoModel(cube_numbers=[27, 27])\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>A few more things to note:</p> <ul> <li>a single validator can be applied to multiple fields by passing it multiple field names</li> <li>a single validator can also be called on all fields by passing the special value <code>'*'</code></li> <li>the keyword argument <code>pre</code> will cause the validator to be called prior to other validation</li> <li>passing <code>each_item=True</code> will result in the validator being applied to individual values   (e.g. of <code>List</code>, <code>Dict</code>, <code>Set</code>, etc.), rather than the whole object</li> </ul>"},{"location":"usage/validators/#subclass-validators-and-each_item","title":"Subclass Validators and <code>each_item</code>","text":"<p>If using a validator with a subclass that references a <code>List</code> type field on a parent class, using <code>each_item=True</code> will cause the validator not to run; instead, the list must be iterated over programmatically.</p> <pre><code>from typing import List\nfrom pydantic import BaseModel, ValidationError, validator\n\n\nclass ParentModel(BaseModel):\n    names: List[str]\n\n\nclass ChildModel(ParentModel):\n    @validator('names', each_item=True)\n    def check_names_not_empty(cls, v):\n        assert v != '', 'Empty strings are not allowed.'\n        return v\n\n\n# This will NOT raise a ValidationError because the validator was not called\ntry:\n    child = ChildModel(names=['Alice', 'Bob', 'Eve', ''])\nexcept ValidationError as e:\n    print(e)\nelse:\n    print('No ValidationError caught.')\n\n\nclass ChildModel2(ParentModel):\n    @validator('names')\n    def check_names_not_empty(cls, v):\n        for name in v:\n            assert name != '', 'Empty strings are not allowed.'\n        return v\n\n\ntry:\n    child = ChildModel2(names=['Alice', 'Bob', 'Eve', ''])\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"usage/validators/#validate-always","title":"Validate Always","text":"<p>For performance reasons, by default validators are not called for fields when a value is not supplied. However there are situations where it may be useful or required to always call the validator, e.g. to set a dynamic default value.</p> <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel, validator\n\n\nclass DemoModel(BaseModel):\n    ts: datetime = None\n\n    @validator('ts', pre=True, always=True)\n    def set_ts_now(cls, v):\n        return v or datetime.now()\n\n\nprint(DemoModel())\nprint(DemoModel(ts='2017-11-08T14:00'))\n</code></pre> <p>You'll often want to use this together with <code>pre</code>, since otherwise with <code>always=True</code> pydantic would try to validate the default <code>None</code> which would cause an error.</p>"},{"location":"usage/validators/#reuse-validators","title":"Reuse validators","text":"<p>Occasionally, you will want to use the same validator on multiple fields/models (e.g. to normalize some input data). The \"naive\" approach would be to write a separate function, then call it from multiple decorators.  Obviously, this entails a lot of repetition and boiler plate code. To circumvent this, the <code>allow_reuse</code> parameter has been added to <code>pydantic.validator</code> in v1.2 (<code>False</code> by default):</p> <pre><code>from pydantic import BaseModel, validator\n\n\ndef normalize(name: str) -&gt; str:\n    return ' '.join((word.capitalize()) for word in name.split(' '))\n\n\nclass Producer(BaseModel):\n    name: str\n\n    # validators\n    _normalize_name = validator('name', allow_reuse=True)(normalize)\n\n\nclass Consumer(BaseModel):\n    name: str\n\n    # validators\n    _normalize_name = validator('name', allow_reuse=True)(normalize)\n\n\njane_doe = Producer(name='JaNe DOE')\njohn_doe = Consumer(name='joHN dOe')\nassert jane_doe.name == 'Jane Doe'\nassert john_doe.name == 'John Doe'\n</code></pre> <p>As it is obvious, repetition has been reduced and the models become again almost declarative.</p> <p>Tip</p> <p>If you have a lot of fields that you want to validate, it usually makes sense to define a help function with which you will avoid setting <code>allow_reuse=True</code> over and over again.</p>"},{"location":"usage/validators/#root-validators","title":"Root Validators","text":"<p>Validation can also be performed on the entire model's data.</p> <pre><code>from pydantic import BaseModel, ValidationError, root_validator\n\n\nclass UserModel(BaseModel):\n    username: str\n    password1: str\n    password2: str\n\n    @root_validator(pre=True)\n    def check_card_number_omitted(cls, values):\n        assert 'card_number' not in values, 'card_number should not be included'\n        return values\n\n    @root_validator\n    def check_passwords_match(cls, values):\n        pw1, pw2 = values.get('password1'), values.get('password2')\n        if pw1 is not None and pw2 is not None and pw1 != pw2:\n            raise ValueError('passwords do not match')\n        return values\n\n\nprint(UserModel(username='scolvin', password1='zxcvbn', password2='zxcvbn'))\ntry:\n    UserModel(username='scolvin', password1='zxcvbn', password2='zxcvbn2')\nexcept ValidationError as e:\n    print(e)\n\ntry:\n    UserModel(\n        username='scolvin',\n        password1='zxcvbn',\n        password2='zxcvbn',\n        card_number='1234',\n    )\nexcept ValidationError as e:\n    print(e)\n</code></pre> <p>As with field validators, root validators can have <code>pre=True</code>, in which case they're called before field validation occurs (and are provided with the raw input data), or <code>pre=False</code> (the default), in which case they're called after field validation.</p> <p>Field validation will not occur if <code>pre=True</code> root validators raise an error. As with field validators, \"post\" (i.e. <code>pre=False</code>) root validators by default will be called even if prior validators fail; this behaviour can be changed by setting the <code>skip_on_failure=True</code> keyword argument to the validator. The <code>values</code> argument will be a dict containing the values which passed field validation and field defaults where applicable.</p>"},{"location":"usage/validators/#field-checks","title":"Field Checks","text":"<p>On class creation, validators are checked to confirm that the fields they specify actually exist on the model.</p> <p>Occasionally however this is undesirable: e.g. if you define a validator to validate fields on inheriting models. In this case you should set <code>check_fields=False</code> on the validator.</p>"},{"location":"usage/validators/#dataclass-validators","title":"Dataclass Validators","text":"<p>Validators also work with pydantic dataclasses.</p> <pre><code>from datetime import datetime\n\nfrom pydantic import validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass DemoDataclass:\n    ts: datetime = None\n\n    @validator('ts', pre=True, always=True)\n    def set_ts_now(cls, v):\n        return v or datetime.now()\n\n\nprint(DemoDataclass())\nprint(DemoDataclass(ts='2017-11-08T14:00'))\n</code></pre>"}]}